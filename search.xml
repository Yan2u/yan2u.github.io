<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划 | 数论 | Scoi2009 Windy数</title>
    <url>/2019/03/04/2019-03-04-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E4%BD%8D-scoi2009-windy%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<p><font color=green> Description </font><br>windy定义了一种windy数。相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>包含两个整数，A B。</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>包含一个整数。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 10</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>20%的数据，满足 1 &lt;= A &lt;= B &lt;= 1000000 。100%的数据，满足 1 &lt;= A &lt;= B &lt;= 2000000000 。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>Success Text.<br>{:.success}</p>
<h1 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 66</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> spr[maxn];</span><br><span class="line">LL f[maxn][maxn];</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p,<span class="type">bool</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!lim &amp;&amp; f[x][p]!=<span class="number">-1</span>) <span class="keyword">return</span> f[x][p];</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> imax=lim?spr[x]:<span class="number">9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=imax;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(i-p)&lt;<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; p==<span class="number">11</span>) ans+=<span class="built_in">dfs</span>(x<span class="number">-1</span>,<span class="number">11</span>,lim &amp;&amp; i==imax);</span><br><span class="line">		<span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(x<span class="number">-1</span>,i,lim &amp;&amp; i==imax);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!lim) f[x][p]=ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">res</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// spr[0] 存位数 </span></span><br><span class="line">	<span class="built_in">memset</span>(spr,<span class="number">0</span>,<span class="built_in">sizeof</span>(spr));</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		spr[++spr[<span class="number">0</span>]]=x%<span class="number">10</span>;</span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125; spr[spr[<span class="number">0</span>]+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(spr[<span class="number">0</span>],<span class="number">11</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">res</span>(b)-<span class="built_in">res</span>(a<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>分治 | 二分 | 防线</title>
    <url>/2019/03/10/2019-03-10-%E9%98%B2%E7%BA%BF/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>lsp学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的lsp 黑化成为了黑暗英雄 Lord lsp。就如二漫画的情节一样， Lord lsp 打算毁掉这个世界。数学竞赛界的精英 lqr 打算阻止 Lord lsp 的阴谋，于是她集合了一支由数学</p>
<p>竞赛选手组成的超级行动队。由于队员们个个都智商超群，很快，行动队便来到了 Lord lsp 的黑暗城堡的下方。</p>
<p>但是，同样强大的 Lord lsp 在城堡周围布置了一条“不可越过”的坚固防线。防线由很多防具组成，这些防具分成了 N 组。我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。也就是说，我们可以用三个整数 S， E 和 D 来描述一组防具，即这一组防具布置在防线的 S，S + D，S + 2D，…，S + KD（K∈Z，S + KD≤E，S + (K + 1)D＞E）位置上。</p>
<p>黑化的 Lord lsp 设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的（包括这个位置一个防具也没有的情况，因为 0 也是偶数）。只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学妹们，你们要帮助她解决这个问题。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件的第一行是一个整数 T，表示有 T 组互相独立的测试数据。</p>
<p>每组数据的第一行是一个整数 N。</p>
<p>之后 N 行，每行三个整数 Si，Ei，Di，代表第 i 组防具的三个参数。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组测试数据，如果防线没有破绽，即所有的位置都有偶数个防具，输出一行“There’s no weakness.”（不包含引号） 否则在一行内输出两个空格分隔的整数 P 和 C，表示在位置 P 有 C 个防具。当然 C 应该是一个奇数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 </span><br><span class="line">1 10 1 </span><br><span class="line">2 10 1 </span><br><span class="line">2 </span><br><span class="line">1 10 1 </span><br><span class="line">1 10 1</span><br><span class="line">4 </span><br><span class="line">1 10 1 </span><br><span class="line">4 4 1 </span><br><span class="line">1 5 1 </span><br><span class="line">6 10 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1 1 </span><br><span class="line">There’s no weakness.</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>
<h2 id="xxxxxxxxxx66-1-include-2-include-3-include-4-include-5-include-6-include-7-include-8-define-maxn-10019-define-pf-x-xx-10using-namespace-std-11typedef-long-long-ll-12struct-node-13-int-a-b-14-double-val-15-bool-operator-lt-const-node-amp-obj-const-16-return-val-lt-obj-val-17-18-g-maxnmaxn-19int-tot-f-maxn-20double-res-maxn-21pair-d-maxn-int-s-p-22inline-double-getdis-ll-x1-ll-x2-ll-y1-ll-y2-23-return-sqrt-pf-abs-x1-x2-pf-abs-y1-y2-24-25int-Sfind-int-x-26-if-f-x-x-return-x-27-else-return-f-x-Sfind-f-x-28-29inline-void-Sunion-int-u1-int-u2-30-int-fa-Sfind-u1-31-int-fb-Sfind-u2-32-f-fa-fb-33-34inline-void-makeEdge-35-for-int-i-1-i-lt-p-i-36-for-int-j-i-1-j-lt-p-j-37-g-tot-node-i-j-38-getdis-d-i-first-d-j-first-d-i-second-d-j-second-39-40-41double-kruskal-42-int-cnt-0-43-sort-g-1-g-tot-1-44-for-int-i-1-i-lt-tot-i-45-if-Sfind-g-i-a-Sfind-g-i-b-46-res-cnt-g-i-val-47-Sunion-g-i-a-g-i-b-48-49-return-res-cnt-s-1-50-51int-main-52-ifndef-ONLINE-JUDGE53-freopen-“testin-txt”-”r”-stdin-54-freopen-“testout-txt”-”w”-stdout-55-endif56-cin-gt-gt-s-gt-gt-p-57-if-s-gt-p-58-cout-lt-lt-”0-00”-59-return-0-60-61-for-int-i-1-i-lt-p-i-62-cin-gt-gt-d-i-first-gt-gt-d-i-second-63-makeEdge-for-int-i-0-i-lt-p-i-f-i-i-64-printf-“-2lf”-kruskal-65-return-0-66-cpp"><a href="#xxxxxxxxxx66-1-include-2-include-3-include-4-include-5-include-6-include-7-include-8-define-maxn-10019-define-pf-x-xx-10using-namespace-std-11typedef-long-long-ll-12struct-node-13-int-a-b-14-double-val-15-bool-operator-lt-const-node-amp-obj-const-16-return-val-lt-obj-val-17-18-g-maxnmaxn-19int-tot-f-maxn-20double-res-maxn-21pair-d-maxn-int-s-p-22inline-double-getdis-ll-x1-ll-x2-ll-y1-ll-y2-23-return-sqrt-pf-abs-x1-x2-pf-abs-y1-y2-24-25int-Sfind-int-x-26-if-f-x-x-return-x-27-else-return-f-x-Sfind-f-x-28-29inline-void-Sunion-int-u1-int-u2-30-int-fa-Sfind-u1-31-int-fb-Sfind-u2-32-f-fa-fb-33-34inline-void-makeEdge-35-for-int-i-1-i-lt-p-i-36-for-int-j-i-1-j-lt-p-j-37-g-tot-node-i-j-38-getdis-d-i-first-d-j-first-d-i-second-d-j-second-39-40-41double-kruskal-42-int-cnt-0-43-sort-g-1-g-tot-1-44-for-int-i-1-i-lt-tot-i-45-if-Sfind-g-i-a-Sfind-g-i-b-46-res-cnt-g-i-val-47-Sunion-g-i-a-g-i-b-48-49-return-res-cnt-s-1-50-51int-main-52-ifndef-ONLINE-JUDGE53-freopen-“testin-txt”-”r”-stdin-54-freopen-“testout-txt”-”w”-stdout-55-endif56-cin-gt-gt-s-gt-gt-p-57-if-s-gt-p-58-cout-lt-lt-”0-00”-59-return-0-60-61-for-int-i-1-i-lt-p-i-62-cin-gt-gt-d-i-first-gt-gt-d-i-second-63-makeEdge-for-int-i-0-i-lt-p-i-f-i-i-64-printf-“-2lf”-kruskal-65-return-0-66-cpp" class="headerlink" title="xxxxxxxxxx66 1#include 2#include 3#include 4#include 5#include 6#include 7#include 8#define maxn 10019#define pf(x) (xx)10using namespace std;11typedef long long ll;12struct node{13    int a,b;14    double val;15    bool operator &lt;(const node &amp;obj)const{16        return val&lt;obj.val;17    }18}g[maxnmaxn];19int tot,f[maxn];20double res[maxn];21pair d[maxn]; int s,p;22inline double getdis(ll x1,ll x2,ll y1,ll y2){23    return sqrt(pf(abs(x1-x2))+pf(abs(y1-y2)));24}25int Sfind(int x){26    if(f[x]==x) return x;27    else return f[x]=Sfind(f[x]);28}29inline void Sunion(int u1,int u2){30    int fa=Sfind(u1);31    int fb=Sfind(u2);32    f[fa]=fb;33}34inline void makeEdge(){35    for(int i=1;i&lt;=p;i++)36        for(int j=i+1;j&lt;=p;j++)37            g[++tot]=(node){i,j,38                getdis(d[i].first,d[j].first,d[i].second,d[j].second)39            };40}41double kruskal(){42    int cnt=0;43    sort(g+1,g+tot+1);44    for(int i=1;i&lt;=tot;i++){45        if(Sfind(g[i].a)!=Sfind(g[i].b))46            res[++cnt]=g[i].val,47            Sunion(g[i].a,g[i].b);48    }49    return res[cnt-s+1];50}51int main(){52    #ifndef ONLINE_JUDGE53    freopen(“testin.txt”,”r”,stdin);54    freopen(“testout.txt”,”w”,stdout);55    #endif56    cin&gt;&gt;s&gt;&gt;p;57    if(s&gt;=p){58        cout&lt;&lt;”0.00”;59        return 0;60    }61    for(int i=1;i&lt;=p;i++)62        cin&gt;&gt;d[i].first&gt;&gt;d[i].second;63    makeEdge(); for(int i=0;i&lt;=p;i++) f[i]=i;64    printf(“%.2lf”,kruskal());65    return 0;66}cpp"></a>xxxxxxxxxx66 1#include <cstdio>2#include <iostream>3#include <algorithm>4#include <cstring>5#include <utility>6#include <vector>7#include <cmath>8#define maxn 10019#define pf(x) (x<em>x)10using namespace std;11typedef long long ll;12struct node{13    int a,b;14    double val;15    bool operator &lt;(const node &amp;obj)const{16        return val&lt;obj.val;17    }18}g[maxn</em>maxn];19int tot,f[maxn];20double res[maxn];21pair<ll,ll> d[maxn]; int s,p;22inline double getdis(ll x1,ll x2,ll y1,ll y2){23    return sqrt(pf(abs(x1-x2))+pf(abs(y1-y2)));24}25int Sfind(int x){26    if(f[x]==x) return x;27    else return f[x]=Sfind(f[x]);28}29inline void Sunion(int u1,int u2){30    int fa=Sfind(u1);31    int fb=Sfind(u2);32    f[fa]=fb;33}34inline void makeEdge(){35    for(int i=1;i&lt;=p;i++)36        for(int j=i+1;j&lt;=p;j++)37            g[++tot]=(node){i,j,38                getdis(d[i].first,d[j].first,d[i].second,d[j].second)39            };40}41double kruskal(){42    int cnt=0;43    sort(g+1,g+tot+1);44    for(int i=1;i&lt;=tot;i++){45        if(Sfind(g[i].a)!=Sfind(g[i].b))46            res[++cnt]=g[i].val,47            Sunion(g[i].a,g[i].b);48    }49    return res[cnt-s+1];50}51int main(){52    #ifndef ONLINE_JUDGE53    freopen(“testin.txt”,”r”,stdin);54    freopen(“testout.txt”,”w”,stdout);55    #endif56    cin&gt;&gt;s&gt;&gt;p;57    if(s&gt;=p){58        cout&lt;&lt;”0.00”;59        return 0;60    }61    for(int i=1;i&lt;=p;i++)62        cin&gt;&gt;d[i].first&gt;&gt;d[i].second;63    makeEdge(); for(int i=0;i&lt;=p;i++) f[i]=i;64    printf(“%.2lf”,kruskal());65    return 0;66}cpp</h2><p>对于 30% 的数据，满足防具总数不多于 10^7。</p>
<p>对于 100% 的数据，满足防具总数不多于 10^8，Si≤Ei，1≤T≤5，N≤200000，0≤Si，Ei，Di≤2^31-1。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于题目中给出，所有位置中，只有一个位置有奇数个防具</p>
<p>那么很容易判断无解条件：即所有位置防具总数之和为偶数</p>
<p>不同条件下，目标位置的奇数个防具会使得：在它前面的位置的防具总数为偶数，在它之后的位置的防具总数是奇数（这里是前缀和），整体二分即可</p>
<p>把每条命令搞成结构体，那么每条命令放下的防具总数就是：</p>
<script type="math/tex; mode=display">
(End-Start)\div Delta +1</script><h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,T;</span><br><span class="line">ll l,r,mid;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> S,E,D;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(S!=obj.S) <span class="keyword">return</span> S&lt;obj.S;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> E&lt;obj.E;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll pos)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>; <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[i].E&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(g[i].S&gt;pos) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&gt;g[i].E) ans+=(g[i].E-g[i].S)/g[i].D+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> ans+=(pos-g[i].S)/g[i].D+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">nosol</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ans+=(g[i].E-g[i].S)/g[i].D+<span class="number">1</span>;</span><br><span class="line">		ans%=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (ans==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[i].E&lt;pos) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(g[i].S&gt;pos) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>((pos-g[i].S)%g[i].D==<span class="number">0</span>) ret++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t2.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t2.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			cin&gt;&gt;g[i].S&gt;&gt;g[i].E&gt;&gt;g[i].D;</span><br><span class="line">		<span class="built_in">sort</span>(g+<span class="number">1</span>,g+n+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">nosol</span>()) cout&lt;&lt;<span class="string">&quot;There&#x27;s no weakness.&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			l=g[<span class="number">1</span>].S;</span><br><span class="line">			r=g[n].E;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">				mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">				<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="built_in">res</span>(l)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>VB.NET小程序</title>
    <url>/2019/03/09/2019-03-09-LRCEDITOR/</url>
    <content><![CDATA[<span id="more"></span>
<blockquote>
<p><strong>分享一个最近写的歌词编辑小程序：$LrcEditor$</strong></p>
</blockquote>
<p><a href="https://share.weiyun.com/5iM2eQm">下载地址（腾讯微云）</a></p>
<p><strong>目前可以实现的功能：</strong></p>
<ul>
<li>对歌词进行编辑，按时间顺序排序并展示</li>
<li>按照LRC​文件的格式输出歌词文件</li>
</ul>
<p><strong>$BUG$ 和 待完善的功能：</strong></p>
<ul>
<li>添加歌曲同步录制功能</li>
<li>异常卡死（有时）</li>
</ul>
<p><strong>程序信息：</strong></p>
<ul>
<li>exe文件路径：\lrceditor\lrceditor\bin\Debug</li>
<li>解决方案（在VS2017下编辑）：\lrceditor\lrceditor.sln</li>
</ul>
<p>欢迎发表评论（指点 $or$ 讨论都可以）！</p>
]]></content>
      <categories>
        <category>VB.NET</category>
      </categories>
      <tags>
        <tag>VB.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>分治 | Best Cow Fences</title>
    <url>/2019/03/10/2019-03-10-BESTCOWFENCES/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Farmer John’s farm consists of a long row of N (1 &lt;= N &lt;= 100,000)fields. Each field contains a certain number of cows, 1 &lt;= ncows &lt;= 2000.</p>
<p>FJ wants to build a fence around a contiguous group of these fields in order to maximize the average number of cows per field within that block. The block must contain at least F(1 &lt;= F &lt;= N) fields, where F given as input.</p>
<p>Calculate the fence placement that maximizes the average, given the constraint. </p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><ul>
<li><p>Line 1: Two space-separated integers, N and F.</p>
</li>
<li><p>Lines 2..N+1: Each line contains a single integer, the number of cows in a field. Line 2 gives the number of cows in field 1,line 3 gives the number in field 2, and so on.</p>
</li>
</ul>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><ul>
<li>Line 1: A single integer that is 1000 times the maximal average.Do not perform rounding, just print the integer that is 1000*ncows/nfields.</li>
</ul>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 6</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">6500</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>USACO 2003 March Green</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>二分题目所求的连续序列平均数</strong>，需要用到前缀和，递推式：</p>
<script type="math/tex; mode=display">
f[i]=max(\sum_{k=1}^iv[i]-\sum_{i=1}^jv[j]，j\in [1,i-f])</script><p>发现 $\sum_{k=1}^iv[i]$ 是定值，可以用前缀和处理出来，于是：</p>
<script type="math/tex; mode=display">
f[i]=sum(i)-min(sum(j)，j\in [1,i-f])</script><p>而 $i$ 变到 $i+1$ 时，$j$ 的选择范围扩大了 $1$ ，于是：</p>
<script type="math/tex; mode=display">
min(sum(j+1))=min(min(sum(j)，sum(j+1))</script><p><strong>预处理 + 二分猜答案来做</strong></p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e-6</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> v[maxn]; <span class="type">int</span> n,f;</span><br><span class="line"><span class="type">double</span> prefix[maxn];</span><br><span class="line"><span class="type">double</span> minu[maxn];</span><br><span class="line"><span class="type">double</span> maxar,minar;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> avar)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		prefix[i]=prefix[i<span class="number">-1</span>]+v[i]-avar;</span><br><span class="line">		minu[i]=<span class="built_in">min</span>(minu[i<span class="number">-1</span>],prefix[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">-99999.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=f;i&lt;=n;i++)</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,prefix[i]-minu[i-f]);</span><br><span class="line">	<span class="keyword">return</span> ans&gt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t1.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t1.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;f;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;v[i]);</span><br><span class="line">		v[i]*<span class="number">1.0</span>; minar+=v[i];</span><br><span class="line">		maxar+=v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	minar=minar/(<span class="type">double</span>)(n);</span><br><span class="line">	<span class="type">double</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">abs</span>(minar-maxar)&gt;=INF)&#123;</span><br><span class="line">		mid=(minar+maxar)/<span class="number">2.0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) minar=mid;</span><br><span class="line">		<span class="keyword">else</span> maxar=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(<span class="type">int</span>)(maxar*<span class="number">1000</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | 数位 | Round Numbers</title>
    <url>/2019/03/09/2019-03-09-RoundNumbers/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>The cows, as you know, have no  fingers or thumbs and thus are unable to play Scissors, Paper, Stone’  (also known as ‘Rock, Paper, Scissors’, ‘Ro, Sham, Bo’,and a host of  other names) in order to make arbitrary decisions such as who gets to be  milked first. They can’t even flip a coin because it’s so hard to  tossusing hooves.</p>
<p>Theyhave thus resorted to “round number”  matching. The first cow picks aninteger less than two billion. The  second cow does the same. If the numbers areboth “round numbers”, the  first cow wins, otherwise the second cowwins.</p>
<p>A positive integer  N is said to be a “round number” if the binary representation of N has as  many or more zero es than it has ones. For example,the integer 9, when  written in binary form, is 1001. 1001 has two zero es and two ones; thus, 9  is a round number. The integer 26 is 11010 in binary; since it has two  zero es and three ones, it is not a round number.</p>
<p>Obviously,it  takes cows a while to convert numbers to binary, so the winner takes a  while to determine. Bessie wants to cheat and thinks she can do that if  she knows how many “round numbers” are in a given range.</p>
<p>Helpher by  writing a program that tells how many round numbers appear in  theinclusive range given by the input (1 &lt; Start &lt; Finish  &lt;2,000,000,000).</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Line 1: Two space-separated integers, respectively Start and Finish.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Line 1: A single integer that is the count of round numbers in the inclusive range Start..Finish</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2 12</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>No Hint</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道数位 $DP$ 题，根据题目要求，要在 $[L，R]$ 区间内求出转化为二进制之后 $0$ 的个数不少于 $1 $ 的个数的数字个数，用<strong>试填法 + $DFS$ 的记忆化实现</strong></p>
<p>注意前导0的问题，代码中用 $lead$ l来指示前导0</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 41</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL dp[maxn][maxn][maxn];</span><br><span class="line"><span class="type">int</span> spr[maxn];</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c1,<span class="type">int</span> c0,<span class="type">bool</span> lead,<span class="type">bool</span> lim)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> c0&gt;=c1;</span><br><span class="line">	<span class="keyword">if</span>(!lim &amp;&amp; dp[x][c1][c0]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[x][c1][c0];</span><br><span class="line">	LL ans=<span class="number">0</span>; <span class="type">int</span> imax=lim?spr[x]:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=imax;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">			ans+=<span class="built_in">dfs</span>(x<span class="number">-1</span>,c1+<span class="number">1</span>,c0,lead &amp;&amp; i==<span class="number">0</span>,lim &amp;&amp; i==imax);</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; lead)</span><br><span class="line">			ans+=<span class="built_in">dfs</span>(x<span class="number">-1</span>,c1,c0,lead &amp;&amp; i==<span class="number">0</span>,lim &amp;&amp; i==imax);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">			ans+=<span class="built_in">dfs</span>(x<span class="number">-1</span>,c1,c0+<span class="number">1</span>,lead &amp;&amp; i==<span class="number">0</span>,lim &amp;&amp; i==imax);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dp[x][c1][c0]==<span class="number">-1</span>) dp[x][c1][c0]=ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">res</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(spr,<span class="number">0</span>,<span class="built_in">sizeof</span>(spr));</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		spr[++cnt]=x&amp;<span class="number">1</span>;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t2.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t2.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	LL a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">res</span>(b)-<span class="built_in">res</span>(a<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>分治 | [USACO06JAN]把牛Corral the Cows</title>
    <url>/2019/03/11/2019-03-11-USACO06JAN%E6%8A%8A%E7%89%9BCorraltheCow/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Desciption"><a href="#Desciption" class="headerlink" title="Desciption"></a>Desciption</h2><p>Farmer John wishes to build a corral for his cows. Being finicky beasts, they demand that the corral be square and that the corral contain at least C (1 &lt;= C &lt;= 500) clover fields for afternoon treats. The corral’s edges must be parallel to the X,Y axes.</p>
<p>FJ’s land contains a total of N (C &lt;= N &lt;= 500) clover fields, each a block of size 1 x 1 and located at with its lower left corner at integer X and Y coordinates each in the range 1..10,000. Sometimes more than one clover field grows at the same location; such a field would have its location appear twice (or more) in the input. A corral surrounds a clover field if the field is entirely located inside the corral’s borders.</p>
<p>Help FJ by telling him the side length of the smallest square containing C clover fields.</p>
<p>约翰打算建一个围栏来圈养他的奶牛.作为最挑剔的兽类，奶牛们要求这个围栏必须是正方 形的，而且围栏里至少要有C&lt; 500)个草场，来供应她们的午餐.</p>
<p>约翰的土地上共有C&lt;=N&lt;=500)个草场，每个草场在一块1x1的方格内，而且这个方格的 坐标不会超过10000.有时候，会有多个草场在同一个方格内，那他们的坐标就会相同.</p>
<p>告诉约翰，最小的围栏的边长是多少？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Line 1: Two space-separated integers: C and N</p>
<p>Lines 2..N+1: Each line contains two space-separated integers that are the X,Y coordinates of a clover field.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Line 1: A single line with a single integer that is length of one edge of the minimum size square that contains at least C clover fields.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">4 1</span><br><span class="line">5 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>Explanation of the sample:</p>
<p>|<em> </em></p>
<p>| <em> </em></p>
<p>+———Below is one 4x4 solution (C’s show most of the corral’s area); many others exist.</p>
<p>|CCCC</p>
<p>|CCCC</p>
<p>|<em>CCC</em></p>
<p>|C<em>C</em></p>
<p>+———</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>二分搜索栅栏的边长</strong>，每次将边长带入到图中，计算出最多能覆盖到的草场的数量即可<br>{:.success}</p>
<p>要计算覆盖草场的数量，选定一块草场 $i$ ，将 $x[i]$ 设为覆盖的上边界，得出下边界，在上边界和下边界中二分查找（使用 $ lower_\;bound $）找到左右边界的草场编号范围（当然这需要提前对草场位置排序）</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr(na,st,ed) for(int na=st;na&lt;=ed;na++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="type">int</span> id1[maxn],id2[maxn];</span><br><span class="line"><span class="type">int</span> n,c; <span class="type">int</span> l=<span class="number">1</span>,r,mid;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> q,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x[q]&lt;x[w];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(<span class="type">int</span> q,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y[q]&lt;y[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> st,ed,k,sum;</span><br><span class="line">	<span class="built_in">fr</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		k=<span class="number">1</span>; sum=<span class="number">0</span>;</span><br><span class="line">		st=x[id1[i]]; ed=st+size<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">fr</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">			<span class="keyword">while</span>(y[id2[k]]-y[id2[j]]+<span class="number">1</span>&lt;=size &amp;&amp; k&lt;=n)&#123;</span><br><span class="line">				<span class="keyword">if</span>(st&lt;=x[id2[k]] &amp;&amp; x[id2[k]]&lt;=ed) sum++;</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;=c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(st&lt;=x[id2[j]] &amp;&amp; x[id2[j]]&lt;=ed) sum--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t3.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t3.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;c&gt;&gt;n;</span><br><span class="line">	<span class="built_in">fr</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">		r=<span class="built_in">max</span>(r,<span class="built_in">max</span>(x[i],y[i]));</span><br><span class="line">		id1[i]=id2[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(id1+<span class="number">1</span>,id1+n+<span class="number">1</span>,cmp1);</span><br><span class="line">	<span class="built_in">sort</span>(id2+<span class="number">1</span>,id2+n+<span class="number">1</span>,cmp2);</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>分治 | [USACO06JAN]把牛Corral the Cows</title>
    <url>/2019/03/11/2019-03-11-%E6%8A%8A%E7%89%9B/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Desciption"><a href="#Desciption" class="headerlink" title="Desciption"></a>Desciption</h2><p>Farmer John wishes to build a corral for his cows. Being finicky beasts, they demand that the corral be square and that the corral contain at least C (1 &lt;= C &lt;= 500) clover fields for afternoon treats. The corral’s edges must be parallel to the X,Y axes.</p>
<p>FJ’s land contains a total of N (C &lt;= N &lt;= 500) clover fields, each a block of size 1 x 1 and located at with its lower left corner at integer X and Y coordinates each in the range 1..10,000. Sometimes more than one clover field grows at the same location; such a field would have its location appear twice (or more) in the input. A corral surrounds a clover field if the field is entirely located inside the corral’s borders.</p>
<p>Help FJ by telling him the side length of the smallest square containing C clover fields.</p>
<p>约翰打算建一个围栏来圈养他的奶牛.作为最挑剔的兽类，奶牛们要求这个围栏必须是正方 形的，而且围栏里至少要有C&lt; 500)个草场，来供应她们的午餐.</p>
<p>约翰的土地上共有C&lt;=N&lt;=500)个草场，每个草场在一块1x1的方格内，而且这个方格的 坐标不会超过10000.有时候，会有多个草场在同一个方格内，那他们的坐标就会相同.</p>
<p>告诉约翰，最小的围栏的边长是多少？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Line 1: Two space-separated integers: C and N</p>
<p>Lines 2..N+1: Each line contains two space-separated integers that are the X,Y coordinates of a clover field.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Line 1: A single line with a single integer that is length of one edge of the minimum size square that contains at least C clover fields.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">4 1</span><br><span class="line">5 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>Explanation of the sample:</p>
<p>|<em> </em></p>
<p>| <em> </em></p>
<p>+———Below is one 4x4 solution (C’s show most of the corral’s area); many others exist.</p>
<p>|CCCC</p>
<p>|CCCC</p>
<p>|<em>CCC</em></p>
<p>|C<em>C</em></p>
<p>+———</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>二分搜索栅栏的边长</strong>，每次将边长带入到图中，计算出最多能覆盖到的草场的数量即可</p>
<p>要计算覆盖草场的数量，选定一块草场 $i$ ，将 $x[i]$ 设为覆盖的上边界，得出下边界，在上边界和下边界中二分查找（使用 $ lower_\;bound $）找到左右边界的草场编号范围（当然这需要提前对草场位置排序）</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr(na,st,ed) for(int na=st;na&lt;=ed;na++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="type">int</span> id1[maxn],id2[maxn];</span><br><span class="line"><span class="type">int</span> n,c; <span class="type">int</span> l=<span class="number">1</span>,r,mid;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> q,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x[q]&lt;x[w];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(<span class="type">int</span> q,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> y[q]&lt;y[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> st,ed,k,sum;</span><br><span class="line">	<span class="built_in">fr</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		k=<span class="number">1</span>; sum=<span class="number">0</span>;</span><br><span class="line">		st=x[id1[i]]; ed=st+size<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">fr</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">			<span class="keyword">while</span>(y[id2[k]]-y[id2[j]]+<span class="number">1</span>&lt;=size &amp;&amp; k&lt;=n)&#123;</span><br><span class="line">				<span class="keyword">if</span>(st&lt;=x[id2[k]] &amp;&amp; x[id2[k]]&lt;=ed) sum++;</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum&gt;=c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(st&lt;=x[id2[j]] &amp;&amp; x[id2[j]]&lt;=ed) sum--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t3.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t3.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;c&gt;&gt;n;</span><br><span class="line">	<span class="built_in">fr</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">		r=<span class="built_in">max</span>(r,<span class="built_in">max</span>(x[i],y[i]));</span><br><span class="line">		id1[i]=id2[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(id1+<span class="number">1</span>,id1+n+<span class="number">1</span>,cmp1);</span><br><span class="line">	<span class="built_in">sort</span>(id2+<span class="number">1</span>,id2+n+<span class="number">1</span>,cmp2);</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;l;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最小生成树 | 北极通讯网  络</title>
    <url>/2019/03/22/2019-03-22-%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>北极地区共有P座村庄，每座村庄均有自己的坐标。现在决定在村庄之间建立通信网络，其中通讯工具可以是无线电收发机，也可以是卫星设备。你的任务是让任意两座村庄之间都可以直接或间接地通信。<br>卫星设备一共有S台，拥有卫星设备的两座村庄之间无论相距多远都可以直接通信；其他每个村庄都可以配备一台无线收发机，但必须具有相同的参数d。只有欧基里德不是超过d的村庄才能用无线收发机直接通讯。由于d越大的无线电收发机越贵，你需要合理分配这S台卫星设备，才能让其他村庄的无线电收发机的d最小。    </p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行为整数S,P，表示卫星通信设备数目和村庄数目。接下来的P行，每行表示一个村庄的坐标(x,y)。   </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一个保留2位小数的实数，表示最小的无线电收发器半径。   </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2 4 </span><br><span class="line">0 100 </span><br><span class="line">0 300 </span><br><span class="line">0 600 </span><br><span class="line">150 750 </span><br><span class="line">```   </span><br><span class="line">## Sample Output   </span><br><span class="line">```text </span><br><span class="line">2 4 </span><br><span class="line">0 100 </span><br><span class="line">0 300 </span><br><span class="line">0 600 </span><br><span class="line">150 750 </span><br><span class="line">```   </span><br><span class="line">## 分析  </span><br><span class="line">当正向思考受阻时，逆向思维可能有奇效。本题就是这样。知道卫星设备的数量，求最小的收发距离，可能比较困难；如果知道距离求数量，就很简单了。把所有可以互相通讯的村庄连接起来，构成一个图。卫星设备的台数就是图的连通支的个数。   </span><br><span class="line">问题转化为：找到一个最小的d，使得把所有权值大于d的边去掉之后，连通支的个数小于等于k。</span><br><span class="line"></span><br><span class="line">定理：如果去掉所有权值大于d的边后，最小生成树被分割成为k个连通支，图也被分割成为k个连通支。   </span><br><span class="line">&#123;:.success&#125;</span><br><span class="line"></span><br><span class="line">证明：用反证法。假设原图被分割成k’ (k&#x27;≠k)个连通支，显然不可能k’&gt;k，所以k’&lt;k。因此在某一图的连通支中，最小生成树被分成了至少两部分，不妨设其为T1,T2。因为T1和T2同属于一个连通支，所以一定存在x∈T1，y∈T2，w(x,y)≤d。又因为在整个最小生成树中，所以x到y的路径中一定存在一条权值大于d的边(u,v)（否则x和y就不会分属于T1和T2了），w(x,y)≤d&lt;w(u,v)，所以把(x,y)加入，把(u,v)去掉，将得到一棵总权值比最小生成树还小的生成树。这显然是不可能的。所以，原命题成立。（证毕）   </span><br><span class="line">有了这个定理，很容易得到一个构造算法：最小生成树的第k长边就是问题的解。   </span><br><span class="line">***——From 信息学奥赛一本通提高版***   </span><br><span class="line">## Codes   </span><br><span class="line">```cpp </span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#define maxn 1001</span><br><span class="line">#define pf(x) (x*x)</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	double val;</span><br><span class="line">	bool operator &lt;(const node &amp;obj)const&#123;</span><br><span class="line">		return val&lt;obj.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxn*maxn];</span><br><span class="line">int tot,f[maxn];</span><br><span class="line">double res[maxn];</span><br><span class="line">pair&lt;ll,ll&gt; d[maxn]; int s,p;</span><br><span class="line">inline double getdis(ll x1,ll x2,ll y1,ll y2)&#123;</span><br><span class="line">	return sqrt(pf(abs(x1-x2))+pf(abs(y1-y2)));</span><br><span class="line">&#125;</span><br><span class="line">int Sfind(int x)&#123;</span><br><span class="line">	if(f[x]==x) return x;</span><br><span class="line">	else return f[x]=Sfind(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">inline void Sunion(int u1,int u2)&#123;</span><br><span class="line">	int fa=Sfind(u1);</span><br><span class="line">	int fb=Sfind(u2);</span><br><span class="line">	f[fa]=fb;</span><br><span class="line">&#125;</span><br><span class="line">inline void makeEdge()&#123;</span><br><span class="line">	for(int i=1;i&lt;=p;i++)</span><br><span class="line">		for(int j=i+1;j&lt;=p;j++)</span><br><span class="line">			g[++tot]=(node)&#123;i,j,</span><br><span class="line">				getdis(d[i].first,d[j].first,d[i].second,d[j].second)</span><br><span class="line">			&#125;;</span><br><span class="line">&#125;</span><br><span class="line">double kruskal()&#123;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	sort(g+1,g+tot+1);</span><br><span class="line">	for(int i=1;i&lt;=tot;i++)&#123;</span><br><span class="line">		if(Sfind(g[i].a)!=Sfind(g[i].b))</span><br><span class="line">			res[++cnt]=g[i].val,</span><br><span class="line">			Sunion(g[i].a,g[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	return res[cnt-s+1];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	#ifndef ONLINE_JUDGE</span><br><span class="line">	freopen(&quot;testin.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	freopen(&quot;testout.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">	#endif</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;p;</span><br><span class="line">	if(s&gt;=p)&#123;</span><br><span class="line">		cout&lt;&lt;&quot;0.00&quot;;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=p;i++)</span><br><span class="line">		cin&gt;&gt;d[i].first&gt;&gt;d[i].second;</span><br><span class="line">	makeEdge(); for(int i=0;i&lt;=p;i++) f[i]=i;</span><br><span class="line">	printf(&quot;%.2lf&quot;,kruskal());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash | 查询</title>
    <url>/2019/03/12/2019-03-12-Hash_%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p> 给定一个长度为n的整数数组A[1]、A[2]、…、A<a href="-10^9&lt;=A[i]&lt;=10^9">N</a>，和m个操作：</p>
<p><strong>操作1：</strong>1  i  x 把A[i]的值增加 x （-10^3&lt;=x&lt;=10^3）; </p>
<p><strong>操作2：</strong>2 x  查询整数 x 在A[1]..A[N]中出现的次数  </p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含两个整数n和m，表示数组有n个元素，m表示有m个查询操作；　　接下来的一行包含n个整数，第i个整数表示A[i]；　　再接下来的m行，每行表示一个操作.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>按输入顺序输出操作2的结果。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 9</span><br><span class="line">3 5 8 17 14 21 7 6 31 5</span><br><span class="line">2 9</span><br><span class="line">1 2 -1</span><br><span class="line">1 1 1</span><br><span class="line">2 4</span><br><span class="line">1 5 2</span><br><span class="line">2 5</span><br><span class="line">1 8 -1</span><br><span class="line">1 2 1</span><br><span class="line">2 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用 $Hash$ 来压缩标记数组的空间大小，选取 $Hash$ 的取余数为：$1226959$（网上搜的）<br>{:.success}</p>
<p>对于每个数 $x$，$x\mod 1226959$ 的值不容易出现重复，因此标记数组开到 $1226959$ 就行了</p>
<p>如果出现重复元素，用 $Vetcor$ 挂邻接表来循环查找即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> haha 1226959</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gethash(x) (abs(x%haha))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; h[haha];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[haha];</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tar=<span class="built_in">gethash</span>(x);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iterh=h[tar].<span class="built_in">begin</span>(); </span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iterg=g[tar].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span>(iterh!=h[tar].<span class="built_in">end</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(*iterh==x)</span><br><span class="line">			<span class="keyword">return</span> *iterg;</span><br><span class="line">		iterh++; iterg++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addhash</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tar=<span class="built_in">gethash</span>(x);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iterh=h[tar].<span class="built_in">begin</span>(); </span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iterg=g[tar].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="type">bool</span> exis=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span>(iterh!=h[tar].<span class="built_in">end</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(*iterh==x)&#123;</span><br><span class="line">			exis=<span class="literal">true</span>;</span><br><span class="line">			(*iterg)++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iterh++; iterg++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!exis)&#123;</span><br><span class="line">		h[tar].<span class="built_in">push_back</span>(x);</span><br><span class="line">		g[tar].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">edithash</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tar=<span class="built_in">gethash</span>(p);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iterh=h[tar].<span class="built_in">begin</span>(); </span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iterg=g[tar].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span>(iterh!=h[tar].<span class="built_in">end</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(*iterh==p)&#123;</span><br><span class="line">			(*iterg)+=v;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iterh++; iterg++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> t,d,o;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i]; <span class="built_in">addhash</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;o;</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="number">1</span>)&#123;</span><br><span class="line">			cin&gt;&gt;t&gt;&gt;d; <span class="built_in">edithash</span>(a[t],<span class="number">-1</span>);</span><br><span class="line">			a[t]+=d; <span class="built_in">addhash</span>(a[t]);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cin&gt;&gt;t;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">res</span>(t)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机（简单版）</title>
    <url>/2019/03/18/2019-03-18-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%90%E7%AE%80%E5%8D%95%E7%89%88%E3%80%91/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行一个n，表示模式串个数；</p>
<p>下面n行每行一个模式串；</p>
<p>下面一行一个文本串。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一个数表示答案</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aa</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">Data Range</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SubTask1(50)</td>
<td style="text-align:center">$\sum len(模式串，文本串)\leq10^6\;n=1$</td>
</tr>
<tr>
<td style="text-align:center">SubTask2(50)</td>
<td style="text-align:center">$\sum len(模式串，文本串)\leq10^6$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看题目名字就知道这是一道<strong>AC自动机裸题</strong></p>
<p>回顾一下AC自动机的算法流程：</p>
<ol>
<li>所有模式串建立Trie树：$Tinsert$</li>
<li>建立 lose 数组（fail指针）：$Tinit$</li>
<li>匹配：$Tmatch$</li>
</ol>
<p><strong>在匹配过程中，由于要防止后缀重复出现的问题，每走过一个节点，将他的 $isend$ 值设置为 $false$ ，为了防止前缀相同而漏掉，需要每次 $k=lose[k]$ 继续匹配</strong><br>{:.info}</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxc 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> to[maxc];</span><br><span class="line">	<span class="type">int</span> isend;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line"><span class="type">int</span> lose[maxn]; <span class="type">int</span> tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Tinsert</span><span class="params">(<span class="type">char</span> *t)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lent=<span class="built_in">strlen</span>(t); <span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lent;i++)&#123;</span><br><span class="line">		c=t[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!g[u].to[c])</span><br><span class="line">			g[u].to[c]=++tot;</span><br><span class="line">		u=g[u].to[c];</span><br><span class="line">	&#125;</span><br><span class="line">	g[u].isend++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Tinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) g[<span class="number">0</span>].to[i]=<span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>); lose[<span class="number">1</span>]=<span class="number">0</span>; <span class="type">int</span> head;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> head2 lose[head]</span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		head=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!g[head].to[i])</span><br><span class="line">				g[head].to[i]=g[lose[head]].to[i];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(g[head].to[i]);</span><br><span class="line">				lose[g[head].to[i]]=g[head2].to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> head2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Tmatch</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lens=<span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="type">int</span> u=<span class="number">1</span>; <span class="type">int</span> c,k; <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">		c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		u=g[u].to[c];</span><br><span class="line">		<span class="keyword">for</span>(k=u;k!=<span class="number">0</span> &amp;&amp; g[k].isend!=<span class="number">-1</span>;k=lose[k])&#123;</span><br><span class="line">			ans+=g[k].isend;</span><br><span class="line">			g[k].isend=<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> A[maxn],R[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,A),<span class="built_in">Tinsert</span>(A);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,R);</span><br><span class="line">	<span class="built_in">Tinit</span>();</span><br><span class="line">	cout&lt;&lt;<span class="built_in">Tmatch</span>(R);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最小生成树 | [HAOI2006]舒适的  路线</title>
    <url>/2019/03/24/2019-03-24-%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Descripiton"><a href="#Descripiton" class="headerlink" title="Descripiton"></a>Descripiton</h2><p>Z小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。</p>
<p>Z小镇附近共有N(1&lt;N≤500)个景点（编号为1,2,3,…,N），这些景点被M（0&lt;M≤5000）条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。也许是为了保护该地的旅游资源，Z小镇有个奇怪的规定，就是对于一条给定的公路Ri，任何在该公路上行驶的车辆速度必须为Vi。</p>
<p>频繁的改变速度使得游客们很不舒服，因此大家从一个景点前往另一个景点的时候，都希望选择行使过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含两个正整数，N和M。</p>
<p>接下来的M行每行包含三个正整数：x，y和v（1≤x,y≤N，0 最后一行包含两个正整数s，t，表示想知道从景点s到景点t最大最小速度比最小的路径。s和t不可能相同。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>第一行包含两个正整数，N和M。</p>
<p>接下来的M行每行包含三个正整数：x，y和v（1≤x,y≤N，0 最后一行包含两个正整数s，t，表示想知道从景点s到景点t最大最小速度比最小的路径。s和t不可能相同。</p>
<h2 id="Samples"><a href="#Samples" class="headerlink" title="Samples"></a>Samples</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th style="text-align:center">Input</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">$4\;2\\1\;2\;1\\3\;4\;2\\1\;4$</td>
<td style="text-align:center">$IMPOSSIBLE$</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">$3\;3\\1\;2\;10\\1\;2\;5\\2\;3\;8\\1\;3$</td>
<td style="text-align:center">$5/4$</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">$3\;2\\1\;2\;2\\2\;3\;4\\1\;3$</td>
<td style="text-align:center">$2$</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Sample 2图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--10---2</span><br><span class="line">1--5---2</span><br><span class="line">2--8---3</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>N(1&lt;N≤500)</p>
<p>M（0&lt;M≤5000）</p>
<p>Vi在int范围内</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最小生成树+枚举：<br>{:.success}</p>
<p>把边权升序排序，然后选取任意一条边作为起点，考虑比它大的边加入集合，直到 $s$ 和 $t$ 联通。此时的比值为</p>
<script type="math/tex; mode=display">
\frac{maxV}{minV}=\frac{g[j].val}{g[i].val}</script><p>然后将这些比值求一个最小值就可以了，几点优化：</p>
<ol>
<li><strong>判断图是否联通，在 $i=1​$ 时判断</strong></li>
<li><strong>如果将比 $i$ 大的边全部加入集合仍然不能使得 $s$ 和 $t$ 联通，则退出循环（再做无意义）</strong></li>
<li><strong>当 $s$ 和  $t$  联通后，当前循环也可以退出</strong></li>
</ol>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 501</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 5001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="type">double</span> val;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&lt;obj.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxm]; <span class="type">int</span> f[maxn]; <span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sunion(u1,u2) (f[Sfind(u1)]=Sfind(u2))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rint i=<span class="number">0</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(rint i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Sfind</span>(g[i].u)!=<span class="built_in">Sfind</span>(g[i].v))</span><br><span class="line">			<span class="built_in">Sunion</span>(g[i].u,g[i].v);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Sfind</span>(x)==<span class="built_in">Sfind</span>(y); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Advanced_kruskal</span><span class="params">(<span class="type">int</span> u1,<span class="type">int</span> u2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+m+<span class="number">1</span>);</span><br><span class="line">	<span class="type">double</span> minE=<span class="number">9999999.0</span>,maxE=<span class="number">0.0</span>;</span><br><span class="line">	<span class="type">double</span> ratio=minE;</span><br><span class="line">	<span class="type">double</span> tarMin,tarMax; <span class="type">bool</span> sign;</span><br><span class="line">	<span class="keyword">for</span>(rint i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		minE=g[i].val;</span><br><span class="line">		sign=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(rint k=<span class="number">0</span>;k&lt;=n;k++) f[k]=k;</span><br><span class="line">		<span class="keyword">for</span>(rint j=i;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Sfind</span>(g[j].u)!=<span class="built_in">Sfind</span>(g[j].v))</span><br><span class="line">				<span class="built_in">Sunion</span>(g[j].u,g[j].v);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Sfind</span>(u1)==<span class="built_in">Sfind</span>(u2))&#123;</span><br><span class="line">				sign=<span class="literal">true</span>;</span><br><span class="line">				maxE=g[j].val;</span><br><span class="line">				<span class="keyword">if</span>(maxE/minE&lt;ratio)&#123;</span><br><span class="line">					tarMin=minE; tarMax=maxE;</span><br><span class="line">					ratio=maxE/minE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ratio==<span class="number">1.0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(!sign) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> tarminE=tarMin;</span><br><span class="line">	<span class="type">int</span> tarmaxE=tarMax;</span><br><span class="line">	<span class="keyword">if</span>(tarmaxE%tarminE==<span class="number">0</span>) cout&lt;&lt;tarmaxE/tarminE;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> Egcd=<span class="built_in">gcd</span>(tarminE,tarmaxE);</span><br><span class="line">		tarminE/=Egcd;tarmaxE/=Egcd;</span><br><span class="line">		cout&lt;&lt;tarmaxE&lt;&lt;<span class="string">&#x27;/&#x27;</span>&lt;&lt;tarminE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeEdge</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(rint i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;g[i].u&gt;&gt;g[i].v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;g[i].val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;way.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;way.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">makeEdge</span>(); <span class="type">int</span> x,y;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">judge</span>(x,y)) cout&lt;&lt;<span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Advanced_kruskal</span>(x,y);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最小生成树 | 最小生成树  计数</title>
    <url>/2019/03/24/2019-03-24-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两颗最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对31011的模就可以了。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行包含两个数，n和m，其中1&lt;=n&lt;=100; 1&lt;=m&lt;=1000; 表示该无向图的节点数和边数。每个节点用1~n的整数编号。　　</p>
<p>接下来的m行，每行包含两个整数：a, b, c，表示节点a, b之间的边的权值为c，其中1&lt;=c&lt;=1,000,000,000。数据保证不会出现自回边和重边。　　</p>
<p>注意：具有相同权值的边不会超过10条。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出不同的最小生成树有多少个。你只需要输出数量对31011的模就可以了。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">1 4 1</span><br><span class="line">2 3 2</span><br><span class="line">2 4 1</span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Sample Input 图示：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--1---2</span><br><span class="line">1--1---3</span><br><span class="line">1--1---4</span><br><span class="line">2--2---3</span><br><span class="line">2--1---4</span><br><span class="line">3--1---4</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对边集按边权排序过后，我们可以使用 $kruskal$ 算法求解最小生成树，因为 $kruksal$ 算法是按照边的权值生成树的，所以：</p>
<p>在边权和相同的最小生成树中，某权值的边的数量是一定的<br>{:.info}</p>
<p>我们可以用 $dfs$ 去搜索满足最小生成树的边的集合的情况，利用乘法原理得到方案数</p>
<p>代码中：</p>
<ol>
<li>d数组用于存放相同边的信息（起始位置，终止位置，构成的生成树数量），d数组是在g数组（边集数组排序之后，在 $kruskal$ 算法过程中求得，所以不会出现漏记或重复</li>
<li>每次dfs求解答案之后，把当前范围内的边（从 $d[i].st$ 位置到 $d[i].ed$ 位置的边）都连接防止下一次dfs出错</li>
<li>不能对并查集数组 $f$ 使用路径压缩，例如 $return\;f[x]=Sfind(f[x])$</li>
</ol>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _mod 31011</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,val;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&lt;obj.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxm]; <span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuperNode</span>&#123;</span><br><span class="line">	<span class="type">int</span> st,ed,tree;</span><br><span class="line">&#125;d[maxm]; <span class="type">int</span> f[maxn],stats;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">    <span class="comment">// else return f[x]=Sfind(f[x])</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sunion(u1,u2) (f[Sfind(u1)]=Sfind(u2))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pos==d[id].ed+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k==d[id].tree) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> fu=<span class="built_in">Sfind</span>(g[pos].u);</span><br><span class="line">	<span class="type">int</span> fv=<span class="built_in">Sfind</span>(g[pos].v);</span><br><span class="line">	<span class="keyword">if</span>(fu!=fv)&#123;</span><br><span class="line">		f[fu]=fv;</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(id,pos+<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">		f[fu]=fu; f[fv]=fv;</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=<span class="built_in">dfs</span>(id,pos+<span class="number">1</span>,k);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> SumTree=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(g[i].val!=g[i<span class="number">-1</span>].val)&#123;</span><br><span class="line">			stats++; d[stats].st=i;</span><br><span class="line">			d[stats<span class="number">-1</span>].ed=i<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Sfind</span>(g[i].u)!=<span class="built_in">Sfind</span>(g[i].v))&#123;</span><br><span class="line">			SumTree++; <span class="built_in">Sunion</span>(g[i].u,g[i].v);</span><br><span class="line">			d[stats].tree++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	d[stats].ed=m;</span><br><span class="line">	<span class="keyword">if</span>(SumTree!=(n<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">res</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=i;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>,tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=stats;i++)&#123;</span><br><span class="line">		tmp=<span class="built_in">dfs</span>(i,d[i].st,<span class="number">0</span>);</span><br><span class="line">		ans=(ans*tmp)%_mod;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=d[i].st;j&lt;=d[i].ed;j++)</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Sfind</span>(g[j].u)!=<span class="built_in">Sfind</span>(g[j].v))</span><br><span class="line">				<span class="built_in">Sunion</span>(g[j].u,g[j].v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;cnt.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;cnt.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].val;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">kruskal</span>()) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="built_in">res</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>数论 | 同余 | 一中OJ_P1133【培训题  】Hankson的趣味题</title>
    <url>/2019/03/28/2019-03-28-MathJax%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="http://newoj.cqyz.cn/problem/P1133"><font color=orange size=5><strong>跳转到在线页面</strong></font></a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title=" Description"></a><font color=#3199DF > <strong>Description</strong></font></h2><p>Hanks博士是BT（Bio-Tech，生物技术）领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。</p>
<p>　　今天在课堂上，老师讲解了如何求两个正整数c1和c2的最大公约数和最小公倍数。现在 Hankson认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 a0,a1,b0,b1，设某未知正整数x满足：</p>
<p>　　1、x和a0的最大公约数是a1；</p>
<p>　　2、x和b0的最小公倍数是b1。</p>
<p>　　Hankson的“逆问题”就是求出满足条件的正整数x。但稍加思索之后，他发现这样的x并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的x的个数。请你帮助他编程求解这个问题。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title=" Input"></a><font color=#3199DF > <strong>Input</strong></font></h2><p>第一行为一个正整数n，表示有n组输入数据。接下来的n行每行一组输入数据，为四个正整数a0，a1，b0，b1，每两个整数之间用一个空格隔开。输入数据保证a0能被a1整除，b1能被b0整除。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title=" Output"></a><font color=#3199DF > <strong>Output</strong></font></h2><p>共n行。每组输入数据的输出结果占一行，为一个整数。　　对于每组数据：若不存在这样的x，请输出0；　　若存在这样的x，请输出满足条件的x的个数；</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title=" Sample Input"></a><font color=#3199DF > <strong>Sample Input</strong></font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">41 1 96 288</span><br><span class="line">95 1 37 1776</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title=" Sample Output"></a><font color=#3199DF > <strong>Sample Output</strong></font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title=" Hint"></a><font color=#3199DF > <strong>Hint</strong></font></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于50%的数据，保证有1≤a0，b1，b0，b1≤10000且n≤100。对于100%的数据，保证有1≤a0，b1，b0，b1≤2,000,000,000且n≤2000。</span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title=" 分析"></a><font color=purple > <strong>分析</strong></font></h1><blockquote>
<p><strong>两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积</strong></p>
</blockquote>
<p>——百度热心网友</p>
<p>首先由：</p>
<script type="math/tex; mode=display">\begin{cases}
lcm(x，b_0)=b_1 \\\\
gcd(x，a_0)=a_1
\end{cases}
\Rightarrow
\begin{cases}
x=k_1a_1 \\\\
b_1=k_2x
\end{cases}
(k_1，k_2\in Z)</script><p>可知<strong>x是b1的一个因子且为a1倍数</strong>，因而<strong>从1到sqrt(b1)枚举每个整除b1的数字</strong>，若其是a1的整数倍，且满足上述二式则ans+1<br>暴力枚举在一中OJ上可以得90分…</p>
<p>100分解法还要推出更深的结论：</p>
<script type="math/tex; mode=display">gcd(x，a_0)=a_1 \\\\ \Rightarrow\begin{cases}x=k_1a_1 \\\\ a_0=k_2a_1
\end{cases}(k_1，k_2\in Z)\\\\ \Rightarrow gcd(k_1,k_2)=1</script><p>则：</p>
<script type="math/tex; mode=display">gcd(a，b)=k \\\\ \Rightarrow gcd(\frac{a}{k}，\frac{b}{k})=1</script><p>进一步的我们有：</p>
<script type="math/tex; mode=display">lcm(x,b_0)=b_1 \\\\ \Rightarrow
gcd(x，b_0)=\frac{x\times b_0}{lcm(x，b0)}=\frac{x\times b_0}{b_1} \\\\ \Rightarrow
gcd\left(\frac{xb_1}{xb_0}，\frac{b_0b_1}{xb_0}\right)=gcd\left(\frac{b_1}{b_0}，\frac{b_1}{x}\right)=1</script><p>设置几个辅助变量：</p>
<script type="math/tex; mode=display">m=\frac{a_0}{a_1}，n=\frac{b_1}{b_0}，p=\frac{b_1}{x}，s=\frac{b_1}{a_1} \\\\ \Rightarrow
\begin{cases} gcd(p，m)=1\\gcd\left( \frac{s}{p}，n \right)=1 \end{cases}</script><p><strong>考虑gcd(s/p,n)=1</strong>要满足s/p与n没有公共质因数，因此我们需要将s/p与n的公共质因数筛去，得到满足条件的数T，T是s/p的某个因数</p>
<p>又因为gcd(p,m)=1，<strong>而s/p=Tr(r为整数)</strong>，那么p=s/(T*r)，则gcd(s/(T*r),n)=1，利用刚才方法将两者的公共质因数筛去得到S，那么S的因数个数就是答案</p>
<h1 id="Codes"><a href="#Codes" class="headerlink" title=" Codes"></a><font color=green > <strong>Codes</strong></font></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hankson 趣味题 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL a0,a1,b0,b1,ans;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lcm</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*b/<span class="built_in">gcd</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">seprate</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL S=<span class="built_in">sqrt</span>(b);</span><br><span class="line">	<span class="keyword">for</span>(LL i=<span class="number">2</span>;i&lt;=S;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b%i==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">while</span>(a%i==<span class="number">0</span>) a/=i;</span><br><span class="line">		<span class="keyword">while</span>(b%i==<span class="number">0</span>) b/=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(b!=<span class="number">1</span>) <span class="keyword">while</span>(a%b==<span class="number">0</span>) a/=b;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin&gt;&gt;T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin&gt;&gt;a0&gt;&gt;a1&gt;&gt;b0&gt;&gt;b1;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		LL m=a0/a1,n=b1/b0,s=b1/a1;</span><br><span class="line">		LL tmp1=<span class="built_in">seprate</span>(s,n);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">gcd</span>(s/tmp1,m)!=<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			LL tmp2=<span class="built_in">seprate</span>(tmp1,m);</span><br><span class="line">			LL S=<span class="built_in">sqrt</span>(tmp2);</span><br><span class="line">			<span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=S;i++)</span><br><span class="line">				<span class="keyword">if</span>(tmp2%i==<span class="number">0</span>)</span><br><span class="line">					ans+=(tmp2/i==i)?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">			cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 二分 | 最小生成树 | [国家  集训队2]Tree I</title>
    <url>/2019/03/25/2019-03-25-NationalTeamI_Tree/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。题目保证有解。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行V,E,need分别表示点数，边数和需要的白色边数。接下来E行每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一行表示所求生成树的边权和。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2 2 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 1 2 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>图示：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">0--&quot;1(black)&quot;---1</span><br><span class="line">0--&quot;2(white)&quot;---1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题要用到二分法，对 $Kruskal$ 算法进行变形，首先我们在对边集排序时，要让值相等的情况下白色边在前（为了选边做准备），然后为了影响 $Kruskal$ 的选边过程，对所有的白色边加上一个权值，这个权值可正可负，这是因为将编边集数组排序时：</p>
<ol>
<li><strong>附加权为正时，表示当前的白色边过多，我们让权值较大的白色边再大一点，就可以被$Kruskal$ 算法排除在最小生成树外面，达到少选的目的</strong></li>
<li><strong>附加权为负时，表示当前的白色边过少，让所有白色边权值变小、前移就可以多选白色边</strong></li>
</ol>
<p>发现这样做实际上只影响了白色边和黑色边的顺序，没有影响白色边之间的相对顺序，因此 $Kruskal$ 选出来的边就还会是满足需要的条件下的最小生成树</p>
<p>要二分的就是附加权的权值，二分直到最小生成树中刚好有 $need$ 条白色边，每次让 $Kruskal$ 返回一个值 $cnt​$ ，表示选了多少条白色边，然后：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$cnt\geq need$</th>
<th style="text-align:center">$cnt&lt;need$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">说明白色边较多，需要调小权值</td>
<td style="text-align:center">说明白色变较少，需要调大权值</td>
</tr>
</tbody>
</table>
</div>
<p>二分完，此时的目标权值和为 $Sum-need\times add$，$add$ 是二分的权值，每次二分完后记得恢复原来的边权</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxV 50001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxE 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,val;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(val==obj.val) <span class="keyword">return</span> c&lt;obj.c;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> val&lt;obj.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxE]; <span class="type">int</span> f[maxV],V,E,need;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sunion(u1,u2) (f[Sfind(u1)]=Sfind(u2))</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+E+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=V;i++) f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=E;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Sfind</span>(g[i].u)!=<span class="built_in">Sfind</span>(g[i].v))&#123;</span><br><span class="line">			<span class="built_in">Sunion</span>(g[i].u,g[i].v);</span><br><span class="line">			ans+=g[i].val;</span><br><span class="line">			<span class="keyword">if</span>(g[i].c==<span class="number">0</span>) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_pair</span>(cnt,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;V&gt;&gt;E&gt;&gt;need; <span class="type">int</span> l,r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=E;i++)&#123;</span><br><span class="line">		cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].val&gt;&gt;g[i].c;</span><br><span class="line">		g[i].u++; g[i].v++;</span><br><span class="line">		r=<span class="built_in">max</span>(r,g[i].val);</span><br><span class="line">	&#125;</span><br><span class="line">	l=r*<span class="number">-1</span>; <span class="type">int</span> mid; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=E;i++)</span><br><span class="line">			<span class="keyword">if</span>(g[i].c==<span class="number">0</span>) g[i].val+=mid;</span><br><span class="line">		res=<span class="built_in">kruskal</span>();</span><br><span class="line">		<span class="keyword">if</span>(res.first&gt;=need)</span><br><span class="line">			ret=res.second-need*mid,</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=E;i++)</span><br><span class="line">			<span class="keyword">if</span>(g[i].c==<span class="number">0</span>) g[i].val-=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ret;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最小生成树 | 次小生成树  \ | 秘密的牛奶运输</title>
    <url>/2019/03/26/2019-03-26-%E7%A7%98%E5%AF%86%E7%9A%84%E7%89%9B%E5%A5%B6%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>约翰叔叔希望能够廉价连接他的供水系统，但是他不希望他的竞争对手知道他选择的路线。一般这样的问题需要选择最便宜的方式，所以他决定避免这种情况而采用第二便宜的方式。 现在有W(3 &lt;= W &lt;= 2000)个供水站，其中最多有P(P &lt;=20,000)&lt; span=”“&gt;条管道，每一条管道连接了两个水站，并且不存在一条管道连接同一个水站，两个水站之间最多只有一条管道。每条管道有一定的费用。请寻找第二便宜的连接方式，使所有的水站相连。 假设最便宜的方案有且只有一种，并且至少有两种可行的连接方案。所有的费用都不超过16位有符号整数。水站用1到W的自然数表示</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行：两个数W和P 第2～P+1行：每行描述了一条管道，有3个用空格分开的整数，前两个数表示管道连接的两个端点。第3个数是管道的费用</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>仅一行，第二便宜的管道铺设费用</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 7 </span><br><span class="line">1 2 3 </span><br><span class="line">2 3 4 </span><br><span class="line">1 4 7 </span><br><span class="line">2 4 11 </span><br><span class="line">2 5 9 </span><br><span class="line">5 4 5 </span><br><span class="line">3 5 8</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>输入数据图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--3---2</span><br><span class="line">2--4---3</span><br><span class="line">1--7---4</span><br><span class="line">2--11---4</span><br><span class="line">2--9---5</span><br><span class="line">5--5---4</span><br><span class="line">3--8---5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道次小生成树的题目，在知道 $Kruskal$ 算法求解最小生成树之后，容易想到一种暴力解法：</p>
<p><strong>利用 $Kruskal$ 求出最小生成树之后，在原图中依次删除树边，再次构建最小生成树，取新的生成树的最小和权就是次小生成树</strong><br>{:.info}</p>
<p>这种方法不但可以求次小生成树，也可以求严格次小生成树，但是明显会超时（在<a href="https://www.luogu.org/problemnew/show/P4180">P4180 【模板】严格次小生成树(BJWC2010)</a>中只能得到50分）</p>
<p><strong>从书上摘取的优化算法：</strong></p>
<p>预处理出 $Max[i][j]​$ 表示当前求出的最小生成树中，点 $i​$ 和点 $j​$ 的唯一路径上的最长边的权值，求解时间：$O(n^2)​$，然后，上述算法的换边操作改写为：对于不在树中的边，考虑加入这条边 $(u,v)​$，替换权值为 $Max(u,v)​$ 的树边，此时的权值和为：$Ans=Ans+G[u][v]-Max[u][v]​$<br>{:.success}<br>在所有的$Ans$ 中取最小值，就是次小生成树的权值，时间复杂度：$O(n^2+m)$<br>{:.success}</p>
<p><strong>下面说 $Max​$ 数组的求法：</strong></p>
<p>按照边的权值对边集数组排序后，每次加入的边权递增，所以有 $Max[u][v]=G[E[i].u][E[i].v]​$</p>
<p>但是我们不仅要更新 $Max[u][v]​$ 的值，由于 $Kruskal​$ 求解最小生成树是一个逐渐联通的过程，定义变长数组$V[i]​$ 表示与 $i​$ 联通的点，初始时 $V[i].push_\ back(i),i\in [1,n]​$，表示最开始的时候，每个点是独立联通的</p>
<p>每次加入一条边，将 $E[i]$ 的 $u$ 端点的联通点集加入到 $v$ 的联通点集中去，更新 $Max$ 时，对于任意的 $p_1\;p_2,\;p_1\;\in V[u]，\;p_2\in V[v]$ 都有 $Max[p_1][p_2]=Max[p_2][p_1]=E[i].value$</p>
<p>这个不难理解，因为$p_1\;p_2​$ 已经联通，那么他们的唯一路径上的最大边权就是他们的联通点集的新加入的边权，为什么这个新加入的边是最长的呢？因为我们是按照边权递增来排序的</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 20001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> maax[maxn][maxn];</span><br><span class="line"><span class="type">int</span> f[maxn],n,m; <span class="type">bool</span> mst[maxm];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,val;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&lt;obj.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;g[maxm];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sunion(u1,u2) (f[Sfind(u1)]=Sfind(u2))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> u g[i].u</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> v g[i].v</span></span><br><span class="line">	<span class="built_in">sort</span>(g+<span class="number">1</span>,g+m+<span class="number">1</span>); <span class="type">int</span> sumT=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		f[i]=i,</span><br><span class="line">		E[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="type">int</span> FU,FV;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		FU=<span class="built_in">Sfind</span>(u);FV=<span class="built_in">Sfind</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(FU!=FV)&#123;</span><br><span class="line">			mst[i]=<span class="literal">true</span>; k++;</span><br><span class="line">			sumT+=g[i].val; f[FU]=FV;</span><br><span class="line">			<span class="type">int</span> lenu=E[FU].<span class="built_in">size</span>(),lenv=E[FV].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;lenu;r++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;lenv;h++)</span><br><span class="line">					maax[E[FU][r]][E[FV][h]]=maax[E[FV][h]][E[FU][r]]=g[i].val;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;lenu;r++)</span><br><span class="line">				E[FV].<span class="built_in">push_back</span>(E[FU][r]);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="type">int</span> tar=<span class="number">99999999</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(!mst[i])</span><br><span class="line">			tar=<span class="built_in">min</span>(tar,sumT+g[i].val-maax[u][v]);</span><br><span class="line">	<span class="keyword">return</span> tar;</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> u</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].val;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">kruskal</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 割点 | tarjan |　[HAOI2006]受欢迎的  牛</title>
    <url>/2019/03/29/2019-03-29-%5BHAOI2006%5D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>每一头牛的愿望就是变成一头最受欢迎的牛。现在有N头牛，给你M对整数(A,B)，表示牛A认为牛B受欢迎。这种关系是具有传递性的，如果A认为B受欢迎，B认为C受欢迎，那么牛A也认为牛C受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行两个数N,M。</p>
<p>接下来M行，每行两个数A,B，意思是A认为B是受欢迎的（给出的信息有可能重复，即有可能出现多个A,B） </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一个数，即有多少头牛被所有的牛认为是受欢迎的。 </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>　<strong>输入样例图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--&gt;2</span><br><span class="line">2--&gt;1</span><br><span class="line">2--&gt;3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用 $Tarjan$ 缩点方法解决这个题，因为在奶牛相互喜欢有向图网络中，每一个强连通分量里面的奶牛是最受欢迎的（上图中的 $(1,\;2)​$ 号奶牛）</p>
<p>求出所有的强连通分量后，原图将变成一个有向无环的 $DAG$ 图，也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1(&quot;1,2&quot;)</span><br><span class="line">d2(3)</span><br><span class="line">d1--&gt;d2</span><br></pre></td></tr></table></figure>
<p>发现 $3$ 号奶牛是最受欢迎的，且 $3$ 号奶牛在这个图里的入度为 $1$ ，所以统计缩点后，入度为 $1$ 的点的强连通分量中的点个数，就是答案要求的数量</p>
<p><strong>需要注意的是，如果缩点后的图存在 $\geq 2$ 个入度仅为 $1$ 的点，那么将不会有奶牛满足要求，例如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--&gt;2</span><br><span class="line">2--&gt;1</span><br><span class="line">2--&gt;3</span><br><span class="line">1--&gt;4</span><br><span class="line">4--&gt;5</span><br><span class="line">5--&gt;4</span><br><span class="line">5--&gt;6</span><br></pre></td></tr></table></figure>
<p>缩点后为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1(&quot;1,2&quot;)</span><br><span class="line">d2(3)</span><br><span class="line">d3(&quot;4,5&quot;)</span><br><span class="line">d4(6)</span><br><span class="line">d1--&gt;d2</span><br><span class="line">d3--&gt;d4</span><br><span class="line">d1--&gt;d3</span><br></pre></td></tr></table></figure>
<p>$3$ 、 $6$、$\left( 4,\;5 \right)$ 都是入度仅为 $1$ 的点，那么答案将为 $0$</p>
<p><strong>实际编程时由于前向星的关系，统计出度更方便，将原图反过来存就能达到统计出度的目的</strong></p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 50001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> neext,tto;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> nxt(x) g[x].neext</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> to(x) g[x].tto</span></span><br><span class="line">&#125;g[maxm]; <span class="type">int</span> head[maxm],tot;</span><br><span class="line"><span class="type">int</span> f[maxn],low[maxn],dfn[maxn];</span><br><span class="line"><span class="type">int</span> cp[maxn],cpt[maxn],dt,n,m;</span><br><span class="line"><span class="type">int</span> indeg[maxn];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Einsert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">nxt</span>(++tot)=head[a];</span><br><span class="line">	<span class="built_in">to</span>(tot)=b; head[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> v (to(i))</span></span><br><span class="line">	low[u]=dfn[u]=++dt;</span><br><span class="line">	stk.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=<span class="built_in">nxt</span>(i))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!cp[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">		cp[u]=++cp[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">while</span>(stk.<span class="built_in">top</span>()!=u)&#123;</span><br><span class="line">			cpt[cp[<span class="number">0</span>]]++;</span><br><span class="line">			cp[stk.<span class="built_in">top</span>()]=cp[<span class="number">0</span>];</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		stk.<span class="built_in">pop</span>();</span><br><span class="line">		cpt[cp[<span class="number">0</span>]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,indeg0s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> U,V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;U&gt;&gt;V;</span><br><span class="line">		<span class="built_in">Einsert</span>(V,U);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=<span class="built_in">nxt</span>(j))</span><br><span class="line">			<span class="keyword">if</span>(cp[i]!=cp[<span class="built_in">to</span>(j)])</span><br><span class="line">				indeg[cp[<span class="built_in">to</span>(j)]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cp[<span class="number">0</span>];i++)</span><br><span class="line">		<span class="keyword">if</span>(!indeg[i])</span><br><span class="line">			ans=cpt[i], indeg0s++;</span><br><span class="line">	<span class="keyword">if</span>(indeg0s==<span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>割点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 割点 | tarjan |　[hnoi2012]矿场搭建</title>
    <url>/2019/03/29/2019-03-29-%5Bhnoi2012%5D%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件有若干组数据，每组数据的第一行是一个正整数 N（N≤500），表示工地的隧道数，接下来的 N 行每行是用空格隔开的两个整数 S 和 T，表示挖S 与挖煤点 T 由隧道直接连接。输入数据以 0 结尾。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输入文件中有多少组数据，输出文件 output.txt 中就有多少行。每行对应一组　　输入数据的 结果。其中第 i 行以 Case i: 开始（注意大小写，Case 与 i 之间有空格，i 与:之间无空格，: 之后有空格），其后是用空格隔开的两个正整数，第一个正整数表示对于第 i 组输入数据至少需 要设置几个救援出口，第二个正整数表示对于第 i 组输入数据不同最少救援出口的设置方案总 数。输入数据保证答案小于 2^64。输出格式参照以下输入输出样例。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 3</span><br><span class="line">4 1</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">2 6</span><br><span class="line">1 5</span><br><span class="line">6 3</span><br><span class="line">1 6</span><br><span class="line">3 2</span><br><span class="line">6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br><span class="line">3 7</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>输入样例图示1：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1---3</span><br><span class="line">4---1</span><br><span class="line">3---5</span><br><span class="line">1---2</span><br><span class="line">2---6</span><br><span class="line">1---5</span><br><span class="line">6---3</span><br><span class="line">1---6</span><br><span class="line">3---2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p> <strong>输入样例图示2：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1---2</span><br><span class="line">1---3</span><br><span class="line">2---4</span><br><span class="line">2---5</span><br><span class="line">3---6</span><br><span class="line">3---7</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Case 1: 2 4</span><br><span class="line">Case 2: 4 1</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道求解点双联通图的题目，用 $Tarjan$ 算法解决</p>
<p><strong>给出的原图具体来说有三种情况：</strong></p>
<ol>
<li>是一个点双联通图，没有割点，从所有点中任意选取2个点作为出口</li>
<li>只有一个割点，那么从其余的点中选取任意一个点来建立出口</li>
<li>割点数 $\geq2$ ，此时不需要再建立出口，割点能作为出口使用</li>
</ol>
<p>需要用到组合公式</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clean(x) (memset(x,0,sizeof(x))) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> neext,tto;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> nxt(x) g[x].neext</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> to(x) g[x].tto</span></span><br><span class="line">&#125;g[maxm*<span class="number">2</span>]; <span class="type">int</span> head[maxm],tot;</span><br><span class="line"><span class="type">int</span> dfn[maxm],low[maxm];</span><br><span class="line"><span class="type">int</span> root,dt; vector&lt;<span class="type">int</span>&gt; vdcc[maxm];</span><br><span class="line"><span class="type">int</span> vdccs; <span class="type">bool</span> cp[maxm];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; S; <span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Einsert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">nxt</span>(++tot)=head[a];</span><br><span class="line">	<span class="built_in">to</span>(tot)=b; head[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> v (to(i))</span></span><br><span class="line">	low[u]=dfn[u]=++dt; <span class="type">int</span> shead;</span><br><span class="line">	S.<span class="built_in">push</span>(u); <span class="type">int</span> chi=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=<span class="built_in">nxt</span>(i))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			chi++;<span class="built_in">tarjan</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">			<span class="keyword">if</span>((u!=root &amp;&amp; dfn[u]&lt;=low[v])||(u==root &amp;&amp; chi&gt;<span class="number">1</span>))</span><br><span class="line">				cp[u]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(dfn[u]&lt;=low[v])&#123;</span><br><span class="line">				vdccs++; vdcc[vdccs].<span class="built_in">clear</span>();</span><br><span class="line">				<span class="keyword">do</span>&#123;</span><br><span class="line">					shead=S.<span class="built_in">top</span>();S.<span class="built_in">pop</span>();</span><br><span class="line">					vdcc[vdccs].<span class="built_in">push_back</span>(shead);</span><br><span class="line">				&#125;<span class="keyword">while</span>(shead!=v);</span><br><span class="line">				vdcc[vdccs].<span class="built_in">push_back</span>(u);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Res</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">clean</span>(dfn);<span class="built_in">clean</span>(low);<span class="built_in">clean</span>(cp);</span><br><span class="line">	<span class="keyword">while</span>(!S.<span class="built_in">empty</span>()) S.<span class="built_in">pop</span>();</span><br><span class="line">	dt=vdccs=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">			root=i;</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll res=<span class="number">0</span>,num=<span class="number">1</span>; <span class="type">int</span> Vlen,cnum;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=vdccs;i++)&#123;</span><br><span class="line">		Vlen=vdcc[i].<span class="built_in">size</span>();</span><br><span class="line">		cnum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;Vlen;j++)</span><br><span class="line">			<span class="keyword">if</span>(cp[vdcc[i][j]]) cnum++;</span><br><span class="line">		<span class="keyword">if</span>(cnum==<span class="number">0</span>) res+=<span class="number">2</span>, num=num*(Vlen<span class="number">-1</span>)*Vlen/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cnum==<span class="number">1</span>) res++,num=num*(Vlen<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;res&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;m; <span class="type">int</span> U,V,ss=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(m)&#123;</span><br><span class="line">		n=<span class="number">0</span>; ss++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;U&gt;&gt;V;</span><br><span class="line">			<span class="built_in">Einsert</span>(U,V);</span><br><span class="line">			<span class="built_in">Einsert</span>(V,U);</span><br><span class="line">			n=<span class="built_in">max</span>(n,<span class="built_in">max</span>(U,V));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case %d: &quot;</span>,ss); </span><br><span class="line">		<span class="built_in">Res</span>();</span><br><span class="line">		<span class="built_in">clean</span>(g);<span class="built_in">clean</span>(head);tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		cin&gt;&gt;m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>割点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 强连通分量 | Tarjan | [中山市  选]杀人游戏</title>
    <url>/2019/04/07/2019-04-07-%E6%9D%80%E4%BA%BA%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一位冷血的杀手潜入Na-wiat，并假装成平民。警察希望能在NNN个人里面，查出谁是杀手。警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。</p>
<p>问：根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行有两个整数 N,M。 接下来有 M 行，每行两个整数 x,y，表示 x 认识 y（y 不一定认识 x ,例如President同志） 。 </p>
<p>注：原文敏感内容已替换</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>仅包含一行一个实数，保留小数点后面 6 位，表示最大概率。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 4 </span><br><span class="line">1 2 </span><br><span class="line">1 3 </span><br><span class="line">1 4 </span><br><span class="line">1 5 </span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0.800000</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sample Input 图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1((1));d2((2));d3((3));d4((4));d5((5))</span><br><span class="line">d1---d2</span><br><span class="line">d1---d3</span><br><span class="line">d1---d4</span><br><span class="line">d1---d5</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>警察必须知道所有 n 个人的信息才能找到杀手，而假设警察知道所有人的信息至少需要询问x个人的话，那么这x 个人中有杀手的可能性就是：$\frac{x}{N}$</p>
<p>所以警察不会被杀手干掉的可能性就是：$1-\frac{x}{N}$</p>
<p>首先需要求出原图的强连通分量，然后把每个 SCC 缩点变为 DAG 图，接着统计入度为 0 的点，这里要注意：<strong>如果入度为 0 的点只有一个，那么 ans 就是 1 ，如果有超过 1 个入度为 0 的点，则当其中有一个点（其实是强连通分量）只包含一个结点时警察就不用去问了</strong></p>
<p>这是为什么呢？因为我们聪明的警察也会用排除法啊</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 300001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> neext,tto;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> nxt(x) g[x].neext</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> to(x) g[x].tto</span></span><br><span class="line">&#125;g[maxm]; <span class="type">int</span> head[maxm],tot;</span><br><span class="line"><span class="type">int</span> f[maxn],low[maxn],dfn[maxn];</span><br><span class="line"><span class="type">int</span> cp[maxn],cpt[maxn],dt,n,m;</span><br><span class="line"><span class="type">int</span> indeg[maxn];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Einsert</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="built_in">nxt</span>(++tot)=head[a];</span><br><span class="line">	<span class="built_in">to</span>(tot)=b; head[a]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> v (to(i))</span></span><br><span class="line">	low[u]=dfn[u]=++dt;</span><br><span class="line">	stk.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=<span class="built_in">nxt</span>(i))&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!cp[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">		cp[u]=++cp[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">while</span>(stk.<span class="built_in">top</span>()!=u)&#123;</span><br><span class="line">			cpt[cp[<span class="number">0</span>]]++;</span><br><span class="line">			cp[stk.<span class="built_in">top</span>()]=cp[<span class="number">0</span>];</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		stk.<span class="built_in">pop</span>();</span><br><span class="line">		cpt[cp[<span class="number">0</span>]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,indeg0s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;kill.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;kill.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> U,V;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;U&gt;&gt;V;</span><br><span class="line">		<span class="built_in">Einsert</span>(U,V);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=<span class="built_in">nxt</span>(j))</span><br><span class="line">			<span class="keyword">if</span>(cp[i]!=cp[<span class="built_in">to</span>(j)])</span><br><span class="line">				indeg[cp[<span class="built_in">to</span>(j)]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cp[<span class="number">0</span>];i++)</span><br><span class="line">		<span class="keyword">if</span>(!indeg[i])</span><br><span class="line">			ans=cpt[i], indeg0s++;</span><br><span class="line">	<span class="keyword">if</span>(indeg0s&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cp[<span class="number">0</span>];i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(indeg[i]==<span class="number">0</span> &amp;&amp; cpt[i]==<span class="number">1</span>) &#123;indeg0s--;<span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,<span class="number">1</span>-(<span class="type">double</span>)indeg0s/(<span class="type">double</span>)n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最小生成树 | 最短路径 |  \ 黑暗城堡 Dark Castle</title>
    <url>/2019/03/29/2019-03-29-%E9%BB%91%E6%9A%97%E5%9F%8E%E5%A0%A1%20DarkCastle/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>在顺利攻破 Lord lsp 的防线之后，lqr 一行人来到了 Lord lsp 的城堡下方。Lord lsp 黑化之后虽然拥有了强大的超能力，能够用意念力制造建筑物，但是智商水平却没怎么增加。现在 lqr 已经搞清楚黑暗城堡有 N 个房间，M 条可以制造的双向通道，以及每条通道的长度。</p>
<p>lqr 深知 Lord lsp 的想法， 为了避免每次都要琢磨两个房间之间的最短路径，Lord lsp一定会把城堡修建成树形的； 但是，为了尽量提高自己的移动效率，Lord lsp 一定会使得城堡满足下面的条件：设 Di 为如果所有的通道都被修建， 第 i 号房间与第 1 号房间的最短路径长度；而 Si 为实际修建的树形城堡中第 i 号房间与第1 号房间的路径长度，对于所有满足 1≤i≤N 的整数 i，有 Si = Di。为了打败 Lord lsp，lqr 想知道有多少种不同的城堡修建方案。于是 lqr 向 applepi 提出了这个问题。由于 applepi 还要忙着出模拟赛，所以这个任务就交给你了。当然，你只需要输出答案对 2^31 – 1 取模之后的结果就行了。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行有两个整数 N 和 M。</p>
<p>之后 M 行，每行三个整数 X，Y 和 L，表示可以修建 X 和 Y 之间的一条长度为 L 的通道。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一个整数，表示答案对 2^31 – 1 取模之后的结果。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">1 3 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>输入样例图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--2---2</span><br><span class="line">1--1---3</span><br><span class="line">2--1---3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先就是对原图跑一个最短路径（这里用的是 $Dijkstkra$ + 堆优化），然后暴力统计</p>
<p>根据题目要求，<strong>若 $father[y]=x$，且 $z=val(edge(x,y))$，就应该有 $dist[y]=dist[x]+z$（$y$ 的层次比 $x$ 深）</strong>，先把所有节点按照 $Dist$ 值排序</p>
<p><strong>依次考虑把每个节点 $p\in G$ 加入树形城堡有多少种方法，那么只要存在节点 $x$ ，使得 $x$ 和 $p$ 满足上述式子，那么 $p$ 与任意 $x$ 相连都可以，在 $p$ 点这一步就有 $cnt$ 种选择，其中 $cnt$ 表示满足条件的 $x$ 个数</strong></p>
<p>由于树的层次关系，只需考虑 $p​$ 与层次浅于 $p​$ 的点相连，也就是 $Dist​$ 值小于 $p​$ 的点即可</p>
<p>第一个点（$Dist$ 值最小的）无需考虑，乘法原理，将每一步得出的 $cnt$ 乘起来就是结果（过程中取模）</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 500001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Smaxn 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oo 1999999999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oo2 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> tto,nxxt,vval;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> to(x) g[x].tto</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> nxt(x) g[x].nxxt</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> val(x) g[x].vval</span></span><br><span class="line">&#125;g[maxm*<span class="number">2</span>]; <span class="type">int</span> fir[maxm*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dist[maxn],tot,n,m;</span><br><span class="line"><span class="type">bool</span> vis[maxn]; <span class="type">int</span> r[Smaxn][Smaxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Einsert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">nxt</span>(++tot)=fir[x];</span><br><span class="line">	fir[x]=tot;</span><br><span class="line">	<span class="built_in">to</span>(tot)=y;</span><br><span class="line">	<span class="built_in">val</span>(tot)=_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstkra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i]=oo;</span><br><span class="line">	dist[<span class="number">1</span>]=<span class="number">0</span>; vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	priority_queue&lt;pr&gt; q;</span><br><span class="line">	<span class="function">pr <span class="title">head</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>; <span class="type">int</span> _next,_val,_begin;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		head=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dist[head.second]!=-head.first) <span class="keyword">continue</span>;</span><br><span class="line">		vis[head.second]=<span class="literal">true</span>;</span><br><span class="line">		_begin=fir[head.second];</span><br><span class="line">		<span class="keyword">while</span>(_begin!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[<span class="built_in">to</span>(_begin)]&gt;dist[head.second]+<span class="built_in">val</span>(_begin))</span><br><span class="line">				<span class="keyword">if</span>(!vis[<span class="built_in">to</span>(_begin)])</span><br><span class="line">					dist[<span class="built_in">to</span>(_begin)]=dist[head.second]+<span class="built_in">val</span>(_begin),</span><br><span class="line">					q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dist[<span class="built_in">to</span>(_begin)],<span class="built_in">to</span>(_begin)));</span><br><span class="line">			_begin=<span class="built_in">nxt</span>(_begin);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dist[a]&lt;dist[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); <span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="built_in">memset</span>(r,oo2,<span class="built_in">sizeof</span>(r));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="built_in">Einsert</span>(a,b,c);</span><br><span class="line">		<span class="built_in">Einsert</span>(b,a,c);</span><br><span class="line">		r[a][b]=r[b][a]=<span class="built_in">min</span>(r[a][b],c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijkstkra</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) id[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,MyCmp);</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">			<span class="keyword">if</span>(dist[id[j]]+r[id[i]][id[j]]==dist[id[i]])</span><br><span class="line">				cnt++;</span><br><span class="line">		ans=(ans*cnt)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>最短路径</tag>
        <tag>Dijkstkra</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最短路径 | SPFA | 最小圈</title>
    <url>/2019/04/06/2019-04-06-%E6%9C%80%E5%B0%8F%E5%9C%88/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>对于一张有向图，要你求图中最小圈的平均值是多少，即若一个圈经过k个节点，那么一个圈的平均值为圈上k条边权之和除以k，求其中的最小值。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行2个正整数，分别为n，m，表示有n个定点，m条边以下m行，每行3个整，分别代表一条边的起点，终点，权值。输入数据保证该图是连通的且存在圈。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一行一个数，表示最小圈的值，保留8位小数</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input #1"></a>Sample Input #1</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 1 5</span><br><span class="line">2 4 3</span><br><span class="line">4 1 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output #1"></a>Sample Output #1</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3.66666667</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input #2"></a>Sample Input #2</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 -2.9</span><br><span class="line">2 1 -3.1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output #2"></a>Sample Output #2</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-3.00000000</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sample Input #1 图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1((1));d2((2));d3((3));d4((4))</span><br><span class="line">d1--5--&gt;d2</span><br><span class="line">d2--5--&gt;d3</span><br><span class="line">d3--5--&gt;d1</span><br><span class="line">d2--3--&gt;d4</span><br><span class="line">d4--3--&gt;d1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最小圈如图，平均值为：3.66666667</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1((1));d2((2));d4((4))</span><br><span class="line">d1--5--&gt;d2</span><br><span class="line">d2--3--&gt;d4</span><br><span class="line">d4--3--&gt;d1</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目中的最小圈的权值可正可负，而最短路的 $SPFA$ 算法只能在图中判断负环，<strong>于是可以二分这个最小圈的平均权值 $mid$，用 $SPFA$ 在原图中找负环来 $Check$</strong></p>
<p><strong>如果当前图中的所有边权减去这个权值后存在了负环，说明原图中的最小圈的平均权值小于我们当前的答案，那么 $mid$ 需要往小猜，如果新图中不存在负环，则最小圈的权值大于当前答案，$mid$ 也就应该增大了</strong></p>
<p>因为图中给的边权是 double 类型，所以要用到实数型二分</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cls(Arr,Dst) memset(Arr,Dst,sizeof(Arr))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 3001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e-10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oo 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="type">double</span> vl;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> to(x) g[x].u</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> nxt(x) g[x].v</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> val(x) g[x].vl</span></span><br><span class="line">&#125;g[maxm]; <span class="type">int</span> tot,head[maxm],n,m;</span><br><span class="line"><span class="type">double</span> d[maxn]; <span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Einsert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">double</span> _v)</span></span>&#123;</span><br><span class="line">	<span class="built_in">nxt</span>(++tot)=head[x];</span><br><span class="line">	head[x]=tot; <span class="built_in">to</span>(tot)=y;</span><br><span class="line">	<span class="built_in">val</span>(tot)=_v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> v0,<span class="type">double</span> del)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> vt to(i)</span></span><br><span class="line">	vis[v0]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[v0];i;i=<span class="built_in">nxt</span>(i))&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[vt]&gt;d[v0]+<span class="built_in">val</span>(i)-del)&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[vt]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				d[vt]=d[v0]+<span class="built_in">val</span>(i)-del;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">spfa</span>(vt,del)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vis[v0]=<span class="literal">false</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> vt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">double</span> aver)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cls</span>(d,<span class="number">0</span>);<span class="built_in">cls</span>(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">spfa</span>(i,aver)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> x,y; <span class="type">double</span> z;</span><br><span class="line">	<span class="type">double</span> l,r=oo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf&quot;</span>,&amp;x,&amp;y,&amp;z);;</span><br><span class="line">		<span class="built_in">Einsert</span>(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	l=-r; <span class="type">double</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;INF)&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">judge</span>(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>SPFA</tag>
        <tag>环</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 强连通分量 | Tarjan | [SDOI2010]所驼  门王的宝藏</title>
    <url>/2019/04/08/2019-04-08-%E6%89%80%E9%A9%BC%E9%97%A8%E7%8E%8B%E7%9A%84%E5%AE%9D%E8%97%8F/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 Alpaca L. Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。 </p>
</blockquote>
<p>整座宫殿呈矩阵状，由 R×C 间矩形宫室组成，其中有 N 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 N 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种: </p>
<ol>
<li>“横天门”：由该门可以传送到同行的任一宫室; </li>
<li>“纵寰门”：由该门可以传送到同列的任一宫室; </li>
<li>“自由门”：由该门可以传送到以该门所在宫室为中心周围8格中任一宫室(如果目标宫室存在的话)。</li>
</ol>
<p>深谋远虑的  Henry  当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。  现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏， 他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉  Henry 这条路 线最多行经不同藏宝宫室的数目。 </p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行给出三个正整数 N， R， C。 以下 N 行，每行给出一扇传送门的信息，包含三个正整数 xi， yi， Ti，表示该 传送门设在位于第 xi 行第 yi 列的藏宝宫室，类型为 Ti。Ti 是一个 1~3 间的整数， 1 表示可以传送到第 xi 行任意一列的“横天门”，2 表示可以传送到任意一行第 yi 列的“纵寰门”，3 表示可以传送到周围 8 格宫室的“自由门”。 保证<br>1≤xi≤R，1≤yi≤C，所有的传送门位置互不相同。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>只有一个正整数,表示你确定的路线所经过不同藏宝 宫室的最大数目。 </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10 7 7 </span><br><span class="line">2 2 1 </span><br><span class="line">2 4 2 </span><br><span class="line">1 7 2 </span><br><span class="line">2 7 3 </span><br><span class="line">4 2 2 </span><br><span class="line">4 4 1 </span><br><span class="line">6 7 3 </span><br><span class="line">7 7 1 </span><br><span class="line">7 5 2 </span><br><span class="line">5 2 1 </span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sample Input 图示：</strong></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列/行</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>5</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>6</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p><img src="http://newoj.cqyz.cn/public/upload/795b7633e6.png" alt="Data Range"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题看似恐怖，实际上如果我们根据途中宝藏门的特点，将图建好之后，就是一道有向图的动态规划题，先说建好图后如何求出最大的藏宝路线</p>
<p>对于一张建好了的有向图 $G1$，首先求出这个图的强连通分量，那么 Henry 可以在这个强连通分量里面随意穿梭，但是只能得到强连通分量所包含的点的数量的宝藏，<strong>将强连通分量缩点，根据每一个强连通分点建新图 $G2$，此时 $G2$ 一定是一个有向无环的 DAG 图，那么我们只需要在这个 DAG 图上进行 DFS 来看，以每个点作为起点，能遍历到多少不同的点就可以了，注意这个图可能本身不连通，因此要主程序中枚举所有的强连通分点来 DFS，最后取最大值</strong></p>
<p>那么接下来就是如何构建图 $G1​$ 了</p>
<p>根据题目的极限数据有 $100,000​$ 个点，如果每两个点之间都连一条边，那么边数最多将会达到$100,000\times (100,000-1)​$，毫无疑问会造成 MLE，这个时候我们发现：<strong>如果在一行上有多个横天门，那么只需要将其中的一个横天门与剩下的点连边，然后将剩下的横天门与这个横天门连边，就能保证一行上的所有横天门都能到达这一行上的所有点，纵寰门同理</strong></p>
<p>那么极限情况下（全部是横天门，或者纵寰门），除去自由门，只需要记录 $N\times 2$ 条边就完事儿了，最后的自由门没有优化技巧，只能按照八个方向依次加边，因此边集数组的大小是：$8\times N$，$N$ 表示点数极限</p>
<p>在建图 $G1​$ 的时候，按照上述思路，需要记录各点的坐标（x，y），记录各行上的点，各列上的点（用 Vector 实现），记录各个点的一维编号（为自由门加边做准备），只需要取各行各列的第一个横天门（或者纵寰门）来加边，其他门加到它们上面去即可</p>
<p>各个点的一维编号是用 x 坐标乘上 maxrow 加上 y 坐标来表示，这种方法在用回溯解决数独问题的时候也用过（题目链接：<a href="http://newoj.cqyz.cn/problem/P1194">P1194 【训练题】数独</a>）</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxr 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,nxt;</span><br><span class="line">&#125;g[maxn*<span class="number">8</span>],g2[maxn*<span class="number">8</span>]; <span class="type">int</span> tot,tot2;</span><br><span class="line"><span class="type">int</span> head[maxn],head2[maxn];</span><br><span class="line"><span class="type">int</span> n,R,C,T[maxn],posx[maxn],posy[maxn];</span><br><span class="line"><span class="type">int</span> low[maxn],dfn[maxn],dt;</span><br><span class="line"><span class="type">int</span> cp[maxn],cpt[maxn]; stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">int</span> f[maxn]; <span class="comment">// dp array </span></span><br><span class="line"><span class="type">bool</span> ins[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; rs[maxr],cs[maxr];</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; M;</span><br><span class="line"><span class="type">int</span> offsetX[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> offsetY[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">convert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ll)x*maxr+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Einsert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	g[++tot].nxt=head[x];</span><br><span class="line">	g[tot].to=y; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Einsert2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	g2[++tot2].nxt=head2[x];</span><br><span class="line">	g2[tot2].to=y; head2[x]=tot2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _firstbuild()&#123;</span><br><span class="line">	<span class="type">int</span> sig=<span class="number">0</span>,vlen;</span><br><span class="line">	<span class="comment">// for rows </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=R;i++)&#123;</span><br><span class="line">		sig=<span class="number">0</span>; vlen=rs[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vlen;j++)</span><br><span class="line">			<span class="keyword">if</span>(T[rs[i][j]]==<span class="number">1</span>)&#123;sig=rs[i][j];<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(sig)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vlen;j++)&#123;</span><br><span class="line">				<span class="built_in">Einsert</span>(sig,rs[i][j]);</span><br><span class="line">				<span class="keyword">if</span>(T[rs[i][j]]==<span class="number">1</span>)<span class="built_in">Einsert</span>(rs[i][j],sig);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for cols </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">		sig=<span class="number">0</span>; vlen=cs[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vlen;j++)</span><br><span class="line">			<span class="keyword">if</span>(T[cs[i][j]]==<span class="number">2</span>)&#123;sig=cs[i][j];<span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(sig)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vlen;j++)&#123;</span><br><span class="line">				<span class="built_in">Einsert</span>(sig,cs[i][j]);</span><br><span class="line">				<span class="keyword">if</span>(T[cs[i][j]]==<span class="number">2</span>)<span class="built_in">Einsert</span>(cs[i][j],sig);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for 9ggs </span></span><br><span class="line">	<span class="type">int</span> newx,newy;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(T[i]==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">				newx=posx[i]+offsetX[j]; </span><br><span class="line">				newy=posy[i]+offsetY[j];</span><br><span class="line">				<span class="keyword">if</span>(M[<span class="built_in">convert</span>(newx,newy)])&#123;</span><br><span class="line">					<span class="built_in">Einsert</span>(M[<span class="built_in">convert</span>(posx[i],posy[i])],M[<span class="built_in">convert</span>(newx,newy)]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _secondbuild()&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=g[j].nxt)&#123;</span><br><span class="line">			k=g[j].to;</span><br><span class="line">			<span class="keyword">if</span>(cp[i]!=cp[k])</span><br><span class="line">				<span class="built_in">Einsert2</span>(cp[i],cp[k]);	</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++dt; stk.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="type">int</span> v; ins[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=g[i].nxt)&#123;</span><br><span class="line">		v=g[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(ins[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">		<span class="type">int</span> shead; cp[<span class="number">0</span>]++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			shead=stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">			cp[shead]=cp[<span class="number">0</span>];</span><br><span class="line">			cpt[cp[<span class="number">0</span>]]++; ins[shead]=<span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">while</span>(shead!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[u]) <span class="keyword">return</span> f[u]; <span class="type">int</span> v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head2[u];i;i=g2[i].nxt)&#123;</span><br><span class="line">		v=g2[i].to;</span><br><span class="line">		f[u]=<span class="built_in">max</span>(f[u],<span class="built_in">dfs</span>(v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[u]=f[u]+cpt[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;soto.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;soto.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;R&gt;&gt;C;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;posx[i]&gt;&gt;posy[i]&gt;&gt;T[i];</span><br><span class="line">		rs[posx[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">		cs[posy[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">		M[<span class="built_in">convert</span>(posx[i],posy[i])]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	_firstbuild();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">	_secondbuild();</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cp[<span class="number">0</span>];i++)</span><br><span class="line">		<span class="keyword">if</span>(!f[i]) ans=<span class="built_in">max</span>(ans,<span class="built_in">dfs</span>(i));</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最短路径 | 新年好</title>
    <url>/2019/04/09/2019-04-09-%E6%96%B0%E5%B9%B4%E5%A5%BD/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>重庆城里有n个车站，m条双向公路连接其中的某些站。每两个车站最多用一条公路直接相连，从任何一个车站出发都可以经过一条或多条公路到达其它车站，但不同的路径需要花费的时间可能不同。在一条路径上花费的时间等于路径上所有公路需要的时间和。</p>
<p>佳佳的家在车站1，他有五个亲戚，分别住在车站a、b、c、d、e。过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。怎样走，才需要最少的时间？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行：n（n&lt;=50,000），m（m&lt;=100,000），为车站数目和公路的数目。</p>
<p>第二行：a、b、c、d、e，为五个亲戚所在车站编号（1&lt; a、b、c、d、e &lt;= n）</p>
<p>接下来m行，每行三个整数x、y、t（ 1 &lt;= x、y &lt;= n，1 &lt;= t &lt;= 100），为公路连接的两个车站编号和时间。 </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>仅一行，包含一个整数T，为最少的总时间</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">2 3 4 5 6</span><br><span class="line">1 2 8</span><br><span class="line">2 3 3</span><br><span class="line">3 4 4</span><br><span class="line">4 5 5</span><br><span class="line">5 6 2</span><br><span class="line">1 6 7</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sample Input 图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1((&quot;1（佳佳）&quot;));d2((亲戚1));d3((亲戚2))</span><br><span class="line">d4((亲戚3));d5((亲戚4));d6((亲戚5))</span><br><span class="line">d1--8---d2</span><br><span class="line">d2--3---d3</span><br><span class="line">d3--4---d4</span><br><span class="line">d4--5---d5</span><br><span class="line">d5--2---d6</span><br><span class="line">d1--7---d6</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>n&lt;=50,000，m&lt;=100,000</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题是求最短路径的一个拓展，我们先求出以佳佳为起点，到达所有点的单源最短路径，再根据给出的 5 个亲戚，求出以这 5 个亲戚为起点到所有点的最短路径（注意要用不同的 dist 数组存，也就是要开 6 个dist 数组存储最短路）</p>
<p>佳佳访问 5 个亲戚的顺序是一个 5 选 5 的全排列，一共有 120 种不同的访问顺序，<strong>如果按照当前已经确定的顺序 order 来访问，则在 order 下佳佳能取得的最短路径就是在访问到某个亲戚家（把佳佳自己看做第 0 个亲戚）要往下一个亲戚家走的时候，选择以当前亲戚家为起点，求出的到目标亲戚家的最短路径加上即可，写成式子：</strong></p>
<script type="math/tex; mode=display">对于\;order\{a_0， a_1，a_2，a_3，a_4，a_5 \}\;(a_0\;是佳佳的家)\\\\Ans=\sum^4_{k=0}dist[a_k][a_{k+1}]</script><p>由于这里的枚举 order 数组，算出所有排列下的 Ans ，取最小值即可</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxm=<span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">150000000</span>;</span><br><span class="line"><span class="type">int</span> n,m,np=<span class="number">0</span>,last[maxn],rela[<span class="number">6</span>],dist[<span class="number">6</span>][maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to,w,pre;&#125;E[maxm*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span>&#123;</span><br><span class="line">	<span class="type">int</span> d,id;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> data &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&gt;obj.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	E[++np]=(edge)&#123;v,w,last[u]&#125;;</span><br><span class="line">	last[u]=np;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> done[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> *dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;data&gt;pq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=INF,done[i]=<span class="number">0</span>;</span><br><span class="line">	pq.<span class="built_in">push</span>((data)&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		data t=pq.<span class="built_in">top</span>();pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> i=t.id;</span><br><span class="line">		<span class="keyword">if</span>(done[i]) <span class="keyword">continue</span>;</span><br><span class="line">		done[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p=last[i];p;p=E[p].pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j=E[p].to,w=E[p].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[j]&gt;dis[i]+w)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[j]=dis[i]+w;</span><br><span class="line">				pq.<span class="built_in">push</span>((data)&#123;dis[j],j&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> order[<span class="number">6</span>];<span class="type">int</span> ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=order[i],y=rela[order[i+<span class="number">1</span>]];</span><br><span class="line">		cnt+=dist[x][y];</span><br><span class="line">	&#125;</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">res</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">120</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">calc</span>();</span><br><span class="line">		<span class="built_in">next_permutation</span>(order+<span class="number">1</span>,order+<span class="number">1</span>+<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// next_permutation 当前数组的下一个全排列 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) cin&gt;&gt;rela[i];</span><br><span class="line">	<span class="keyword">register</span> <span class="type">int</span> u,v,w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		<span class="built_in">addedge</span>(u,v,w);<span class="built_in">addedge</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	rela[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++) <span class="built_in">Dijkstra</span>(rela[i],dist[i]); </span><br><span class="line">	order[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) order[i]=i;</span><br><span class="line">	<span class="built_in">res</span>(); cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 欧拉回路 | 欧拉回路 &amp; 欧  拉路径</title>
    <url>/2019/04/12/2019-04-12-%E6%AC%A7%E6%8B%89%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="T1：欧拉路径"><a href="#T1：欧拉路径" class="headerlink" title="T1：欧拉路径"></a>T1：欧拉路径</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>18世纪著名的数学问题之一：在哥尼斯堡的一个公园里，有7座桥将河中两个岛及河两岸连接起来(如图a)。问是否可能从这四块陆地中任一块出发，恰好通过每座桥一次，再回到起点？　　　</p>
<p>欧拉于1736年研究并解决了此问题。欧拉把每一块陆地考虑成一个点，连接两块陆地的桥以边表示，画出图b的图论模型，由此问题变成：能否从无向图的一个结点出发走出一条路径，每条边恰好经过一次，最后回到出发点。这样的路线称为欧拉回路，也可以称为一笔画。</p>
<p>你的任务与欧拉一样：给出n个顶点（编号为1..n），m条边的无向图。请寻找一条欧拉路径。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第1行为整数n，接下来的 m 行，每行两个整数：i,j(1&lt;=i,j&lt;=n)，表示一条无向边。 </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>如果不存在欧拉路径，则输出NIE。否则输出应当包含 m+1 个整数，依次表示欧拉路径经过的顶点号。如果把欧拉路径经过的结点序列看成是一个n进制的数，那么当存在多组解的情况下，输出n进制表示法中最小的一个（也就是输出第一个数较小的，如果还有多解，输出第二个数较小的，…，实质就是字典序）。 </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 2</span><br><span class="line">4 5</span><br><span class="line">2 5</span><br><span class="line">5 6</span><br><span class="line">5 7</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 2 3 4 2 5 4 6 5 7</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sample Input 图示：（欧拉路为 <code>1 2 3 4 2 5 4 6 5 7</code>）</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1---2;2---3;3---4;4---2;4---5</span><br><span class="line">2---5;5---6;5---7;4---6</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>1&lt;=n&lt;=500, 1&lt;=m&lt;=1024</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一道欧拉路径的模板题，大致思路和求解欧拉路的模板算法一样，只是这个题要求输出字典序最小的欧拉路经上的点，那么可以想到将边集数组改变，因为原本的前向星不能保证字典序最小</p>
<p><strong>可以用 Vector 模拟边集数组，进行排序之后再 DFS ，就可以保证求得欧拉路的时候字典序最小了，这可能会丢失修改 head 数组的时间优化，但是这个题数据太水，也能 AC</strong></p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 501</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 1025</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,to;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> edge &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> to&lt;obj.to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; vector&lt;edge&gt; g[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxm*<span class="number">2</span>]; <span class="type">int</span> res[<span class="number">2</span>*maxm];</span><br><span class="line"><span class="type">int</span> f[maxn];</span><br><span class="line"><span class="type">int</span> n,m,deg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_euler</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	vector&lt;edge&gt;::iterator iter=g[u].<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span>(iter!=g[u].<span class="built_in">end</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[iter-&gt;id])&#123;</span><br><span class="line">			vis[iter-&gt;id]=<span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">dfs_euler</span>(iter-&gt;to);</span><br><span class="line">		&#125;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	res[++res[<span class="number">0</span>]]=u;</span><br><span class="line">&#125; <span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> U,V,fu,fv;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;U&gt;&gt;V;</span><br><span class="line">		g[U].<span class="built_in">push_back</span>((edge)&#123;i,V&#125;);</span><br><span class="line">		g[V].<span class="built_in">push_back</span>((edge)&#123;i,U&#125;);</span><br><span class="line">		deg[U]++; deg[V]++;</span><br><span class="line">		fu=<span class="built_in">Sfind</span>(U); fv=<span class="built_in">Sfind</span>(V);</span><br><span class="line">		f[fu]=fv;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">sort</span>(g[i].<span class="built_in">begin</span>(),g[i].<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> st=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">// JUDGE 1 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(deg[i]&amp;<span class="number">1</span>) cnt++;</span><br><span class="line">	<span class="keyword">if</span>(cnt&gt;<span class="number">2</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;NIE&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// JUDGE 2 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Sfind</span>(f[i])!=<span class="built_in">Sfind</span>(f[i<span class="number">-1</span>]))&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;NIE&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(deg[i]&amp;<span class="number">1</span>)&#123;st=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">	<span class="built_in">dfs_euler</span>(st);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=res[<span class="number">0</span>];i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;res[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="T2：欧拉回路"><a href="#T2：欧拉回路" class="headerlink" title="T2：欧拉回路"></a>T2：欧拉回路</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>有一天一位灵魂画师画了一张图，现在要你找出欧拉回路，即在图中找一个环使得每条边都在环上出现恰好一次。</p>
<p>一共两个子任务：</p>
<ol>
<li>这张图是无向图。（50分）</li>
<li>这张图是有向图。（50分）</li>
</ol>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>第一行一个整数 t</p>
<p>第二行两个整数 n,m</p>
<p>接下来 m行，每行两个整数u,v</p>
<p>如果 t=1 表示无向边(u,v)，如果 t=2 表示有向边<u,v>，图中可能有重边也可能有自环。</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>如果不可以一笔画，输出一行 “NO”。</p>
<p>否则，输出一行 “YES”，接下来一行输出一组方案。</p>
<p>如果 t=1,输出m个整数：p1,p2…m。表示边的编号。若pi为正，表示从ui走到vi，否则表示从vi走到ui如果 t=2,输出m个整数，表示边的编号。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input #1"></a>Sample Input #1</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output #1"></a>Sample Output #1</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">3 -2 -1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input #2"></a>Sample Input #2</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5 6</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">4 2</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output #2"></a>Sample Output #2</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">4 1 3 5 2 6</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sample Input #2 图示：（欧拉路为 <code>4，1，3，5，2，6</code>）</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1((1));d2((2));d3((3));d4((4));d5((5));</span><br><span class="line">d2--1--&gt;d3;d2--2--&gt;d5</span><br><span class="line">d3--3--&gt;d4;d1--4--&gt;d2</span><br><span class="line">d4--5--&gt;d2;d5--6--&gt;d1</span><br></pre></td></tr></table></figure>
<h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>1≤n≤10^5，0≤m≤2×10^5</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>求解欧拉路径的一个模板题，因为 m 的范围不大，可以用比较好写的 DFS 来求解，大致思路和求解欧拉路径的模板代码一样，这里说说如何存放欧拉路上的边的编号</p>
<p>对于y</p>
<p>由于无向图加边的连续性，如果边集数组的 tot 从 1 开始，那么对于一对点 (u，v) 来说，从 u 到 v 的边号始终是奇数（1，3，5，7，……），从 v 到 u 的反向边就是偶数，由此就可以判断当前边的方向，然后看是存正编号还是负编号</p>
<p><strong>对于无向图，在判断某条边是否访问过时，把无向图想成有向图，那么每条边的编号将会缩小一倍（除以 2），这样走过之后把 $vis[i\div 2]$ 标记即可，判断也只判断 $vis[i\div 2]$  ，加边时也要加 $i\div 2$</strong></p>
<p>对于有向图，直接对这条边的编号进行操作即可</p>
<h2 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 5*100001</span></span><br><span class="line"><span class="comment">// for not directed graph </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> head[maxn],nxt[maxm],to[maxm];</span><br><span class="line"><span class="type">int</span> res[maxm],tot=<span class="number">1</span>,n,m;</span><br><span class="line"><span class="type">int</span> ind[maxn],oud[maxn]; <span class="comment">// outdegs and indegs </span></span><br><span class="line"><span class="type">bool</span> vis[<span class="number">2</span>*maxn]; <span class="type">int</span> typ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	nxt[++tot]=head[u]; to[tot]=v;</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> &amp;i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="type">int</span> v=to[i]; <span class="type">int</span> c=(typ==<span class="number">1</span>)?(i/<span class="number">2</span>):(i<span class="number">-1</span>);</span><br><span class="line">		<span class="type">int</span> s=i%<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[c]) <span class="keyword">continue</span>; </span><br><span class="line">		vis[c]=<span class="literal">true</span>;</span><br><span class="line">		<span class="built_in">euler</span>(v);</span><br><span class="line">		<span class="keyword">if</span>(typ==<span class="number">1</span>) res[++res[<span class="number">0</span>]]=(s?(-c):c);</span><br><span class="line">		<span class="keyword">else</span> res[++res[<span class="number">0</span>]]=c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;typ;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y; <span class="built_in">Eadd</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span>(typ==<span class="number">1</span>) <span class="built_in">Eadd</span>(y,x);</span><br><span class="line">		oud[x]++; ind[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// JUDGE </span></span><br><span class="line">	<span class="keyword">if</span>(typ==<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(ind[i]!=oud[i])&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>((ind[i]+oud[i])&amp;<span class="number">1</span>)&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// SOLVE </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(head[i])&#123;</span><br><span class="line">			<span class="built_in">euler</span>(i);<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(res[<span class="number">0</span>]!=m) &#123; cout&lt;&lt;<span class="string">&quot;NO&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=res[<span class="number">0</span>];i;i--) cout&lt;&lt;res[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>欧拉回路</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 欧拉回路 | 太鼓达人</title>
    <url>/2019/04/13/2019-04-13-%E5%A4%AA%E9%BC%93%E8%BE%BE%E4%BA%BA/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>七夕祭上，Vani牵着cl的手，在明亮的灯光和欢乐的气氛中愉快地穿行。这时，在前面忽然出现了一台太鼓达人机台，而在机台前坐着的是刚刚被精英队伍成员XLk、Poet_shy和lydrainbowcat拯救出来的的applepi。看到两人对太鼓达人产生了兴趣，applepi果断闪人，于是cl拿起鼓棒准备挑战。然而即使是在普通难度下，cl的路人本性也充分地暴露了出来。一曲终了，不但没有过关，就连鼓都不灵了。Vani十分过意不去，决定帮助工作人员修鼓。</p>
<p>鼓的主要元件是M个围成一圈的传感器。每个传感器都有开和关两种工作状态，分别用1和0表示。显然，从不同的位置出发沿顺时针方向连续检查K个传感器可以得到M个长度为K的01串。Vani知道这M个01串应该是互不相同的。而且鼓的设计很精密，M会取到可能的最大值。现在Vani已经了解到了K的值，他希望你求出M的值，并给出字典序最小的传感器排布方案。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>一个整数K。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一个整数M和一个二进制串，由一个空格分隔。表示可能的最大的M，以及字典序最小的排布方案，字符0表示关，1表示开。你输出的串的第一个字和最后一个字是相邻的。</p>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>得到的8个01串分别是000、001、010、101、011、111、110和100。注意前后是相邻的。长度为3的二进制串总共只有8种，所以M = 8一定是可能的最大值。</p>
<p>对于全部测试点，2≤K≤11。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>开始一看这个题好像跟欧拉回路扯不上半点关系，但是，<del>根据输入输出样例来猜测</del>，我们可以知道第一问的答案显然是：$2^n$</p>
<p>然后题目好像是要求给出一个数 K，将小于等于 K 的所有数字表示成二进制后，将首尾一样的二进制数首尾连接起来（连接的时候保证前一个数的最后一位与后一个数的第一位一样，且在这两个相同的数字中只保留一个）成一个串，而且这些数不能重复使用，要求出一个最小的长度为 M（M就是第一问的答案）的串</p>
<p>用 <strong>DFS</strong> 来做，思路是：<strong>先构造一个包含 $2^n-1$ 个点的图 G，然后对于每个点 S，将 S 与 (S&lt;&lt;1)&amp;(M-1) 和 (S&lt;&lt;1)&amp;(M-1) +1 号点分别连出一条边，会发现图 G 是一个欧拉图，用 DFS 求出这个图的欧拉回路然后逆序输出，同时满足字典序最小的条件即可</strong></p>
<p>上面运算时与 (M-1) 相与是为了甩掉多余的位数从而得出下一个目标点的编号</p>
<p>实际编程用不到这么复杂，其实就一个 <strong>DFS+VIS数组</strong> 判断是否访问过即可</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> res[maxn],n,maxk;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s1=(k&lt;&lt;<span class="number">1</span>) &amp; maxk;</span><br><span class="line">	<span class="type">int</span> s2=((k&lt;&lt;<span class="number">1</span>) &amp; maxk) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!vis[s1])&#123;</span><br><span class="line">		vis[s1]=<span class="literal">true</span>; <span class="built_in">euler</span>(s1);</span><br><span class="line">		res[++res[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">if</span>(!vis[s2])&#123;</span><br><span class="line">		vis[s2]=<span class="literal">true</span>; <span class="built_in">euler</span>(s2);</span><br><span class="line">		res[++res[<span class="number">0</span>]]=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n; maxk=<span class="number">1</span>&lt;&lt;n; cout&lt;&lt;maxk;</span><br><span class="line">	maxk--;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">euler</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=res[<span class="number">0</span>];i&gt;=n;i--) cout&lt;&lt;res[i];	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>图论</tag>
        <tag>欧拉回路</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最短路径 | SPFA | 20190414 考试(图  论综合1)</title>
    <url>/2019/04/15/2019-04-15-%E5%9B%BE%E8%AE%BA%E8%80%83%E8%AF%951/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="Problem-1-升降梯-Up-Down"><a href="#Problem-1-升降梯-Up-Down" class="headerlink" title="Problem 1. 升降梯(Up-Down)"></a>Problem 1. 升降梯(Up-Down)</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>开启了升降梯的动力之后，探险队员们进入了升降梯运行的那条竖直的隧道，映入眼帘的是一条直通塔顶的轨道、一辆停在轨道底部的电梯、和电梯内一杆控制电梯升降的巨大手柄。 </p>
<p>塔一共有 N 层，升降梯在每层都有一个停靠点。手柄有 M 个控制槽，第 i 个控制槽旁边标着一个数 Ci，满足 C1<C2<C3<……<CM。如果 Ci>0，表示手柄扳动到该槽时，电梯将上升 Ci 层；如果 Ci&lt;0，表示手柄扳动到该槽时，电梯将下降 -Ci 层；并且一定存在一个 Ci=0，手柄最初就位于此槽中。注意升降梯只能在 1~N 层间移动，因此扳动到使升降梯移动到 1 层以下、N 层以上的控制槽是不允许的。 </p>
<p>电梯每移动一层，需要花费 2 秒钟时间，而手柄从一个控制槽扳到相邻的槽，需要花费 1 秒钟时间。探险队员现在在 1 层，并且想尽快到达 N 层，他们想知道从 1 层到 N 层至少需要多长时间？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行两个正整数 N、M。 </p>
<p>第二行 M 个整数 C1、C2„„CM</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出一个整数表示答案，即至少需要多长时间。若不可能到达输出-1。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">-1 0 2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>手柄从第二个槽扳到第三个槽（0 扳到 2），用时 1 秒，电梯上升到 3 层，用时 4 秒。 </p>
<p>手柄在第三个槽不动，电梯再上升到 5 层，用时 4 秒。 </p>
<p>手柄扳动到第一个槽（2 扳到-1），用时 2 秒，电梯下降到 4 层，用时 2 秒。手柄扳动到第三个槽（-1 扳倒 2），用时 2 秒，电梯上升到 6 层，用时 4 秒。 </p>
<p>总用时为(1+4)+4+(2+2)+(2+4)=19秒。</p>
<h2 id="Data-Range"><a href="#Data-Range" class="headerlink" title="Data Range"></a>Data Range</h2><p>对于 30% 的数据，满足 1≤N≤10，2&lt;=M&lt;=5。对于 100% 的数据，满足 1≤N≤1000，2&lt;=M&lt;=20，-N&lt;C1&lt;C2&lt;……&lt;CM&lt;N。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>思路：把每 N 层楼看作 N 个点，把 M 个对应数字的槽看作特殊的边，遍历 N 层楼建图加边</p>
<p>具体来说：<strong>对于 $\forall i \in [1\;,\;N]$，$\forall j \in[1\;,\;M]$，如果满足 $i+c[j]\geq1\;\;and\;\;i+c[j]\leq N$，说明通过把手柄搬到 j 号位置，能够将电梯从 i 号楼层送到 i+c[j] 号楼层（至于时间稍后计算），那么连一条有向边，记录两个信息(to，way)，to 表示去往的楼层，way 表示手柄停在的槽的编号</strong></p>
<p>然后用这个二元组进行 SPFA 即可求出最短路，输出 dist[n]</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 21021</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line">vector&lt;pr&gt; g[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn],n,m,c[maxm];</span><br><span class="line"><span class="type">int</span> dist[maxn];<span class="type">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildG</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==x) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(i+c[j]&lt;<span class="number">1</span> || i+c[j]&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			g[i].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i+c[j],j));</span><br><span class="line">			<span class="comment">// pair&lt;i+c[j],j&gt;</span></span><br><span class="line">			<span class="comment">// i 到 i+c[j] 通过 j 号槽实现  </span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dists</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> edg1,<span class="type">int</span> edg2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(x-y)*<span class="number">2</span>+<span class="built_in">abs</span>(edg1-edg2);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">shortest</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">127</span>,<span class="built_in">sizeof</span>(dist));dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// pair &lt; 去往哪个点 , 当前在哪个槽 &gt;  </span></span><br><span class="line">	queue&lt;pr&gt; q; q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,x));pr qhead;</span><br><span class="line">	vector&lt;pr&gt;::iterator iter;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> u qhead.first</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> pos qhead.second</span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		qhead=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(iter=g[u].<span class="built_in">begin</span>();iter!=g[u].<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[u]+<span class="built_in">dists</span>(u,iter-&gt;first,pos,iter-&gt;second)&lt;dist[iter-&gt;first])&#123;</span><br><span class="line">				dist[iter-&gt;first]=dist[u]+<span class="built_in">dists</span>(u,iter-&gt;first,pos,iter-&gt;second);</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(iter-&gt;first,iter-&gt;second));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> u</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> pos</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;updown.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;updown.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123; </span><br><span class="line">		cin&gt;&gt;c[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i]==<span class="number">0</span>) x=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">buildG</span>();<span class="built_in">shortest</span>();</span><br><span class="line">	cout&lt;&lt;(dist[n]==<span class="number">2139062143</span>?<span class="number">-1</span>:dist[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Problem-2-虫洞-Holes"><a href="#Problem-2-虫洞-Holes" class="headerlink" title="Problem 2. 虫洞(Holes)"></a>Problem 2. 虫洞(Holes)</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>N个虫洞，M条单向跃迁路径。从一个虫洞沿跃迁路径到另一个虫洞需要消耗一定量的燃料和1单位时间。虫洞有白洞和黑洞之分。设一条跃迁路径两端的虫洞质量差为delta。</p>
<ol>
<li><p>从白洞跃迁到黑洞，消耗的燃料值减少delta，若该条路径消耗的燃料值变为负数的话，取为0。</p>
</li>
<li><p>从黑洞跃迁到白洞，消耗的燃料值增加delta。</p>
</li>
<li><p>路径两端均为黑洞或白洞，消耗的燃料值不变化。</p>
</li>
</ol>
<p>作为压轴题，自然不会是如此简单的最短路问题，所以每过1单位时间黑洞变为白洞，白洞变为黑洞。在飞行过程中，可以选择在一个虫洞停留1个单位时间，如果当前为白洞，则不消耗燃料，否则消耗s[i]的燃料。现在请你求出从虫洞1到N最少的燃料消耗，保证一定存在1到N的路线。</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>第1行：2个正整数N,M</p>
<p>第2行：N个整数，第i个为0表示虫洞i开始时为白洞，1表示黑洞。</p>
<p>第3行：N个整数，第i个数表示虫洞i的质量w[i]。</p>
<p>第4行：N个整数，第i个数表示在虫洞i停留消耗的燃料s[i]。</p>
<p>第5..M+4行：每行3个整数，u,v,k，表示在没有影响的情况下，从虫洞u到虫洞v需要消耗燃料k。</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>一个整数，表示最少的燃料消耗。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 0 1 0</span><br><span class="line">10 10 100 10</span><br><span class="line">5 20 15 10</span><br><span class="line">1 2 30</span><br><span class="line">2 3 40</span><br><span class="line">1 3 20</span><br><span class="line">1 4 200</span><br><span class="line">3 4 200</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">130</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>输入数据图示：</strong></p>
<p><strong>括号内标注了洞的质量和 s 值，方框表示开始为黑洞，圆框表示为白洞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">d1[&quot;1 (m=10,s=5)&quot;];d2((&quot;2 (m=10,s=20)&quot;));</span><br><span class="line">d3[&quot;3 (m=100,s=15)&quot;];d4((&quot;4 (m=10,s=10)&quot;))</span><br><span class="line">d1--30--&gt;d2;d2--40--&gt;d3;d1--20--&gt;d3;</span><br><span class="line">d1--200--&gt;d4;d3--200--&gt;d4</span><br></pre></td></tr></table></figure>
<h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><blockquote>
<p><strong>按照<code>1-&gt;3-&gt;4</code>的路线，总消耗：20+200-90=130</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--&quot;20 delta=0&quot;--&gt;3</span><br><span class="line">3--&quot;200 delta=-90&quot;--&gt;4</span><br></pre></td></tr></table></figure>
<h2 id="Data-Range-1"><a href="#Data-Range-1" class="headerlink" title="Data Range"></a>Data Range</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据占比</th>
<th style="text-align:center">数据范围或数据特征</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">30%</td>
<td style="text-align:center">1&lt;=N&lt;=100，1&lt;=M&lt;=500</td>
</tr>
<tr>
<td style="text-align:center">60%</td>
<td style="text-align:center">1&lt;=N&lt;=100，1&lt;=M&lt;=500</td>
</tr>
<tr>
<td style="text-align:center">100%</td>
<td style="text-align:center">1&lt;=N&lt;=5000，1&lt;=M&lt;=30000</td>
</tr>
<tr>
<td style="text-align:center"><strong>20%</strong></td>
<td style="text-align:center">1&lt;=N&lt;=3000的链</td>
</tr>
<tr>
<td style="text-align:center"><strong>100%</strong></td>
<td style="text-align:center">1&lt;=u,v&lt;=N，1&lt;=k，w[i]，s[i]&lt;=200</td>
</tr>
</tbody>
</table>
</div>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>由于题目中的“停留”这一限制，导致直接对原图使用 SPFA 或者在过程中动态判断当前两个洞的黑白状态会遇到困难（往自己这个点加边会使 SPFA 死循环或者求出错误答案）</p>
<p><strong>那么我们就把一个洞黑白两个状态分别用两个点记录，记 i 为 i 号点的白洞状态，i+maxn 为 i 号点的黑洞状态，那么对于“停留”这个选择，只需将白点和黑点互相连边即可，然后照常 SPFA，就能得出正确答案</strong></p>
<h2 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 30000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">vector&lt;pr&gt; g[maxn*<span class="number">2</span>+<span class="number">1</span>]; <span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dist[maxn*<span class="number">2</span>+<span class="number">1</span>],dt; <span class="type">bool</span> vis[maxn*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s[maxn*<span class="number">2</span>+<span class="number">1</span>],stat[maxn*<span class="number">2</span>+<span class="number">1</span>],qua[maxn*<span class="number">2</span>+<span class="number">1</span>]; <span class="comment">// qua 质量  </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> stu,<span class="type">int</span> stv,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stu==<span class="number">1</span>) u+=maxn;</span><br><span class="line">	<span class="keyword">if</span>(stv==<span class="number">1</span>) v+=maxn;</span><br><span class="line">	g[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ejump</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(stat[u]==stat[v])&#123;</span><br><span class="line">		g[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v+maxn,w)); </span><br><span class="line">		g[u+maxn].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,w));</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		g[u+maxn].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v+maxn,w+<span class="built_in">abs</span>(qua[u]-qua[v])));</span><br><span class="line">		g[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,<span class="built_in">max</span>(w-<span class="built_in">abs</span>(qua[u]-qua[v]),<span class="number">0</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">buildG</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 用 i+maxn 表示 i 点黑洞  </span></span><br><span class="line">	<span class="comment">// 用 i 表示 i 点白洞 </span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;stat[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;qua[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class="line">	<span class="comment">// 到其它点  </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<span class="built_in">Ejump</span>(x,y,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 停留 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">Eadd</span>(i,i,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>); <span class="comment">// 白洞停留 1 时间  </span></span><br><span class="line">		<span class="built_in">Eadd</span>(i,i,<span class="number">1</span>,<span class="number">0</span>,s[i]); <span class="comment">// 黑洞停留 1 时间 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shortest</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">127</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> qhead;</span><br><span class="line">	<span class="keyword">if</span>(stat[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">		dist[<span class="number">1</span>]=<span class="number">0</span>; vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		dist[<span class="number">1</span>+maxn]=<span class="number">0</span>; vis[<span class="number">1</span>+maxn]=<span class="literal">true</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="number">1</span>+maxn);</span><br><span class="line">	&#125;vector&lt;pr&gt;::iterator iter; </span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> u qhead</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> v iter-&gt;first</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> w iter-&gt;second</span></span><br><span class="line">		qhead=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[u]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(iter=g[u].<span class="built_in">begin</span>();iter!=g[u].<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[v]&gt;dist[u]+w)&#123;</span><br><span class="line">				dist[v]=dist[u]+w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;vis[v]=<span class="literal">true</span>;q.<span class="built_in">push</span>(v);&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="keyword">undef</span> u</span></span><br><span class="line">		<span class="meta">#<span class="keyword">undef</span> v</span></span><br><span class="line">		<span class="meta">#<span class="keyword">undef</span> w</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;holes.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;holes.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">buildG</span>();<span class="built_in">shortest</span>();</span><br><span class="line">	cout&lt;&lt;<span class="built_in">min</span>(dist[n],dist[n+maxn]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路径</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 线段树 | 可持久化线  段树:学习笔记</title>
    <url>/2019/05/03/2019-05-03-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h2><p>可持久化线段树是一种<strong>特殊的线段树</strong>，不同于普通的线段树，他能够维护一些经过修改之后的不同版本的树，并且能在当前树的某个历史版本上进行操作，包括：</p>
<ul>
<li><p>单点查询</p>
</li>
<li><p>单点更新</p>
</li>
<li><p>区间查询</p>
</li>
<li><p>区间更新</p>
</li>
<li><p>创建新的版本</p>
</li>
</ul>
<p>维护不同版本的树，如采用朴素的线段树建新树，时间和空间都会超出限制，但是利用当前版本的线段树和以前版本的线段树的共同结点，我们可以节省很多重复的结点，对旧版本的树进行改造，就能遍历到新的树</p>
<h3 id="Code-可持久化线段树"><a href="#Code-可持久化线段树" class="headerlink" title="Code(可持久化线段树)"></a>Code(可持久化线段树)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> lc,rc,sumv;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc(x) T[x].lc <span class="comment">// x 的左儿子</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc(x) T[x].rc <span class="comment">// x 的右儿子</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s(x) T[x].sumv <span class="comment">// x 的值</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> pushup(x) (T[x].sumv=T[T[x].lc].sumv+T[T[x].rc].sumv) <span class="comment">// 上传 </span></span></span><br><span class="line">&#125;T[MAXN];</span><br></pre></td></tr></table></figure>
<h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><p>可持久化线段树建树和线段树建树没有多大区别，但是为了后面操作的方便，我们不用以前的线段树表示方式（即 $K&lt;&lt;1$ 表示 $K$ 的左儿子，$K&lt;&lt;1+1$ 表示 $K$ 的右儿子），而用 $LC(K)=K+1$ 和 $RC(K)$ 来表示</p>
<h3 id="Code-集合线段树"><a href="#Code-集合线段树" class="headerlink" title="Code(集合线段树)"></a>Code(集合线段树)</h3><p>构建一颗空的集合线段树：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> now=++newp;</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span> now;</span><br><span class="line">	<span class="built_in">lc</span>(now)=<span class="built_in">build</span>(L,mid);</span><br><span class="line">	<span class="built_in">rc</span>(now)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">	<span class="keyword">return</span> now; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Code-普通线段树"><a href="#Code-普通线段树" class="headerlink" title="Code(普通线段树)"></a>Code(普通线段树)</h3><p>利用给出的 $w$  数组，构建一颗普通线段树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> now=++newp;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		<span class="built_in">s</span>(now)=w[L];</span><br><span class="line">		<span class="keyword">return</span> now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">lc</span>(now)=<span class="built_in">build</span>(L,mid);</span><br><span class="line">	<span class="built_in">rc</span>(now)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">	<span class="keyword">return</span> now; </span><br></pre></td></tr></table></figure>
<h2 id="更新（创建新的版本链）"><a href="#更新（创建新的版本链）" class="headerlink" title="更新（创建新的版本链）"></a>更新（创建新的版本链）</h2><p>在更新的同时，创建额外的结点</p>
<p>对于非叶子结点的额外结点，与当前节点共享一个儿子（左儿子或者右儿子），他的另一个儿子是递归创建的新结点，他的权值是经过更新之后的当前结点的权值（当前结点权值保持不动）</p>
<p>对于叶子节点的额外结点，没有左右儿子，他的权值是当前结点的更新后权值</p>
<p><strong>这里用集合线段树来举一个例子：</strong></p>
<blockquote>
<p><strong>对序列：$2\;5\;1\;8\;3\;5\;4\;7$ 创建一颗集合线段树：</strong></p>
<p><strong>树中每个结点存了此结点表示的 $[L，R]$ 区间内出现的数字的个数</strong></p>
</blockquote>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">d1(&quot;[1,8]:8&quot;);d2(&quot;[1,4]:4&quot;);d3(&quot;[1,2]:2&quot;);d4(&quot;[1,1]:1&quot;);</span><br><span class="line">d5(&quot;[2,2]:1&quot;);d6(&quot;[3,4]:2&quot;);d7(&quot;[3,3]:1&quot;);d8(&quot;[4,4]:1&quot;);</span><br><span class="line">d9(&quot;[5,8]:4&quot;);d10(&quot;[5,6]:2&quot;);d11(&quot;[5,5]:2&quot;);d12(&quot;[6,6]&quot;)</span><br><span class="line">d13(&quot;[7,8]:2&quot;);d14(&quot;[7,7]:1&quot;);d15(&quot;[8,8]:1&quot;)</span><br><span class="line">d1---d2;d2---d3;d3---d4;d3---d5;d2---d6;</span><br><span class="line">d6---d7;d6---d8;d1---d9;d9---d10;d10---d11;</span><br><span class="line">d10---d12;d9---d13;d13---d14;d13---d15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>操作：将数列中的 8 删去，以此创建新的版本 1 ，原来的作为版本 0 不动</strong></p>
<p><strong>那么操作之后的图：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">d1(&quot;[1,8]:8&quot;);d2(&quot;[1,4]:4&quot;);d3(&quot;[1,2]:2&quot;);d4(&quot;[1,1]:1&quot;);</span><br><span class="line">d5(&quot;[2,2]:1&quot;);d6(&quot;[3,4]:2&quot;);d7(&quot;[3,3]:1&quot;);d8(&quot;[4,4]:1&quot;);</span><br><span class="line">d9(&quot;[5,8]:4&quot;);d10(&quot;[5,6]:2&quot;);d11(&quot;[5,5]:2&quot;);d12(&quot;[6,6]&quot;)</span><br><span class="line">d13(&quot;[7,8]:2&quot;);d14(&quot;[7,7]:1&quot;);d15(&quot;[8,8]:1&quot;);</span><br><span class="line">d16(&quot;[8,8]:0&quot;);d17(&quot;[7,8]:1&quot;);d18(&quot;[5,8]:3&quot;);d19(&quot;[1,8]:7&quot;);</span><br><span class="line">d1---d2;d2---d3;d3---d4;d3---d5;d2---d6;</span><br><span class="line">d6---d7;d6---d8;d1---d9;d9---d10;d10---d11;</span><br><span class="line">d10---d12;d9---d13;d13---d14;d13---d15;</span><br><span class="line">d19===d2;d19===d18;d18===d10;d18===d17;</span><br><span class="line">d17===d14;d17===d16</span><br></pre></td></tr></table></figure>
<p>此时我们沿着细线访问就是版本0，沿着粗线访问就是版本1</p>
<p>整个操作只是新建了右边一串的四个点（注意到根结点也被新建了）， 比暴力建新树要节省了巨多的空间，用 $Ver[i]$  表示版本 $i$ 的根结点是哪个就行了</p>
<h3 id="Code-更新结点-复制版本：集合线段树"><a href="#Code-更新结点-复制版本：集合线段树" class="headerlink" title="Code(更新结点+复制版本：集合线段树)"></a>Code(更新结点+复制版本：集合线段树)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> _v)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 更新结点 + 复制版本  </span></span><br><span class="line">	<span class="built_in">s</span>(k)+=_v;</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span>; <span class="comment">// 叶子节点不用复制 ??  </span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)&#123;</span><br><span class="line">		T[++newp]=T[<span class="built_in">lc</span>(k)]; <span class="comment">// 这里用结构体直接复制一份 k 的左子节点  </span></span><br><span class="line">		<span class="built_in">lc</span>(k)=newp;</span><br><span class="line">		<span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,_v);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T[++newp]=T[<span class="built_in">rc</span>(k)];</span><br><span class="line">	<span class="built_in">rc</span>(k)=newp;</span><br><span class="line">	<span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,_v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Code-更新结点-复制版本：普通线段树"><a href="#Code-更新结点-复制版本：普通线段树" class="headerlink" title="Code(更新结点+复制版本：普通线段树)"></a>Code(更新结点+复制版本：普通线段树)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 修改 x 位置 为 d </span></span><br><span class="line">	<span class="comment">// 为了新建的版本节点，需要返回 int  </span></span><br><span class="line">	<span class="type">int</span> now=++newp;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		<span class="built_in">s</span>(now)=d;</span><br><span class="line">		<span class="keyword">return</span> now;</span><br><span class="line">	&#125;</span><br><span class="line">	T[now]=T[k]; <span class="built_in">s</span>(now)=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">lc</span>(now)=<span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,d);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">rc</span>(now)=<span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,d);</span><br><span class="line">	<span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="以某个版本为基础进行修改"><a href="#以某个版本为基础进行修改" class="headerlink" title="以某个版本为基础进行修改"></a>以某个版本为基础进行修改</h2><p>这种操作通常都伴有要你新建一个版本，这个版本存的是某一个历史版本为基础，修改了上面的某个值之后的结果（历史版本不动）</p>
<p>注意到上面我们的 $updata$ 是 $int$ 类型，那么他返回的其实就是操作完成后的新的根结点的值，因此，在主函数里直接把新的版本根结点赋值即可</p>
<h3 id="Code-版本修改-创建"><a href="#Code-版本修改-创建" class="headerlink" title="Code(版本修改+创建)"></a>Code(版本修改+创建)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;version,&amp;k,&amp;d)</span><br><span class="line">    <span class="comment">// 表示把 version 版本的 k 位置改成 d，并创建新的版本</span></span><br><span class="line">    Ver[++Ver[<span class="number">0</span>]]=<span class="built_in">updata</span>(Ver[version],<span class="number">1</span>,n,k,d);    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问历史版本的某一个结点值"><a href="#访问历史版本的某一个结点值" class="headerlink" title="访问历史版本的某一个结点值"></a>访问历史版本的某一个结点值</h2><p>由于之前更新的时候我们已经把版本信息存下来了（在 $Ver$ 数组里面）</p>
<p>于是现在直接从对应的版本根结点开始遍历即可</p>
<h3 id="Code-访问历史版本"><a href="#Code-访问历史版本" class="headerlink" title="Code(访问历史版本)"></a>Code(访问历史版本)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 查询 位置 x 上的值 </span></span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span> <span class="built_in">s</span>(k); <span class="comment">// s(k) 的意义见可持久化线段树定义 </span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">lc</span>(k),L,mid,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;Version,&amp;k); <span class="comment">// 表示查询 Version 版本的第 k 位置 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">query</span>(Ver[Version],<span class="number">1</span>,n,k)) <span class="comment">// 从 Ver[Version] 的根结点进树</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="【应用】求区间第K小"><a href="#【应用】求区间第K小" class="headerlink" title="【应用】求区间第K小"></a>【应用】求区间第K小</h2><p>我们在用<strong>集合线段树</strong>求解区间第K大的问题时，注意到集合线段树总有左子树表示的数字总比右子树表示的数字小，所以将区间内的数字统计出来之后，我们对于某个结点的左右子树判断，若左子树包含的数字个数大于等于K，则第K小的树一定在左子树，否则就去右子树找第 $K-sumv(lchi)$ 小的数，可以递归实现</p>
<p>对于区间的第K小，基本思路和上述一致，只不过用到类似区间前缀和相减的知识，即：一个数在 $[L_1，R_1]$ 中出现的次数，等于他在 $[L_1，R_2]$ 中出现的次数加上 $[L_1，R_3]$ 中出现的次数（$R_1=R_2+R_3$），若序列有 $n$ 个元素，就建 $n$ 个版本的线段树，分别保存的是序列只有 $1，2，3……n$ 个元素时候的集合信息，需要区间相减的时候，我们分别从两个版本的根结点进树，遍历时动态相减就能得到目标区间内数字出现的个数</p>
<h3 id="Code-第K小"><a href="#Code-第K小" class="headerlink" title="Code(第K小)"></a>Code(第K小)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> r1,<span class="type">int</span> r2,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 查询区间内第 k 大的数  </span></span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span> w[vis[L]];</span><br><span class="line">	<span class="type">int</span> chi=<span class="built_in">s</span>(<span class="built_in">lc</span>(r2))-<span class="built_in">s</span>(<span class="built_in">lc</span>(r1));</span><br><span class="line">	<span class="keyword">if</span>(chi&gt;=k) <span class="keyword">return</span> <span class="built_in">kth</span>(L,mid,<span class="built_in">lc</span>(r1),<span class="built_in">lc</span>(r2),k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(mid+<span class="number">1</span>,R,<span class="built_in">rc</span>(r1),<span class="built_in">rc</span>(r2),k-chi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k); <span class="comment">// 查询 [l,r] 内第k小的数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">kth</span>(<span class="number">1</span>,n,Ver[l<span class="number">-1</span>],Ver[r],k));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="【应用】统计区间内的数字个数"><a href="#【应用】统计区间内的数字个数" class="headerlink" title="【应用】统计区间内的数字个数"></a>【应用】统计区间内的数字个数</h2><p>设数列 ${a_n}$，需要统计出 $a_x$ 到 $a_y$ 间的所有数字在区间 $[L，R]$ 内的个数</p>
<p>和上面的区间减法思路本质一样，模板是线段树区间查询</p>
<h3 id="Code-统计数字个数"><a href="#Code-统计数字个数" class="headerlink" title="Code(统计数字个数)"></a>Code(统计数字个数)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cens</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> Rx,<span class="type">int</span> Ry)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 统计 [x,y] 中的数在 [Rx,Ry] 中的个数 </span></span><br><span class="line">	<span class="comment">// s(x) = tree[x].sumv </span></span><br><span class="line">	<span class="comment">// lc(x) = tree[x].lchild</span></span><br><span class="line">	<span class="comment">// rc(x) = tree[x].rchild </span></span><br><span class="line">	<span class="keyword">if</span>(L&gt;Ry || R&lt;Rx) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(Rx&lt;=L &amp;&amp; Ry&gt;=R) <span class="keyword">return</span> <span class="built_in">s</span>(y)-<span class="built_in">s</span>(x);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cens</span>(L,mid,<span class="built_in">lc</span>(x),<span class="built_in">lc</span>(y),Rx,Ry)+<span class="built_in">cens</span>(mid+<span class="number">1</span>,R,<span class="built_in">rc</span>(x),<span class="built_in">rc</span>(y),Rx,Ry); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构| 图论 | 线段树 | 树状  数组| LCA | 最小生成树 | 20190504 青年节  考试 总结订正</title>
    <url>/2019/05/07/2019-05-07-%E9%9D%92%E5%B9%B4%E8%8A%82%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="T2-货车运输"><a href="#T2-货车运输" class="headerlink" title="T2.货车运输"></a>T2.货车运输</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A 国有 n 座城市，编号从 1 到 n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行有两个用一个空格隔开的整数 n，m，表示 A 国有 n 座城市和 m 条道路。接下来 m 行每行 3 个整数 x、y、z，每两个整数之间用一个空格隔开，表示从x 号城市到 y 号城市有一条限重为 z 的道路。注意：x 不等于 y，两座城市之间可能有多条道路。接下来一行有一个整数 q，表示有 q 辆货车需要运货。接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意：x 不等于 y</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">3 1 1</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 10,000，0 &lt; q &lt; 1,000；</p>
<p>对于 60%的数据，0 &lt; n &lt; 1,000，0 &lt; m &lt; 50,000，0 &lt; q &lt; 1,000；</p>
<p>对于 100%的数据，0 &lt; n &lt; 10,000，0 &lt; m &lt; 50,000，0 &lt; q &lt; 30,000，0 ≤ z ≤ 100000</p>
<blockquote>
<p><strong>输入样例图示：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--4---2</span><br><span class="line">2--3---3</span><br><span class="line">3--1---1</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先注意到题目中并不是给出一颗树，意味着两点之间可能有多条路径，那么载重最大的那条路经应该保留，其余路径可以去掉，<strong>由此我们可以对原图求一个最大生成树（森林）</strong></p>
<p>对于样例，求出最大生成树（森林）后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--4---2;2--3---3</span><br></pre></td></tr></table></figure>
<p>然后在这个树上求 $LCA$ 即可，这里要增加一个数组 $g[i][j]$ 表示 $i$ 点与他向上跳 $2^j$ 步的祖先之间的树链上的权值最小的树边，显然 $g[i][j]=min(g[i][j-1]，g[f[i][j-1]][j-1])$，$f[i][j]$ 即 $i$ 点向上跳 $2^j$ 步达到的祖先结点</p>
<p><strong>求解 $LCA$ 时，要将跳跃路径上的边权最小值跟最后的 $g[x][0]$ 和 $g[y][0]$ 再进行比较</strong></p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 500001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxlg 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> to[maxm*<span class="number">2</span>],nxt[maxm*<span class="number">2</span>],w[maxm*<span class="number">2</span>],newp;</span><br><span class="line"><span class="type">int</span> head[maxn],n,m,q,f[maxn],dep[maxn];</span><br><span class="line"><span class="type">int</span> fa[maxn][maxlg],ga[maxn][maxlg],lgN;</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">// fa[i][j] i向上 2^j 步的祖先 </span></span><br><span class="line"><span class="comment">// ga[i][j] i与 f[i][j] 中间的最短边  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> S,E,W;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> W&gt;obj.W;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;g[maxm];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> we)</span></span>&#123;</span><br><span class="line">    nxt[++newp]=head[x]; to[newp]=y;</span><br><span class="line">    w[newp]=we; head[x]=newp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">max_kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构建最大生成树  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(g+<span class="number">1</span>,g+m+<span class="number">1</span>); <span class="type">int</span> cho=<span class="number">0</span>,fx,fy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cho==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        fx=<span class="built_in">Sfind</span>(g[i].S);fy=<span class="built_in">Sfind</span>(g[i].E);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">            f[fx]=fy; <span class="comment">// UNION </span></span><br><span class="line">            cho++; <span class="built_in">Eadd</span>(g[i].S,g[i].E,g[i].W);</span><br><span class="line">            <span class="built_in">Eadd</span>(g[i].E,g[i].S,g[i].W);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> qhead;</span><br><span class="line">    dep[s]=<span class="number">1</span>; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxlg;i++) ga[s][i]=INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        qhead=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>(); vis[qhead]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[qhead];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dep[to[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            dep[to[i]]=dep[qhead]+<span class="number">1</span>;</span><br><span class="line">            fa[to[i]][<span class="number">0</span>]=qhead;ga[to[i]][<span class="number">0</span>]=w[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lgN;j++)&#123;</span><br><span class="line">                fa[to[i]][j]=fa[fa[to[i]][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">                ga[to[i]][j]=<span class="built_in">min</span>(ga[to[i]][j<span class="number">-1</span>],ga[fa[to[i]][j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y); <span class="type">int</span> minans=INF;</span><br><span class="line">    <span class="type">int</span> jh=(<span class="type">int</span>)(<span class="built_in">log</span>(dep[x])/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=jh;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[x][i]]&gt;=dep[y])&#123;</span><br><span class="line">            minans=<span class="built_in">min</span>(minans,ga[x][i]);</span><br><span class="line">            x=fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> minans; jh=(<span class="type">int</span>)(<span class="built_in">log</span>(dep[x])/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=jh;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            minans=<span class="built_in">min</span>(<span class="built_in">min</span>(ga[x][i],ga[y][i]),minans);</span><br><span class="line">            x=fa[x][i]; y=fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(minans,<span class="built_in">min</span>(ga[x][<span class="number">0</span>],ga[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;t2.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;t2.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m); lgN=(<span class="type">int</span>)(<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">fcin</span>(g[i].S);<span class="built_in">fcin</span>(g[i].E);</span><br><span class="line">        <span class="built_in">fcin</span>(g[i].W);</span><br><span class="line">    &#125; <span class="built_in">max_kruskal</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) <span class="built_in">bfs</span>(i); </span><br><span class="line">    <span class="built_in">fcin</span>(q); <span class="type">int</span> Qx,Qy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">fcin</span>(Qx);<span class="built_in">fcin</span>(Qy);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Sfind</span>(Qx)!=<span class="built_in">Sfind</span>(Qy))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(Qx,Qy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="T3-HH的项链"><a href="#T3-HH的项链" class="headerlink" title="T3.HH的项链"></a>T3.HH的项链</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答。。。因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>第一行：一个整数 N，表示项链的长度。第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为 0 到 1000000 之间的整数）。第三行：一个整数 M，表示 HH 询问的个数。接下来 M 行：每行两个整数，L 和 R（1 ≤ L ≤ R ≤ N），表示询问的区间。N ≤ 50000，M ≤ 200000。</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>M 行，每行一个整数，依次表示询问对应的答案。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 3 5</span><br><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">2 6</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>None</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>采用离线算法，先将所有询问按照左端点升序排序，然后记录每个颜色第一次出现的位置 $first[i]$ 和当前位置后的下一次出现的位置 $next[i]$，可以在 $O(n)$ 内处理出来</p>
<p><strong>对于每个区间，每种颜色仅当它第一次出现时计数，然后当询问的左端点扫过了这个颜色时，它就不会再被统计了，把下一次他出现的位置加入统计，把它移除即可</strong></p>
<p>由于涉及了单点修改和区间求和，所以用树状数组优化时间复杂度。</p>
<h2 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正解： 树状数组  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxQ 500001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxV 1000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> L,R; <span class="type">int</span> id;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> R&lt;obj.R;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;ask[maxQ]; <span class="type">int</span> T[maxQ],ans[maxQ],a[maxQ];</span><br><span class="line"><span class="type">int</span> vis[maxV],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> Pos,<span class="type">int</span> Val)</span></span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=Pos;i&lt;=n;i+=i&amp;(-i))T[i]+=Val; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> Pos)</span></span>&#123; <span class="type">int</span> Res=<span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> i=Pos;i;i-=i&amp;(-i))Res+=T[i]; <span class="keyword">return</span> Res; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t3.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;t3.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(a[i]);</span><br><span class="line">	<span class="built_in">fcin</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(ask[i].L);<span class="built_in">fcin</span>(ask[i].R);</span><br><span class="line">		ask[i].id=i;</span><br><span class="line">	&#125; <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(ask+<span class="number">1</span>,ask+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[a[i]]) <span class="built_in">updata</span>(vis[a[i]],<span class="number">-1</span>);</span><br><span class="line">		vis[a[i]]=i;<span class="built_in">updata</span>(i,<span class="number">1</span>); </span><br><span class="line">		<span class="keyword">while</span>(ask[now].R==i)&#123;</span><br><span class="line">			ans[ask[now].id]=<span class="built_in">sum</span>(ask[now].R)-<span class="built_in">sum</span>(ask[now].L<span class="number">-1</span>);</span><br><span class="line">			now++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h1 id="T4-Rmq-Problem-mex"><a href="#T4-Rmq-Problem-mex" class="headerlink" title="T4.Rmq Problem / mex"></a>T4.Rmq Problem / mex</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p><img src="https://www.lydsy.com/JudgeOnline/upload/201401/1.jpg" alt="Description"></p>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p><img src="https://www.lydsy.com/JudgeOnline/upload/201401/2.jpg" alt="input"></p>
<h2 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h2><p><img src="https://www.lydsy.com/JudgeOnline/upload/201401/3.jpg" alt="output"></p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5</span><br><span class="line">0 2 1 0 1 3 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">3 6</span><br><span class="line">2 7</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h2><p><img src="https://www.lydsy.com/JudgeOnline/upload/201401/6.jpg" alt="hint"></p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>采用离线算法，先将所有询问按照左端点升序排序，用类似前缀和的思想可以求出 $f[i]$ 表示 $[1,i]$ 的 $mex$ 值，和T3一样，用 $next[i]$ 表示 $a[i]$ 下一次出现的位置</p>
<p>现在假设有两个询问 $[L，R]$ 和 $[L+1，R]$，<strong>如果 $R\geq next[L]$ 那么两个询问的 $mex$ 值相同</strong></p>
<p><strong>如果 $R<next[L]$ ，那么在 $[L+1，R]$ 区间内将所有的 $f[i]>a[L]，i\in[L+1，R]$ 改为 $a[L]$ ，然后单点查询 $f[L]$ 即可</strong></p>
<p>涉及到区间修改和单点查询，用线段树实现</p>
<h2 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> Le,Ri,id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Le&lt;obj.Le;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ask[maxn]; <span class="type">int</span> ans[maxn],n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tnode</span>&#123;</span><br><span class="line">    <span class="type">int</span> LC,RC,V;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> val(x) T[x].V</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">&#125;T[maxn*<span class="number">4</span>]; <span class="comment">// 线段树求最小  </span></span><br><span class="line"><span class="type">int</span> a[maxn],newp;</span><br><span class="line"><span class="type">int</span> f[maxn],nxt[maxn],las[maxn];</span><br><span class="line"><span class="comment">// f[n] [1,n]的 mex 值 nxt[n] 出现 a[n] 的下一个位置  </span></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">val</span>(k)==INF) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">val</span>(<span class="built_in">lc</span>(k))=<span class="built_in">min</span>(<span class="built_in">val</span>(<span class="built_in">lc</span>(k)),<span class="built_in">val</span>(k));</span><br><span class="line">    <span class="built_in">val</span>(<span class="built_in">rc</span>(k))=<span class="built_in">min</span>(<span class="built_in">val</span>(<span class="built_in">rc</span>(k)),<span class="built_in">val</span>(k));</span><br><span class="line">    <span class="built_in">val</span>(k)=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=++newp;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        <span class="built_in">val</span>(now)=f[L];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125; <span class="built_in">val</span>(now)=INF;</span><br><span class="line">    <span class="built_in">lc</span>(now)=<span class="built_in">build</span>(L,mid);</span><br><span class="line">    <span class="built_in">rc</span>(now)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> _v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线段树 区间修改  </span></span><br><span class="line">    <span class="keyword">if</span>(L==x &amp;&amp; R==y)&#123;</span><br><span class="line">        <span class="built_in">val</span>(k)=<span class="built_in">min</span>(<span class="built_in">val</span>(k),_v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(mid&gt;=y) <span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,y,_v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=x) <span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y,_v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,mid,_v);</span><br><span class="line">        <span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,mid+<span class="number">1</span>,y,_v);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线段树单点查询  </span></span><br><span class="line">    <span class="keyword">if</span>(L==R) <span class="keyword">return</span> <span class="built_in">val</span>(k);</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">res</span>(<span class="built_in">lc</span>(k),L,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">res</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;t4.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;t4.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(q); <span class="type">int</span> nowmex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; <span class="comment">// 求解 f[i]  </span></span><br><span class="line">        vis[a[i]]=<span class="literal">true</span>; <span class="keyword">while</span>(vis[nowmex]) nowmex++;</span><br><span class="line">        f[i]=nowmex;</span><br><span class="line">    &#125; <span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123; <span class="comment">// nxt[i] 需要倒过来求解  </span></span><br><span class="line">        nxt[i]=las[a[i]]; las[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">fcin</span>(ask[i].Le),<span class="built_in">fcin</span>(ask[i].Ri),ask[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(ask+<span class="number">1</span>,ask+q+<span class="number">1</span>); <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;ask[i].Le)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nxt[now]) nxt[now]=n+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,now,nxt[now]<span class="number">-1</span>,a[now]);</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ask[i].id]=<span class="built_in">res</span>(<span class="number">1</span>,<span class="number">1</span>,n,ask[i].Ri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | AHOI2009 中国象棋</title>
    <url>/2019/06/02/2019-06-02-zgxq/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好<br>有一个棋子。你也来和小可可一起锻炼一下思维吧！</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>一行包含两个整数N，M，之间由一个空格隔开。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>样例说明</p>
<p>除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有2×2×2-1=7种方案。</p>
<p>数据范围</p>
<p>100%的数据中N和M均不超过100</p>
<p>50%的数据中N和M至少有一个数不超过8</p>
<p>30%的数据中N和M均不超过6</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先想到，每一行最多只能塞进 2 门炮，否则就会出现隔山打牛的情况了，<strong>那么每一行就只有 2 种合法状态，即放 1 门炮和放 2 门炮</strong></p>
<p><strong>设 $f[i][j][k]$ 表示到了第 $i$ 行，有 $j$ 列只有一门炮，还有 $k$ 列有两门炮的方案数</strong>，显然 $k\leq m-j$</p>
<p>那么剩下没有放炮的列数就是：$m-j-k$，接下来可以有 3 种选择：</p>
<ol>
<li><p>在第 $i$ 行不放炮，此时状态继承了上一行的状态，即 $f[i][j][k]=f[i-1][j][k]$</p>
</li>
<li><p>在第 $i$ 行放一门炮，又有两种选择（不能放在有 2 门炮的列上面）</p>
<ul>
<li>放在只有一门炮的一列，会使它变成有 2 门炮，因此 $k$ 的状态需要从 $k-1$ 转移过来，而只有一门炮的列数会减少 1，而变成当前的 $j$ ，所以 $j$ 的状态从 $j+1$ 转移过来，既然是从 $j+1$ 转移过来，那么可以在这 $j+1$ 列上放炮，方案数乘上 $j+1$，即：$f[i][j][k]+=f[i-1][j+1][k-1]\times (j+1)$</li>
<li>放在没有炮的一列，会使它变成有 1 门炮，因此 $j$ 的状态要从 $j-1$ 转移，此时 $k$ 状态不变，又因为当前没有放炮的列数是 $m-j-k$，注意空的列数是相对于 $j=j-1$ 的状态而言的，所以实际空的列数为 $m-(j-1)-k$，即：$f[i][j][k]+=f[i-1][j-1][k]\times (m-(j-1)-k)$</li>
</ul>
</li>
<li><p>在第 $i$ 行放两门炮，有三种情况需要讨论：</p>
<ul>
<li>两门炮都放在没放炮的那一列，和上面的的思路类似，但是注意这 2 门炮的排列组合，可以得出：$f[i][j]+=f[i-1][j-2][k]\times C^2_{m-(j-2)-k}$</li>
<li>两门炮都放在放了 1 门炮的那一列，也是排列组合，可以得出：$f[i][j]+=f[i-1][j+2][k-2]\times C^2_{j+2}$</li>
<li>一门放在没放炮的一列，一门放在放了炮的一列，此时综合情况 2 的两种子情况可以得出：$f[i][j][k]+=f[i-1][j][k-1]\times j \times (m-(k-1)-j)$</li>
</ul>
</li>
</ol>
<p><strong>边界为 $f[0][0][0]=1$</strong>，这便是 省选 / NOI- 的 DP 题难度吧，题面不长但是很烧脑子。。。</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 108</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n,m; <span class="type">const</span> <span class="type">int</span> mod=<span class="number">9999973</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((x*(x<span class="number">-1</span>))/<span class="number">2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)	</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=(m-j);k++)&#123;</span><br><span class="line">				f[i][j][k]=f[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=<span class="number">1</span>)(f[i][j][k]+=f[i<span class="number">-1</span>][j+<span class="number">1</span>][k<span class="number">-1</span>]*(j+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">1</span>)(f[i][j][k]+=f[i<span class="number">-1</span>][j<span class="number">-1</span>][k]*(m-j-k+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=<span class="number">2</span>)(f[i][j][k]+=f[i<span class="number">-1</span>][j+<span class="number">2</span>][k<span class="number">-2</span>]*(((j+<span class="number">2</span>)*(j+<span class="number">1</span>))/<span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=<span class="number">1</span>)(f[i][j][k]+=f[i<span class="number">-1</span>][j][k<span class="number">-1</span>]*j*(m-j-k+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)(f[i][j][k]+=f[i<span class="number">-1</span>][j<span class="number">-2</span>][k]*<span class="built_in">c</span>(m-j-k+<span class="number">2</span>));</span><br><span class="line">                f[i][j][k]%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			ans+=f[n][i][j],ans%=mod;</span><br><span class="line">	<span class="keyword">return</span> (ans+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">dp</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 | 平衡树 | FHQTreap 函数式  平衡树:学习笔记</title>
    <url>/2019/05/30/2019-05-30-FHQTreap%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="FHQTreap：函数式平衡树"><a href="#FHQTreap：函数式平衡树" class="headerlink" title="FHQTreap：函数式平衡树"></a>FHQTreap：函数式平衡树</h2><p><strong>FHQTreap</strong> 是一种特殊的平衡树<em>（  Invented By FHQ ）</em>，不同于普通平衡树 <strong>Splay</strong> 的是，它无需旋转操作(Rotate)就可以达到 <strong>Splay</strong> 的速度，而是用两个基本操作实现序列操作：<strong>Merge</strong> 和 <strong>Split</strong></p>
<p>从名字 <strong>Split</strong> 就可以发现，<strong>它的核心思想是将一颗树分裂，使之两个部分满足堆序，在上面操作之后再合并为一棵树</strong></p>
<p><strong>FHQTreap</strong> 的本质还是 <strong>BST</strong> ，所以区间操作和 <strong>Splay</strong> 没有多大区别<del>（经过优化后好像还比<strong>Splay</strong>跑得快？）</del></p>
<h2 id="基础操作：Split-分裂"><a href="#基础操作：Split-分裂" class="headerlink" title="基础操作：Split (分裂)"></a>基础操作：Split (分裂)</h2><p><strong>Split 分裂</strong> 是按照某种规定将当前的树分成两棵子树的操作（当前的树也有可能是分裂之后的树，因此操作具有递归性），分裂操作可以按照给定权值分，也可以按照子树大小分</p>
<h3 id="按照权值分裂"><a href="#按照权值分裂" class="headerlink" title="按照权值分裂"></a>按照权值分裂</h3><p>将当前树分裂成权值均小于等于 X 的一棵树 A 和权值均大于 X 的一棵树 B</p>
<p>A，B 的意义为分裂后两棵树的根结点，需要实时更新，引用传参</p>
<p><strong>空树将会被拆分成 2 棵空树，即A=B=0（边界），然后：</strong></p>
<ol>
<li><p>如果正在考虑的点 K 权值比 X 大，说明 K 的右子树的权值均比 X 大，K 的右子树放到 B 中，同时走 K 的左子树，把左子树中所有权值大于 X 的点分到 B 中，剩下的点分到 A 中</p>
</li>
<li><p>如果正在考虑的点 K 权值比 X 小，说明 K 的左子树的权值均比 X 小，K 的左子树放到 A 中，同时走 K 的右子树，把右子树中所有权值小于 X 的点分到 A 中，剩下的点分到 B 中</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SplitVal</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tar,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123; <span class="comment">// 按权值分裂  </span></span><br><span class="line">		<span class="keyword">if</span>(!k)&#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(tar&gt;=<span class="built_in">val</span>(k))&#123;</span><br><span class="line">			x=k; <span class="built_in">SplitVal</span>(<span class="built_in">rc</span>(k),tar,<span class="built_in">rc</span>(k),y);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			y=k; <span class="built_in">SplitVal</span>(<span class="built_in">lc</span>(k),tar,x,<span class="built_in">lc</span>(k));</span><br><span class="line">		&#125; <span class="built_in">pushup</span>(k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按照排名分裂"><a href="#按照排名分裂" class="headerlink" title="按照排名分裂"></a>按照排名分裂</h3><p>基本思想和上面的 <strong>按照权值分裂</strong> 一致，判断条件从权值改为了子树的大小 <strong>Size(K)</strong></p>
<p>这里注意，如果要走当前点的右子树，目标大小应该减去它左子树大小加上他自身的 1 ，和 <strong>Kth​</strong> 的思想相似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SplitRnk</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tar,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123; <span class="comment">// 按排名分裂  </span></span><br><span class="line">		<span class="keyword">if</span>(!k)&#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(tar&lt;<span class="built_in">siz</span>(<span class="built_in">lc</span>(k)))&#123;</span><br><span class="line">			y=k; <span class="built_in">SplitRnk</span>(<span class="built_in">lc</span>(k),tar,x,<span class="built_in">lc</span>(k));</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			x=k; <span class="built_in">SplitRnk</span>(<span class="built_in">rc</span>(k),tar-<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))<span class="number">-1</span>,<span class="built_in">rc</span>(k),y);</span><br><span class="line">             <span class="comment">// 和 Kth 的思想相似 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pushup(K) 是更新 K 的子树大小，跟线段树的 pushup 相似</strong></p>
<h2 id="基础操作：Merge-合并"><a href="#基础操作：Merge-合并" class="headerlink" title="基础操作：Merge (合并)"></a>基础操作：Merge (合并)</h2><p><strong>Merge 合并</strong> 是把当前分开的两棵子树合并成一颗新的树，函数需要返回合并之后的根结点，合并时需要按照堆序，使得随机值较小的结点作为新树的根，假设合并前有两棵树 A，B，A 中的所有元素都小于B 中的元素，则：</p>
<ol>
<li>若 A 树的根成为了新树的根，则 B 树不会对 A 树的左子树造成影响，递归合并 A 的右子树和 B 即可</li>
<li>若 B 树的根成为了新树的根，则 A 树不会对 B 树的右子树造成影响，递归合并 B 的左子树和 A 即可</li>
</ol>
<p><strong>边界条件：若 A，B 中有空树，那么以不是空树的结点作为新树的根结点，此时无需再往下递归</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x|y;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">rnd</span>(x)&lt;<span class="built_in">rnd</span>(y))&#123;</span><br><span class="line">			<span class="built_in">rc</span>(x)=<span class="built_in">merge</span>(<span class="built_in">rc</span>(x),y);</span><br><span class="line">			<span class="built_in">pushup</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">lc</span>(y)=<span class="built_in">merge</span>(x,<span class="built_in">lc</span>(y));</span><br><span class="line">			<span class="built_in">pushup</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用时要用 <strong>root</strong> 来维护当前树的根结点</p>
<h2 id="区间操作：插入（Insert）"><a href="#区间操作：插入（Insert）" class="headerlink" title="区间操作：插入（Insert）"></a>区间操作：插入（Insert）</h2><p><strong>Insert 插入</strong> 是把新的值放入当前的 <strong>FHQTreap</strong> 中，依靠 <strong>Split</strong> 和 <strong>Merge</strong> 实现插入操作，我们只需要将当前的树按照插入的权值 <strong>X</strong> 分裂成两棵树，此时左边的 A 树权值均小于等于 <strong>X</strong>，右边的 B 树权值均大于 <strong>X</strong>，把 A，X，B 按顺序合并，插入就完成了，举个例子：</p>
<blockquote>
<p><strong>插入之前的树，需要插入的值为 5</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">4---2</span><br><span class="line">4---7</span><br><span class="line">7---6</span><br><span class="line">7---8</span><br><span class="line">2---1</span><br><span class="line">2---3</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>一次分裂之后：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">4---2</span><br><span class="line">7---6</span><br><span class="line">7---8</span><br><span class="line">2---1</span><br><span class="line">2---3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>合并之后：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">4---2</span><br><span class="line">4---7</span><br><span class="line">7---6</span><br><span class="line">6---5</span><br><span class="line">7---8</span><br><span class="line">2---1</span><br><span class="line">2---3</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">		<span class="built_in">SplitVal</span>(root,<span class="built_in">val</span>(N),X,Y);</span><br><span class="line">		rot=<span class="built_in">merge</span>(<span class="built_in">merge</span>(X,N),Y);</span><br><span class="line">    	<span class="comment">// root 是一个常量，代表树当前的根结点</span></span><br><span class="line">    	<span class="comment">// X,Y 随意取值，原因是他们会在 Split 时被引用赋值，只具有临时意义</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间操作：第-K-小（Kth）"><a href="#区间操作：第-K-小（Kth）" class="headerlink" title="区间操作：第 K 小（Kth）"></a>区间操作：第 K 小（Kth）</h2><p><strong>Kth 第 K 小</strong> 是寻找当前序列中升序排列后第 K 位的数，这里的第 K 小返回的是这个数的结点编号，与 <strong>Splay</strong> 以及 <strong>BST</strong> 的思路完全一致，就不多说了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tar)</span></span>&#123;</span><br><span class="line">    	<span class="comment">// k 代表当前走到了哪个结点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tar&lt;=<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))) k=<span class="built_in">lc</span>(k);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tar==<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="number">1</span>) <span class="keyword">return</span> k;</span><br><span class="line">				<span class="keyword">else</span> tar-=(<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="number">1</span>), k=<span class="built_in">rc</span>(k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间操作：排名问题（Rank）"><a href="#区间操作：排名问题（Rank）" class="headerlink" title="区间操作：排名问题（Rank）"></a>区间操作：排名问题（Rank）</h2><p><strong>Rank 排名问题</strong> 是指在区间中询问某一个数的升序排列后位置（确保存在），和询问排名为 K 的数（升序排列），通常与 <strong>Kth</strong> 合起来使用，思路同 <strong>BST</strong></p>
<h3 id="查询某数的排名"><a href="#查询某数的排名" class="headerlink" title="查询某数的排名"></a>查询某数的排名</h3><p>将原树按照给定数 N 的值减 1 分为 X，Y 两棵树，然后左边的 X 树的大小就是处在 N 前面的数的个数，加上 N 本身，就是他的排名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRnk</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得元素的排名  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N<span class="number">-1</span>,X,Y);</span><br><span class="line">			<span class="type">int</span> ret=<span class="built_in">siz</span>(X)+<span class="number">1</span>;</span><br><span class="line">			root=<span class="built_in">merge</span>(X,Y); <span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询第-K-名的数"><a href="#查询第-K-名的数" class="headerlink" title="查询第 K 名的数"></a>查询第 K 名的数</h3><p>直接 <strong>Kth</strong> 解决问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRanK</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得第 K 小的数 </span></span><br><span class="line">			<span class="type">int</span> ret=<span class="built_in">kth</span>(root,N);</span><br><span class="line">			<span class="keyword">if</span>(!ret) <span class="keyword">return</span> INF;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">val</span>(ret);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元素操作：前驱与后继（Precursor-amp-Successor）"><a href="#元素操作：前驱与后继（Precursor-amp-Successor）" class="headerlink" title="元素操作：前驱与后继（Precursor &amp; Successor）"></a>元素操作：前驱与后继（Precursor &amp; Successor）</h2><h3 id="元素的前驱（Precursor）"><a href="#元素的前驱（Precursor）" class="headerlink" title="元素的前驱（Precursor）"></a>元素的前驱（Precursor）</h3><p>元素的前驱定义为 <strong>小于等于此元素的元素组成的集合中最大的一个</strong>，要求一个元素的前驱，只需将整颗树按照 <strong>N-1</strong> 进行分裂（N是元素的值），然后在左数中找最大值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetPre</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得元素的前驱  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N<span class="number">-1</span>,X,Y);</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">siz</span>(X)) ret=INF;</span><br><span class="line">			<span class="keyword">else</span> ret=<span class="built_in">val</span>(<span class="built_in">kth</span>(X,<span class="built_in">siz</span>(X)));</span><br><span class="line">			root=<span class="built_in">merge</span>(X,Y); <span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元素的后继（Successor）"><a href="#元素的后继（Successor）" class="headerlink" title="元素的后继（Successor）"></a>元素的后继（Successor）</h3><p>元素的后继定义为 <strong>大于此元素的元素组成的集合中最小的一个</strong>，要求一个元素的后继，只需将整颗树按照 <strong>N</strong> 进行分裂（N是元素的值），然后在右树中找最小值即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetSuc</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得元素的后继  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N,X,Y);</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">siz</span>(Y)) ret=INF;</span><br><span class="line">			<span class="keyword">else</span> ret=<span class="built_in">val</span>(<span class="built_in">kth</span>(Y,<span class="number">1</span>));</span><br><span class="line">			root=<span class="built_in">merge</span>(X,Y); <span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="元素操作：元素-N-的出现与计数（Exist-amp-Count）"><a href="#元素操作：元素-N-的出现与计数（Exist-amp-Count）" class="headerlink" title="元素操作：元素 N 的出现与计数（Exist &amp; Count）"></a>元素操作：元素 N 的出现与计数（Exist &amp; Count）</h2><h3 id="元素-N-是否出现（Exist）"><a href="#元素-N-是否出现（Exist）" class="headerlink" title="元素 N 是否出现（Exist）"></a>元素 N 是否出现（Exist）</h3><p>判断给定的元素 <strong>N</strong> 是否存在，按照中序遍历整棵树即可</p>
<p>由于 <strong>FHQTreap</strong> 本质是一颗 <strong>BST</strong> ，符合 <strong>BST</strong> 的特征，所以若 <strong>N</strong> 小于等于当前结点的值，<strong>N</strong> 一定在其左子树，否则 <strong>N</strong> 只能位于其右子树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ExistK</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 递归寻找 val=K 的元素  </span></span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">val</span>(k)==N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(N&gt;=<span class="built_in">val</span>(k)) <span class="keyword">return</span> <span class="built_in">ExistK</span>(<span class="built_in">rc</span>(k),N);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ExistK</span>(<span class="built_in">lc</span>(k),N);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小于等于-N-的数的个数（Count）"><a href="#小于等于-N-的数的个数（Count）" class="headerlink" title="小于等于 N 的数的个数（Count）"></a>小于等于 N 的数的个数（Count）</h3><p>这里的 <strong>Count</strong> 与前面的 <strong>Kth</strong> 和 <strong>GetRnk</strong> 不同的是，<strong>N</strong> 可以不是当前序列中的数，按照 <strong>BST</strong> 的性质，如果当前结点 <strong>K</strong> 的值小于等于 <strong>N</strong>， 那么 <strong>K</strong> 的左子树一定全部小于等于 <strong>N</strong> ，把这部分加上后再去其右子树递归寻找，否则只用去 <strong>K</strong> 的左子树递归寻找（<strong>K</strong> 的右子树一定都比 <strong>N</strong> 大）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">CntK</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 数一下有多少个小于 N 的数 </span></span><br><span class="line">			<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span> ans;</span><br><span class="line">			<span class="keyword">if</span>(N&gt;<span class="built_in">val</span>(k)) ans=<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="number">1</span>+<span class="built_in">CntK</span>(<span class="built_in">rc</span>(k),N);</span><br><span class="line">			<span class="keyword">else</span> ans=<span class="built_in">CntK</span>(<span class="built_in">lc</span>(k),N);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="扩展操作：垃圾回收（Recycle）"><a href="#扩展操作：垃圾回收（Recycle）" class="headerlink" title="扩展操作：垃圾回收（Recycle）"></a>扩展操作：垃圾回收（Recycle）</h2><p><strong>Recycle 垃圾回收</strong> 是对那些毒瘤数据，会让平衡树频繁删点和建点设计的优化算法，可以在一定程度上节省一些空间</p>
<p>利用 <strong>DUST</strong> 数组存储已经删除的点，下次新建时优先去 <strong>DUST</strong> 里寻找已经删除的点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">New</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  		p=(dust[<span class="number">0</span>]?)dust[dust[<span class="number">0</span>]--]:++newp;</span><br><span class="line">    	<span class="built_in">lc</span>(p)=<span class="built_in">rc</span>(p)=<span class="number">0</span>; <span class="built_in">siz</span>(p)=<span class="number">1</span>;</span><br><span class="line">    	<span class="built_in">val</span>(p)=x; <span class="built_in">rnd</span>(p)=<span class="built_in">rand</span>();</span><br><span class="line">		<span class="built_in">siz</span>(p)=<span class="number">1</span>; <span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eliminate</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 消除元素  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N,X,Z);</span><br><span class="line">			<span class="built_in">SplitVal</span>(X,N<span class="number">-1</span>,X,Y);</span><br><span class="line">    		dust[++dust[<span class="number">0</span>]]=Y;</span><br><span class="line">			Y=<span class="built_in">merge</span>(<span class="built_in">lc</span>(Y),<span class="built_in">rc</span>(Y));</span><br><span class="line">			root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(X,Y),Z);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展操作：延迟标记（Tag）"><a href="#扩展操作：延迟标记（Tag）" class="headerlink" title="扩展操作：延迟标记（Tag）"></a>扩展操作：延迟标记（Tag）</h2><p><strong>Tag 延迟标记</strong> 和线段树的 <strong>LazyTag 懒标记</strong> 相似，若操作多次能造成结果的周期性变化，在 <strong>Tag</strong>  中保存操作的次数而不用马上进行操作，可以降低时间复杂度，一个例子：</p>
<blockquote>
<p>定义操作 <strong>SegReverse（L，R）</strong> 表示将区间 <strong>（L，R）</strong> 内的数字全部头尾翻转，给定原序列，输出经过 n 次给定操作后的序列</p>
</blockquote>
<p>上面的翻转操作显然具有周期性，<strong>任何区间翻转偶数次之后不会发生变化</strong>，利用延迟标记降低操作的时间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 标记下传  </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">tag</span>(k))&#123;</span><br><span class="line">				<span class="built_in">swap</span>(<span class="built_in">lc</span>(k),<span class="built_in">rc</span>(k));</span><br><span class="line">				<span class="built_in">tag</span>(<span class="built_in">lc</span>(k))^=<span class="number">1</span>;<span class="built_in">tag</span>(<span class="built_in">rc</span>(k))^=<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">tag</span>(k)=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SeqReverse</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 区间翻转  </span></span><br><span class="line">			<span class="built_in">SplitRnk</span>(root,L<span class="number">-1</span>,X,Y);</span><br><span class="line">			<span class="built_in">SplitRnk</span>(Y,R-L+<span class="number">1</span>,Y,Z);</span><br><span class="line">			<span class="built_in">tag</span>(Y)^=<span class="number">1</span>;</span><br><span class="line">			root=<span class="built_in">merge</span>(X,<span class="built_in">merge</span>(Y,Z));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出序列时要用到中序遍历</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VisDfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 中序遍历  </span></span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">//pushdown(k);</span></span><br><span class="line">			<span class="built_in">VisDfs</span>(<span class="built_in">lc</span>(k));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">val</span>(k));</span><br><span class="line">			<span class="built_in">VisDfs</span>(<span class="built_in">rc</span>(k));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展操作：启发式合并（Enlightenment-Merge）"><a href="#扩展操作：启发式合并（Enlightenment-Merge）" class="headerlink" title="扩展操作：启发式合并（Enlightenment Merge）"></a>扩展操作：启发式合并（Enlightenment Merge）</h2><p><strong>Enlightenment Merge 启发式合并</strong> 是并查集里面的一个思想，即：<strong>每次合并时，将元素少的集合合并到元素多的集合</strong>，这样的合并在树中可以减少两棵树合并后对于原树的影响，从某种玄学的角度来说，能降低后面遍历的时间复杂度，对于多根树的合并操作，启发式合并比随机合并能提高后面遍历的效率，核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MultiUnion</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">siz</span>(x)&gt;<span class="built_in">siz</span>(y)) <span class="built_in">swap</span>(x,y);</span><br><span class="line">			<span class="built_in">Union</span>(x,y); <span class="keyword">return</span> y; <span class="comment">// Union(x,y) 表示将 x 合并到 y</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MultiMerge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">			<span class="type">int</span> fx=<span class="built_in">Sfind</span>(x),fy=<span class="built_in">Sfind</span>(y);</span><br><span class="line">			<span class="keyword">if</span>(fx==fy) <span class="keyword">return</span>;</span><br><span class="line">			<span class="type">int</span> fz=<span class="built_in">MultiUnion</span>(fx,fy);</span><br><span class="line">			f[<span class="built_in">Sfind</span>(x)]=f[<span class="built_in">Sfind</span>(y)]=fz; f[fz]=fz;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>下面是一些例题：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">用到的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://newoj.cqyz.cn/problem/P2025">【培训题】平衡树[1]</a></td>
<td style="text-align:center">Split，Merge，Insert，Precursor，Successor，Exist，Rank，Eliminate</td>
</tr>
<tr>
<td style="text-align:center"><a href="http://newoj.cqyz.cn/problem/P2026">【培训题】平衡树[2]</a></td>
<td style="text-align:center">Split，Merge，Insert，Kth，Exist，Rank，Count，Eliminate</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.luogu.org/problemnew/show/P3391">【模板】文艺平衡树</a></td>
<td style="text-align:center">Split，Merge，Insert，Eliminate，Tag</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://www.luogu.org/problemnew/show/P3224">HNOI2012 永无乡</a></td>
<td style="text-align:center">Split，Merge，Insert，Eliminate，Enlightenment Merge</td>
</tr>
</tbody>
</table>
</div>
<p><strong>代码整合：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FHQTreap</span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> INF 2147483647</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">	<span class="type">int</span> X,Y,Z;</span><br><span class="line">	<span class="type">int</span> f[maxn&lt;&lt;<span class="number">2</span>]; <span class="comment">// 并查集部分   </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">FHQTreap</span>()&#123;</span><br><span class="line">		X=Y=Z=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">		<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">		x*=sign;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">FHQTreapNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> LC,RC,RND,SIZ,V,TAG;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> rnd(x) T[x].RND</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> siz(x) T[x].SIZ</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> val(x) T[x].V</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> tag(x) T[x].TAG</span></span><br><span class="line">	&#125;T[maxn&lt;&lt;<span class="number">2</span>]; <span class="type">int</span> newp,root;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="built_in">siz</span>(k)=<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="built_in">siz</span>(<span class="built_in">rc</span>(k))+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">New</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		newp++; <span class="built_in">val</span>(newp)=x; <span class="built_in">rnd</span>(newp)=<span class="built_in">rand</span>();</span><br><span class="line">		<span class="built_in">siz</span>(newp)=<span class="number">1</span>; <span class="keyword">return</span> newp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123; <span class="comment">// 合并两棵树 </span></span><br><span class="line">		<span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x|y;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">rnd</span>(x)&lt;<span class="built_in">rnd</span>(y))&#123;</span><br><span class="line">			<span class="built_in">rc</span>(x)=<span class="built_in">merge</span>(<span class="built_in">rc</span>(x),y);</span><br><span class="line">			<span class="built_in">pushup</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">lc</span>(y)=<span class="built_in">merge</span>(x,<span class="built_in">lc</span>(y));</span><br><span class="line">			<span class="built_in">pushup</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SplitVal</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tar,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123; <span class="comment">// 按权值分裂  </span></span><br><span class="line">		<span class="keyword">if</span>(!k)&#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(tar&gt;=<span class="built_in">val</span>(k))&#123;</span><br><span class="line">			x=k; <span class="built_in">SplitVal</span>(<span class="built_in">rc</span>(k),tar,<span class="built_in">rc</span>(k),y);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			y=k; <span class="built_in">SplitVal</span>(<span class="built_in">lc</span>(k),tar,x,<span class="built_in">lc</span>(k));</span><br><span class="line">		&#125; <span class="built_in">pushup</span>(k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SplitRnk</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tar,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123; <span class="comment">// 按排名分裂  </span></span><br><span class="line">		<span class="keyword">if</span>(!k)&#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(tar&lt;=<span class="built_in">siz</span>(<span class="built_in">lc</span>(k)))&#123;</span><br><span class="line">			y=k; <span class="built_in">SplitRnk</span>(<span class="built_in">lc</span>(k),tar,x,<span class="built_in">lc</span>(k));</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			x=k; <span class="built_in">SplitRnk</span>(<span class="built_in">rc</span>(k),tar-<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))<span class="number">-1</span>,<span class="built_in">rc</span>(k),y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">pushup</span>(k);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> tar)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tar&lt;=<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))) k=<span class="built_in">lc</span>(k);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tar==<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="number">1</span>) <span class="keyword">return</span> k;</span><br><span class="line">				<span class="keyword">else</span> tar-=(<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="number">1</span>), k=<span class="built_in">rc</span>(k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 几种基本操作 </span></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 插入元素  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N,X,Y);</span><br><span class="line">			root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(X,<span class="built_in">New</span>(N)),Y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eliminate</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 消除元素  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N,X,Z);</span><br><span class="line">			<span class="built_in">SplitVal</span>(X,N<span class="number">-1</span>,X,Y);</span><br><span class="line">			Y=<span class="built_in">merge</span>(<span class="built_in">lc</span>(Y),<span class="built_in">rc</span>(Y));</span><br><span class="line">			root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(X,Y),Z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">GetRnk</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得元素的排名  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N<span class="number">-1</span>,X,Y);</span><br><span class="line">			<span class="type">int</span> ret=<span class="built_in">siz</span>(X)+<span class="number">1</span>;</span><br><span class="line">			root=<span class="built_in">merge</span>(X,Y); <span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">GetPre</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得元素的前驱  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N<span class="number">-1</span>,X,Y);</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">siz</span>(X)) ret=INF;</span><br><span class="line">			<span class="keyword">else</span> ret=<span class="built_in">val</span>(<span class="built_in">kth</span>(X,<span class="built_in">siz</span>(X)));</span><br><span class="line">			root=<span class="built_in">merge</span>(X,Y); <span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">GetSuc</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得元素的后继  </span></span><br><span class="line">			<span class="built_in">SplitVal</span>(root,N,X,Y);</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">siz</span>(Y)) ret=INF;</span><br><span class="line">			<span class="keyword">else</span> ret=<span class="built_in">val</span>(<span class="built_in">kth</span>(Y,<span class="number">1</span>));</span><br><span class="line">			root=<span class="built_in">merge</span>(X,Y); <span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRanK</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 取得第 K 小的数 </span></span><br><span class="line">			<span class="type">int</span> ret=<span class="built_in">kth</span>(root,N);</span><br><span class="line">			<span class="keyword">if</span>(!ret) <span class="keyword">return</span> INF;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">val</span>(ret);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ExistK</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 递归寻找 val=K 的元素  </span></span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">val</span>(k)==N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(N&gt;=<span class="built_in">val</span>(k)) <span class="keyword">return</span> <span class="built_in">ExistK</span>(<span class="built_in">rc</span>(k),N);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ExistK</span>(<span class="built_in">lc</span>(k),N);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">siz</span>(root)) <span class="keyword">return</span> INF;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">val</span>(<span class="built_in">kth</span>(root,<span class="built_in">siz</span>(root)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">siz</span>(root)) <span class="keyword">return</span> INF;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">val</span>(<span class="built_in">kth</span>(root,<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">CntK</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 数一下有多少个小于 N 的数 </span></span><br><span class="line">			<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span> ans;</span><br><span class="line">			<span class="keyword">if</span>(N&gt;<span class="built_in">val</span>(k)) ans=<span class="built_in">siz</span>(<span class="built_in">lc</span>(k))+<span class="number">1</span>+<span class="built_in">CntK</span>(<span class="built_in">rc</span>(k),N);</span><br><span class="line">			<span class="keyword">else</span> ans=<span class="built_in">CntK</span>(<span class="built_in">lc</span>(k),N);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 文艺平衡树部分：区间翻转  </span></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 标记下传  </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">tag</span>(k))&#123;</span><br><span class="line">				<span class="built_in">swap</span>(<span class="built_in">lc</span>(k),<span class="built_in">rc</span>(k));</span><br><span class="line">				<span class="built_in">tag</span>(<span class="built_in">lc</span>(k))^=<span class="number">1</span>;<span class="built_in">tag</span>(<span class="built_in">rc</span>(k))^=<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">tag</span>(k)=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SeqReverse</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 区间翻转  </span></span><br><span class="line">			<span class="built_in">SplitRnk</span>(root,L<span class="number">-1</span>,X,Y);</span><br><span class="line">			<span class="built_in">SplitRnk</span>(Y,R-L+<span class="number">1</span>,Y,Z);</span><br><span class="line">			<span class="built_in">tag</span>(Y)^=<span class="number">1</span>;</span><br><span class="line">			root=<span class="built_in">merge</span>(X,<span class="built_in">merge</span>(Y,Z));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">VisDfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">			<span class="comment">// 中序遍历  </span></span><br><span class="line">			<span class="keyword">if</span>(!k) <span class="keyword">return</span>;</span><br><span class="line">			<span class="comment">//pushdown(k);</span></span><br><span class="line">			<span class="built_in">VisDfs</span>(<span class="built_in">lc</span>(k));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">val</span>(k));</span><br><span class="line">			<span class="built_in">VisDfs</span>(<span class="built_in">rc</span>(k));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 启发式合并 </span></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MultiInsert</span><span class="params">(<span class="type">int</span> &amp;rot,<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">			<span class="built_in">SplitVal</span>(rot,<span class="built_in">val</span>(N),X,Y);</span><br><span class="line">			rot=<span class="built_in">merge</span>(<span class="built_in">merge</span>(X,N),Y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MultiDfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">			<span class="built_in">MultiDfs</span>(<span class="built_in">lc</span>(x),y);</span><br><span class="line">			<span class="built_in">MultiDfs</span>(<span class="built_in">rc</span>(x),y);</span><br><span class="line">			<span class="built_in">lc</span>(x)=<span class="built_in">rc</span>(x)=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">MultiInsert</span>(y,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">MultiUnion</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">siz</span>(x)&gt;<span class="built_in">siz</span>(y)) <span class="built_in">swap</span>(x,y);</span><br><span class="line">			<span class="built_in">MultiDfs</span>(x,y); <span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">MultiMerge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">			<span class="type">int</span> fx=<span class="built_in">Sfind</span>(x),fy=<span class="built_in">Sfind</span>(y);</span><br><span class="line">			<span class="keyword">if</span>(fx==fy) <span class="keyword">return</span>;</span><br><span class="line">			<span class="type">int</span> fz=<span class="built_in">MultiUnion</span>(fx,fy);</span><br><span class="line">			f[<span class="built_in">Sfind</span>(x)]=f[<span class="built_in">Sfind</span>(y)]=fz; f[fz]=fz;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>分治 | 点分治 | 点分治：学习笔  记</title>
    <url>/2019/06/04/2019-06-04-dfz/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><p>点分治，是树上的一种分治算法，<strong>是统计树上路径的一种优化算法</strong></p>
<p><strong>点分治的核心思想是，对于一棵无根树的一个结点 u ，把题目要求的特征路径分为只在 u 的子树上的路径数，和经过 u 的路径数，而求只在 u 的子树上的路径数可以通过递归求解</strong></p>
<p>这里的 u 具有递归性质，那么应该考虑一个递归的入口，使得总的递归次数尽量小，也就是 u 连接的结点层数尽量小，符合要求的 u ，称之为：<strong>树的重心</strong></p>
<h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><p>求树的重心，对于优化点分治的时间复杂度很重要，而且<strong>求解数的重心的过程也是一个递归的过程，即这个“树”可能是递归时的子树，也就是说要对每一步走到的子树求重心，才能保证每一步都高效的分治求解</strong></p>
<p>求解树的重心结点是一个树上 DP 的过程，把每个点延伸到的子树大小（这里要加上它自己的 1 个）求出来，取最小的结点即可，但是要注意无根树的性质，如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">1---2;2---3;1---4;4---5;2---6;4---7</span><br></pre></td></tr></table></figure>
<p>此时，结点 4 的子树不仅包含 {5，7}，也包含它上面的一串点 {1，2，3，6}，但此时的 size() 里面是 2，那么 4 的另外一个子树大小应该是 N-size() ，N 即是总点数</p>
<h2 id="Code：求解树的重心"><a href="#Code：求解树的重心" class="headerlink" title="Code：求解树的重心"></a>Code：求解树的重心</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rootdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu &amp;&amp; !vis[to[i]])&#123;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],u); siz[u]+=siz[to[i]];</span><br><span class="line">			f[u]=<span class="built_in">max</span>(f[u],siz[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	f[u]=<span class="built_in">max</span>(f[u],nsize-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(maxsize&gt;siz[u]) root=u; <span class="comment">// maxsize 初始为 INF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题1：【模板】点分治1（洛谷P3806）"><a href="#例题1：【模板】点分治1（洛谷P3806）" class="headerlink" title="例题1：【模板】点分治1（洛谷P3806）"></a>例题1：【模板】点分治1（洛谷P3806）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一棵有n个点的树</p>
<p>询问树上距离为k的点对是否存在。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>n,m 接下来n-1条边a,b,c描述a到b有一条长度为c的路径</p>
<p>接下来m行每行询问一个K</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个K每行输出一个答案，存在输出“AYE”,否则输出”NAY”(不包含引号)</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">AYE</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于30%的数据n&lt;=100</p>
<p>对于60%的数据n&lt;=1000,m&lt;=50</p>
<p>对于100%的数据n&lt;=10000,m&lt;=100,c&lt;=10000,K&lt;=10000000</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对于两点之间路径长度为 K 的点对数目，可以通过点分治来实现，<strong>即将当前点子树中的点对路径为 K 的点对分成 都在同一棵子树中 和 穿越当前结点，在两棵不同子树中 的两种情况</strong>，又发现对于第一种情况可以递归处理，完美配合点分治的思想</p>
<p>初步实现：先一次 DFS 将以 K 为根结点的子树中的所有点到 K 的距离计算出来，然后用标记数组标记出现的路径长度（之后可以 $O(n)$ 离线处理询问），再按照分治的思想，每次选择当前树的重心结点进入，递归解决即可</p>
<p>但是，我们的目的是统计跨越子树的点对路径长度，对于上面的 DFS 求点到 K 的路径长度再加起来的确行之有效，然而某些处于同一子树中的点对的距离就不会被正确的计算，从而有可能导致多余的统计，如：</p>
<blockquote>
<p><strong>目标路径长度为 5，根结点为 1</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">1--2---2;1--3---3</span><br><span class="line">2--1---4;2--1---5</span><br></pre></td></tr></table></figure>
<p>在上图中会发现，按照前面 DFS 累加的思想，会使得 2 到 4 的路径长度 $Len(2,\;4)$ 被计算为 $Dist(2)+Dist(4)=5$ 从而统计进答案，但是 $Len(2,\;4)=1$ 才是正确答案，而正确的答案应该为$Len(2,\;3)=5$ 只有一组</p>
<p><strong>解决的方法就是，ans 统计之后，对于当前结点 K 的每个直接子结点（有边的）多统计一次，这次统计与上次统计相反，把标记数组中的路径长度对应的计数器全部减掉，就实现了排错，注意进入递归时，如果时累加（从 K 开始）就不同带初始值，设为 0 就好，但如果是排错（从 K 的某个儿子开始）就要带上初始值，为 K 和这个儿子之间的边权（因为 $Dist$ 统计的是所有子树中的点到 K 的距离）</strong></p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 40001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxk 10000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2139062143</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> siz[maxn],f[maxn],w[maxm],d[maxn]; <span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> ex[maxk];</span><br><span class="line"><span class="type">int</span> n,k,m,tot,root,nsize,maxsize;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> ww)</span></span>&#123;</span><br><span class="line">	nxt[++tot]=head[x]; w[tot]=ww;</span><br><span class="line">	to[tot]=y; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rootdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu &amp;&amp; !vis[to[i]])&#123;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],u); siz[u]+=siz[to[i]];</span><br><span class="line">			f[u]=<span class="built_in">max</span>(f[u],siz[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	f[u]=<span class="built_in">max</span>(f[u],nsize-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(maxsize&gt;siz[u]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ds;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu,<span class="type">int</span> wu)</span></span>&#123;</span><br><span class="line">	d[++ds]=wu;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu &amp;&amp; !vis[to[i]])</span><br><span class="line">			<span class="built_in">pathdfs</span>(to[i],u,wu+w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stat</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val,<span class="type">bool</span> plus)</span></span>&#123;</span><br><span class="line">	ds=<span class="number">0</span>; <span class="built_in">pathdfs</span>(u,<span class="number">0</span>,val);</span><br><span class="line">	<span class="keyword">if</span>(plus)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ds;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=ds;j++) </span><br><span class="line">				ex[d[i]+d[j]]++;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ds;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=ds;j++) </span><br><span class="line">				ex[d[i]+d[j]]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="built_in">stat</span>(u,<span class="number">0</span>,<span class="literal">true</span>); vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">			<span class="built_in">stat</span>(to[i],w[i],<span class="literal">false</span>);</span><br><span class="line">			nsize=siz[to[i]]; maxsize=INF;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],<span class="number">0</span>); <span class="built_in">dfs</span>(root); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); <span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="built_in">Eadd</span>(a,b,c);<span class="built_in">Eadd</span>(b,a,c);</span><br><span class="line">	&#125;</span><br><span class="line">	nsize=n; maxsize=INF;</span><br><span class="line">	<span class="built_in">rootdfs</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">		<span class="keyword">if</span>(ex[k]) <span class="built_in">printf</span>(<span class="string">&quot;AYE\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题2：洛谷P4178-Tree"><a href="#例题2：洛谷P4178-Tree" class="headerlink" title="例题2：洛谷P4178 Tree"></a>例题2：洛谷P4178 Tree</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>N（n&lt;=40000） 接下来n-1行边描述管道，按照题目中写的输入 接下来是k</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>一行，有多少对点之间的距离小于等于k</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 6 13 </span><br><span class="line">6 3 9 </span><br><span class="line">3 5 7 </span><br><span class="line">4 1 3 </span><br><span class="line">2 4 20 </span><br><span class="line">4 7 2 </span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>$K\leq 2000$，$\forall w_i\leq 1000$</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>有了<strong>例题 1</strong> 的思路，这道题显然是可以用点分治来解决的，与 例题 1 不同的是，这道题需要统计的是小于等于 K 的路径长度的点对数量</p>
<p>还是采用 整体统计 + 子树排错 的方法做，即先无脑统计 K 所有子树中满足 $Dist(x)+Dist(y)\leq k$ 的点对个数，再后面排错减掉</p>
<p>统计点对数时要用到两个指针 L，R 来优化，具体是：<strong>先将 K 的所有子结点到 K 的长度求出来，将他们排序，此时 R 代表路径最长的点，L 代表路径最短的点，每次判断 $Dist[L]+Dist[R]\leq k$ 成立与否，如果成立，说明 L 与 L+1 到 R 之间的所有点连接的边都小于等于 k（排序之后具有单调性），打答案累加，移动 L，R 就实现了快速统计</strong></p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 40001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2139062143</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> siz[maxn],f[maxn],w[maxm],d[maxn]; <span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> n,k,tot,root,nsize,maxsize;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> ww)</span></span>&#123;</span><br><span class="line">	nxt[++tot]=head[x]; w[tot]=ww;</span><br><span class="line">	to[tot]=y; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rootdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu &amp;&amp; !vis[to[i]])&#123;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],u); siz[u]+=siz[to[i]];</span><br><span class="line">			f[u]=<span class="built_in">max</span>(f[u],siz[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	f[u]=<span class="built_in">max</span>(f[u],nsize-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(maxsize&gt;siz[u]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L,R;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu,<span class="type">int</span> wu)</span></span>&#123;</span><br><span class="line">	d[++R]=wu;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu &amp;&amp; !vis[to[i]])</span><br><span class="line">			<span class="built_in">pathdfs</span>(to[i],u,wu+w[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">stat</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	R=<span class="number">0</span>; L=<span class="number">1</span>; ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">pathdfs</span>(u,<span class="number">0</span>,val);</span><br><span class="line">	<span class="built_in">sort</span>(d+<span class="number">1</span>,d+R+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[L]+d[R]&lt;=k) sum+=R-L,L++;</span><br><span class="line">		<span class="keyword">else</span> R--; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	ans+=<span class="built_in">stat</span>(u,<span class="number">0</span>); vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">			ans-=<span class="built_in">stat</span>(to[i],w[i]);</span><br><span class="line">			nsize=siz[to[i]]; maxsize=INF;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],<span class="number">0</span>); <span class="built_in">dfs</span>(root); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); <span class="type">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="built_in">Eadd</span>(a,b,c);<span class="built_in">Eadd</span>(b,a,c);</span><br><span class="line">	&#125; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">	maxsize=INF; nsize=n;</span><br><span class="line">	<span class="built_in">rootdfs</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题3：洛谷P2634-聪聪可可"><a href="#例题3：洛谷P2634-聪聪可可" class="headerlink" title="例题3：洛谷P2634 聪聪可可"></a>例题3：洛谷P2634 聪聪可可</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。</p>
<p>他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。</p>
<p>聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>以即约分数形式输出这个概率（即“a/b”的形式，其中a和b必须互质。如果概率为1，输出“1/1”）。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">1 4 1</span><br><span class="line">2 5 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">13/25</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>【样例说明】</p>
<p>13组点对分别是(1,1) (2,2) (2,3) (2,5) (3,2) (3,3) (3,4) (3,5) (4,3) (4,4) (5,2) (5,3) (5,5)。</p>
<p>【数据规模】</p>
<p>对于100%的数据，n&lt;=20000。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先把所有点之间的边权模 3，这样做了之后对统计答案是没有影响的</p>
<p><strong>采用点分治时，我们把 K 的子树结点到 K 的距离值的集合分为 3 个部分，为距离值模 3 等于 0 的，等于 1 的，和等于 2 的三种情况，个数分别记作 $sum[0],\;sum[1],\;sum[2]$</strong></p>
<p>然后组合一下，$sun[0]$ 的边已经满足是三的倍数，可以两两组合，依然是三的倍数，而 $sum[1]$ 和 $sum[2]$ 的边拼接起来，边权就成 3 的倍数了，由于题目没交代顺序，因此 $sum[0]\to sum[1]$ 和 $sum[1]\to sum[0]$ 都要统计，于是就有 $Ans=sum[0]^2+2sum[1]\times sum[2]$</p>
<p>计算概率时，注意路径总数为 $n\times n$ ，输出分数要用 GCD 化简</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 2139062143</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn]; ll sum[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> siz[maxn],f[maxn],w[maxm],d[maxn]; <span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> n,k,tot,root,nsize,maxsize;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> ww)</span></span>&#123;</span><br><span class="line">	ww%=<span class="number">3</span>;</span><br><span class="line">	nxt[++tot]=head[x]; w[tot]=ww;</span><br><span class="line">	to[tot]=y; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rootdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu &amp;&amp; !vis[to[i]])&#123;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],u); siz[u]+=siz[to[i]];</span><br><span class="line">			f[u]=<span class="built_in">max</span>(f[u],siz[to[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	f[u]=<span class="built_in">max</span>(f[u],nsize-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(maxsize&gt;siz[u]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathdfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu,<span class="type">int</span> wu)</span></span>&#123;</span><br><span class="line">	sum[wu%<span class="number">3</span>]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]] &amp;&amp; to[i]!=fu)</span><br><span class="line">			<span class="built_in">pathdfs</span>(to[i],u,(wu+w[i])%<span class="number">3</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">stat</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	sum[<span class="number">0</span>]=sum[<span class="number">1</span>]=sum[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">pathdfs</span>(u,<span class="number">0</span>,val);</span><br><span class="line">	<span class="keyword">return</span> sum[<span class="number">0</span>]*sum[<span class="number">0</span>]+sum[<span class="number">1</span>]*sum[<span class="number">2</span>]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	ans+=<span class="built_in">stat</span>(u,<span class="number">0</span>); vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">			ans-=<span class="built_in">stat</span>(to[i],w[i]);</span><br><span class="line">			nsize=siz[to[i]]; maxsize=INF;</span><br><span class="line">			<span class="built_in">rootdfs</span>(to[i],<span class="number">0</span>); <span class="built_in">dfs</span>(root); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(b^=a^=b^=a%=b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n); <span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y,z);<span class="built_in">Eadd</span>(y,x,z);</span><br><span class="line">	&#125;																	</span><br><span class="line">	nsize=n; maxsize=INF;</span><br><span class="line">	<span class="built_in">rootdfs</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs</span>(root);</span><br><span class="line">	n=n*n; ll gcds=<span class="built_in">gcd</span>(ans,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,ans/gcds,n/gcds);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="这里要说一个注意事项"><a href="#这里要说一个注意事项" class="headerlink" title="这里要说一个注意事项"></a>这里要说一个注意事项</h3><p>之前写找重心的 DFS 的时候，我是直接用一个变量 maxsize 来表示当前子树最小的结点，但是后来发现完全不用这样，只需要表示出根结点 root，每次寻找的时候把 root 改成 0 ，把 siz(0) 改成 n+1 就可以了，而且貌似这样写的话时间复杂度还可以大大降低……</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | [USACO08NOV]奶牛混合起来  Mixed Up Cows</title>
    <url>/2019/06/11/2019-06-11-%E6%B7%B7%E4%B9%B1%E7%9A%84%E5%A5%B6%E7%89%9B/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>Each of Farmer John’s N (4 &lt;= N &lt;= 16) cows has a unique serial  number S_i (1 &lt;= S_i &lt;= 25,000). The cows are so proud of it that  each one now wears her number in a gangsta manner engraved in large  letters on a gold plate hung around her ample bovine neck.</p>
<p>Gangsta cows are rebellious and line up to be milked in an order  called ‘Mixed Up’. A cow order is ‘Mixed Up’ if the sequence of serial  numbers formed by their milking line is such that the serial numbers of  every pair of consecutive cows in line differs by more than K (1 &lt;= K  &lt;= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a  ‘Mixed Up’ lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive  numbers 5 and 6 differ by 1).</p>
<p>How many different ways can N cows be Mixed Up?</p>
<p>For your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data.</p>
</blockquote>
<p>约翰家有N头奶牛，第i头奶牛的编号是Si，每头奶牛的编号都是唯一的。这些奶牛最近  在闹脾气，为表达不满的情绪，她们在挤奶的时候一定要排成混乱的队伍。在一只混乱的队 伍中，相邻奶牛的编号之差均超过K。比如当K = 1时，1,  3, 5, 2, 6, 4就是一支混乱的队伍， 而1, 3, 6, 5, 2, 4不是，因为6和5只差1。请数一数，有多少种队形是混乱的呢？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><ul>
<li><p>Line 1: Two space-separated integers: N and K</p>
</li>
<li><p>Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S_i</p>
</li>
</ul>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><ul>
<li>Line 1: A single integer that is the number of ways that N cows can be<br>‘Mixed Up’. The answer is guaranteed to fit in a 64 bit integer.</li>
</ul>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2>  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 1 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">2 </span><br><span class="line">1 </span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题考试时写了回溯，<del>结果作死的把每种方案详细的输出来了导致部分分也没有了</del>，后来才知道正解应是状压 DP</p>
<p>先看看开始写的错误 DP：$f[i][j]=\sum_{p=1}^{n}f[i-1][k]\;\;\;(abs(s[j]-s[p])&gt;k)$</p>
<p>这里的 $i$ 表示行数，$j$ 表示最后放第 $j$ 头牛，边界情况为 $f[1][i]=1\;\;\;(i\in[1,\;n])$</p>
<p>这样写的话明显会计算到重复的情况（这里指隔一位出现同一头牛），而且怎么改也改不对。。。</p>
<p>但是最初的思路是有用的，状压 DP 的思路与此已经很相近了，不同的是，用类似 <a href="https://newoj.cqyz.cn/problem/P1976"><strong>TSP问题</strong></a> 的思路</p>
<p>设 $f[i][j]$ 表示当前放置的状态为二进制数 $i$ 的情况下，最后放的是第 $j$ 头奶牛的方案数，新的状态转移方程为：$f[i][j]=\sum^{n}_{p=1}f[i’][p]\;\;\;(i’=i-2^j,\;j\notin i,\;p\in i’,\;abs(s[j]-s[p])&gt;k)$</p>
<p>当然也可以写成：$f[i’][p]=\sum^n_{p=1}f[i][j]\;\;\;(i’=i+2^p,\;j\in i,\;p\notin i,\;abs(s[j]-s[p])&gt;k)$</p>
<p>这里的 $i$ 表示的是放置状态的集合，用 <code>i &amp; (1&lt;&lt;j)</code> 可以判断 $j$ 是否处于 $i$ 中（$p$ 同理）</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxs 65537</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 17</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll f[maxs][maxn];</span><br><span class="line"><span class="type">int</span> st[maxn];</span><br><span class="line"><span class="type">int</span> s[maxn],n,k;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxst=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) st[i]=st[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[st[i]][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxst;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="keyword">if</span>(i&amp;st[j])</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;p++)</span><br><span class="line">				<span class="keyword">if</span>(!(i&amp;st[p]) &amp;&amp; <span class="built_in">abs</span>(s[j]-s[p])&gt;k) </span><br><span class="line">					f[i+st[p]][p]+=f[i][j];</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=f[maxst][i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;mixed.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;mixed.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(k); st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(s[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">solve</span>()); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | SPFA | 20190623考试：解题报告</title>
    <url>/2019/06/24/2019-06-24-%E8%80%83%E8%AF%95%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Problem-1：虫洞-wormhole-cpp-c-pas"><a href="#Problem-1：虫洞-wormhole-cpp-c-pas" class="headerlink" title="Problem.#1：虫洞(wormhole.cpp/c/pas)"></a>Problem.#1：虫洞(wormhole.cpp/c/pas)</h2><blockquote>
<p>While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ’s farms comprises N (1 ≤ N ≤ 500) fields conveniently numbered 1..N, M (1 ≤ M ≤ 2500) paths, and W (1 ≤ W ≤ 200) wormholes.</p>
<p>As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) .</p>
<p>To help FJ find out whether this is possible or not, he will supply you with complete maps to F (1 ≤ F ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds.</p>
</blockquote>
<p>John在他的农场中闲逛时发现了许多虫洞。虫洞可以看作一条十分奇特的有向边，并可以使你返回到过去的一个时刻（相对你进入虫洞之前）。John的每个农场有M条小路（无向边）连接着N （从1..N标号）块地，并有W个虫洞（有向边）。其中1&lt;=N&lt;=500,1&lt;=M&lt;=2500,1&lt;=W&lt;=200。 现在John想借助这些虫洞来回到过去（出发时刻之前），也就是说，John可以从任何一块地开始，但是最终要通过虫洞回到这块地，且时间要处在开始之前，请你告诉John他能办到吗。</p>
<p> John将向你提供F(1&lt;=F&lt;=5)个农场的地图。没有小路会耗费你超过10000秒的时间，当然也没有虫洞回帮你回到超过10000秒以前。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><ul>
<li><p>Line 1: 一个整数 F, 表示农场个数。</p>
</li>
<li><p>Line 1 of each farm: 三个整数 N, M, W。</p>
</li>
<li><p>Lines 2..M+1 of each farm: 三个数（S, E, T）。表示在标号为S的地与标号为E的地中间有一条用时T秒的小路。</p>
</li>
<li><p>Lines M+2..M+W+1 of each farm: 三个数（S, E, T）。表示在标号为S的地与标号为E的地中间有一条可以使John到达T秒前的虫洞。</p>
</li>
</ul>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><ul>
<li>Lines 1..F: 如果John能在这个农场实现他的目标，输出”YES”,否则输出”NO”。</li>
</ul>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 3 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 3 1</span><br><span class="line">3 1 3</span><br><span class="line">3 2 1</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">3 1 8</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>图论基础题，理解一下题目大意，就是：<strong>给你一张含有 M 条无向边的和 W 条有向边的混合图，问你图中是否存在负环（因为通过虫洞回到原点时时间在开始之前，那么路上权值之和一定为负值）</strong></p>
<p>判断负环用的是 SPFA 算法</p>
<h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e15</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,addcnt[maxn];</span><br><span class="line">ll dist[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	vector&lt;pr&gt; linkto;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">		e[x].linkto.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y,z));</span><br><span class="line">		e[y].linkto.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x,z));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">		e[x].linkto.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y,-z));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> st,<span class="type">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;pr&gt;::iterator iterid;</span><br><span class="line">	<span class="type">int</span> head,next,val;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; wait;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">if</span>(mode==<span class="number">1</span>)&#123; <span class="comment">// 判断负环  </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			dist[i]=<span class="number">0</span>;</span><br><span class="line">			vis[i]=<span class="literal">true</span>;</span><br><span class="line">			wait.<span class="built_in">push</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i]=INF;</span><br><span class="line">		dist[st]=<span class="number">0</span>;</span><br><span class="line">		vis[st]=<span class="literal">true</span>;</span><br><span class="line">		wait.<span class="built_in">push</span>(st);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!wait.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		head=wait.<span class="built_in">front</span>();</span><br><span class="line">		wait.<span class="built_in">pop</span>();</span><br><span class="line">		vis[head]=<span class="literal">false</span>;</span><br><span class="line">		iterid=e[head].linkto.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span>(iterid!=e[head].linkto.<span class="built_in">end</span>())&#123;</span><br><span class="line">			next=iterid-&gt;first;</span><br><span class="line">			val=iterid-&gt;second;</span><br><span class="line">			<span class="keyword">if</span>(dist[next]&gt;dist[head]+val)&#123;</span><br><span class="line">				dist[next]=dist[head]+val;</span><br><span class="line">				<span class="keyword">if</span>(!vis[next])&#123;</span><br><span class="line">					vis[next]=<span class="literal">true</span>;</span><br><span class="line">					wait.<span class="built_in">push</span>(next);</span><br><span class="line">					addcnt[next]++;</span><br><span class="line">					<span class="keyword">if</span>(mode==<span class="number">1</span>) <span class="keyword">if</span>(addcnt[next]&gt;=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			iterid++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;wormhole.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;wormhole.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> T; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>,<span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].linkto.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">memset</span>(addcnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(addcnt));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="Problem-2：数列问题"><a href="#Problem-2：数列问题" class="headerlink" title="Problem.#2：数列问题"></a>Problem.#2：数列问题</h2><p>给定一个数列，从中找到3个无交集的连续子数列使其和最大。</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>第一行一个数n，表示数列长度。</p>
<p>接下来有n行，每行一个数，第i行为第i个数。</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>仅有一个数，表示最大和。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">-1 2 3 -4 0 1 -6 -1 1 -2</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>考试时想到的是所有的正数和 + 如果正数不够 3 个就加上最大的负数，愉快的 WA 了大样例（因为两个区间的正数和他们之间的负数的整体和很有可能大于原来的任何一个正数区间和）</p>
<p>于是自然而然地想到了 DP，设 $f[i][j][k]$ 表示当前考虑到第 $i$ 个数，要形成 $j$ 组（$j\leq 3$）并且选不选这个数（$k=0$ 表示不选，反之则选），下面来讨论：</p>
<ol>
<li><p>如果选这个数，那么要形成 $j$ 组，可以根第 $i-1$ 个数凑到一起，需要 $f[i-1][j][1]$ ，或者也可以另起一组那么第 $i-1$ 个数就无所谓了，需要 $f[i-1][j-1][0]$ 或 $f[i-1][j-1][1]$ 皆可</p>
</li>
<li><p>如果不选这个数，那么要形成 $j$ 组，显然第 $i-1$ 个数必须已经形成 $j$ 组才行，所以就是 $f[i-1][j][0]$ 和 $f[i-1][j][1]$ </p>
</li>
</ol>
<h2 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll a[maxn];ll n;</span><br><span class="line">ll f[maxn][<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;array.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;array.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">			f[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j][<span class="number">1</span>]);</span><br><span class="line">			f[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>],f[i<span class="number">-1</span>][j][<span class="number">1</span>]))+a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">max</span>(f[n][<span class="number">3</span>][<span class="number">0</span>],f[n][<span class="number">3</span>][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Problem-3：Dueling-GPS-gps-cpp"><a href="#Problem-3：Dueling-GPS-gps-cpp" class="headerlink" title="Problem.#3：Dueling GPS (gps.cpp)"></a>Problem.#3：Dueling GPS (gps.cpp)</h2><blockquote>
<p>Farmer John has recently purchased a new car online, but in his haste he accidentally clicked the “Submit” button twice when selecting extra features for the car, and as a result the car ended up equipped with two GPS navigation systems! Even worse, the two systems often make conflicting decisions about the route that FJ should take. The map of the region in which FJ lives consists of N intersections (2 &lt;= N &lt;= 10,000) and M directional roads (1 &lt;= M &lt;= 50,000). Road i connects intersections A_i (1 &lt;= A_i &lt;= N) and B_i (1 &lt;= B_i &lt;= N). Multiple roads could connect the same pair of intersections, and a bi-directional road (one permitting two-way travel) is represented by two separate directional roads in opposite orientations. FJ’s house is located at intersection 1, and his farm is located at intersection N. It is possible to reach the farm from his house by traveling along a series of directional roads. Both GPS units are using the same underlying map as described above; however, they have different notions for the travel time along each road. Road i takes P_i units of time to traverse according to the first GPS unit, and Q_i units of time to traverse according to the second unit (each travel time is an integer in the range 1..100,000). FJ wants to travel from his house to the farm. However, each GPS unit complains loudly any time FJ follows a road (say, from intersection X to intersection Y) that the GPS unit believes not to be part of a shortest route from X to the farm (it is even possible that both GPS units can complain, if FJ takes a road that neither unit likes). Please help FJ determine the minimum possible number of total complaints he can receive if he chooses his route appropriately. If both GPS units complain when FJ follows a road, this counts as +2 towards the total.</p>
</blockquote>
<p>John最近新买了辆车，但是他在为车订购GPS时，脑子进水点了两下”Submit”，导致新车装了两套GPS系统，更糟的是，两套GPS系统存储的路径信息不同，当John没有按照GPS的预定最短路径走的时候，GPS就会报警一次，如果John同时不在两套GPS的预定路径上行驶，他们甚至会同时报警，John现在把这个难题交给了你，他给了你一张有向图有 N 个结点和 M 条边，两套GPS存储的从 i 到 j 的路径长度分别用 A_i 和 B_i 表示，John希望你帮他设计一条从 1 到 N的路线，使得他能听到最少的GPS报警次数</p>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><ul>
<li>Line 1: The integers N and M. Line i describes road i with four integers: A_i B_i P_i Q_i.</li>
</ul>
<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><ul>
<li>Line 1: The minimum total number of complaints FJ can receive if he routes himself from his house to the farm optimally.</li>
</ul>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">3 4 7 1</span><br><span class="line">1 3 2 20</span><br><span class="line">1 4 17 18</span><br><span class="line">4 5 25 3</span><br><span class="line">1 2 10 1</span><br><span class="line">3 5 4 14</span><br><span class="line">2 4 6 5</span><br></pre></td></tr></table></figure>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p><strong>建三个图，分别存储 GPS1  的路径信息，GPS2的路径信息，以及报警次数</strong></p>
<p>先对 1，2 图进行 SPFA ，记录下最短路经过的边，一开始把 3 图的边权全部改成 2，代表两个 GPS 都为报警，然后对于每个 GPS 认为的最短路径的边，在 3 图中边权减去 1 即可</p>
<p><strong>需要注意的是，GPS 对于路径的选择是实时更新的，每次 GPS 都会选择当前点 k 到点 N 的最短路径而不是当前点 k 到点 1 的最短路径，因此 1，2 图要存逆图再 SPFA</strong></p>
<p>最后在图3上 SPFA 求最短路就可以了</p>
<h2 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 50001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// mixed graphs </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> TO,NXT,VAL;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> to(x,y) g[x][y].TO </span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> nxt(x,y) g[x][y].NXT</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> val(x,y) g[x][y].VAL </span></span><br><span class="line">&#125;g[<span class="number">4</span>][maxm]; <span class="type">int</span> tot[<span class="number">4</span>],head[<span class="number">4</span>][maxm];</span><br><span class="line"><span class="type">int</span> n,m,vis[maxn];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">nxt</span>(cnt,++tot[cnt])=head[cnt][u];</span><br><span class="line">	<span class="built_in">to</span>(cnt,tot[cnt])=v; <span class="built_in">val</span>(cnt,tot[cnt])=x;</span><br><span class="line">	head[cnt][u]=tot[cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> cnt,<span class="type">int</span> st)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> dist[maxn];<span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">qhead</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; q;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">127</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,st));vis[st]=<span class="literal">true</span>;dist[st]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		qhead=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dist[qhead.second]!=-qhead.first) <span class="keyword">continue</span>;</span><br><span class="line">		vis[qhead.second]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[cnt][qhead.second];i;i=<span class="built_in">nxt</span>(cnt,i))</span><br><span class="line">			<span class="keyword">if</span>(!vis[<span class="built_in">to</span>(cnt,i)])</span><br><span class="line">				<span class="keyword">if</span>(dist[<span class="built_in">to</span>(cnt,i)]&gt;dist[qhead.second]+<span class="built_in">val</span>(cnt,i))</span><br><span class="line">					dist[<span class="built_in">to</span>(cnt,i)]=dist[qhead.second]+<span class="built_in">val</span>(cnt,i),</span><br><span class="line">					q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dist[<span class="built_in">to</span>(cnt,i)],<span class="built_in">to</span>(cnt,i)));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dist[n]);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=head[cnt][i];j;j=<span class="built_in">nxt</span>(cnt,j))</span><br><span class="line">				<span class="keyword">if</span>(dist[i]+<span class="built_in">val</span>(cnt,j)==dist[<span class="built_in">to</span>(cnt,j)])</span><br><span class="line">					<span class="built_in">val</span>(<span class="number">3</span>,j)--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;gps.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;gps.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m); <span class="type">int</span> x,y,z,w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);<span class="built_in">fcin</span>(w);</span><br><span class="line">		<span class="built_in">Eadd</span>(<span class="number">1</span>,y,x,z);<span class="built_in">Eadd</span>(<span class="number">2</span>,y,x,w);</span><br><span class="line">		<span class="built_in">Eadd</span>(<span class="number">3</span>,x,y,<span class="number">2</span>); </span><br><span class="line">	&#125; <span class="built_in">SPFA</span>(<span class="number">1</span>,n);<span class="built_in">SPFA</span>(<span class="number">2</span>,n);</span><br><span class="line">	<span class="built_in">SPFA</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 2-SAT | 2-SAT问题：学习笔记</title>
    <url>/2019/06/28/2019-06-28-twoSAT/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="2-SAT-问题"><a href="#2-SAT-问题" class="headerlink" title="2-SAT 问题"></a>2-SAT 问题</h2><blockquote>
<p>$\mathtt{SAT=Satisfiability}$</p>
</blockquote>
<p><strong>2-SAT 问题</strong>，就是求一类 <strong>在多个只有两个元素的集合里面选择元素，每个集合里面只能选一个，并满足给定的约束条件</strong> 的问题，处理这类约束条件的思路有点像 <strong>差分约束系统</strong>，即建立有向图来表示限制条件，这类问题的一般形式其实是 K-SAT 问题，即每个元素里面有 K 个元素，2-SAT 只是其中的一个情况</p>
<p>由于 2-SAT 问题不好系统地解释，下面用一个例题结合起来总结：</p>
<h2 id="CQYZOJ-P2060-和平委员会"><a href="#CQYZOJ-P2060-和平委员会" class="headerlink" title="CQYZOJ P2060.和平委员会"></a><a href="https://newoj.cqyz.cn/problem/P2060">CQYZOJ P2060.和平委员会</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p> 某国有n个党派，每个党派在议会中恰有2个代表。现在要成立和平委员会 ，该委员会必须满足：</p>
<p>　　1、每个党派在和平委员会中有且只有一个代表 。<br>　　2、如果某两个代表不和，则他们不能都属于委员会 。</p>
<p>　　代表的编号从 1 到 2n，编号为 2a-1、2a 的代表属于第a个党派，求和平委员会是否能创立。若能，求一种构成方式。 </p>
<p>　　<strong>PS：有n个组，第i个组里有两个节点Ai, Ai” 。需要从每个组中选出一个。而某些点不可以同时选出（称之为不相容）。任务是保证选出的n个点都能两两相容。这类型的问题我们称之为2-SAT问题。</strong>  </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数 n 和 m ，分别表示党派数量和 m 对不和的关系。　　接下来 m 行每行两个整数 a,b，表示编号为 a 和 b 的代表不和</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>如果能成立，则输出构成委员会的代表的编号，输出字典序最小的方案。如果不能成立，则输出”NIE”。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>1≤n≤8000，0≤m ≤20000 。</p>
<h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><p>典型的模板题，每个党派是一个集合，两个代表是元素，只能选一个代表进入和平委员会而且还要保证避开代表的冲突关系，也就是不同集合元素间的约束关系，下面总结了两种方法解决 2-SAT 问题，分别是 <strong>强连通分量法</strong> 和 <strong>染色法</strong></p>
<h3 id="建立有向图（重点）"><a href="#建立有向图（重点）" class="headerlink" title="建立有向图（重点）"></a>建立有向图（重点）</h3><p>无论是 <strong>强连通分量法</strong> 还是 <strong>染色法 </strong> 都要求在建好的有向图上进行操作，建立有向图的原则是 <strong>如果选择 $i$ 就必须选择 $j$，那么就连接 $i\to j$</strong>，以输入样例作为例子：</p>
<p>3 个集合分别是 ${1,\;2}$，${3\;4}$，${5,\;6}$，其中代表 1 和代表 3 冲突，那么意味着选择了 1 就只能选 4，这时连接 $1\to 4$，同理选了 3 就只能选 2，连接 $3\to 2$，代表 2 和 4 发生冲突就连接 $2\to 3$，$4\to 1$ 即可</p>
<h3 id="强连通分量法"><a href="#强连通分量法" class="headerlink" title="强连通分量法"></a>强连通分量法</h3><p>顾名思义，对这张有向图跑一个 <strong>Tarjan</strong> 或者 <strong>Kosaraju </strong> 跑完后所有的强连通分量里的点就是必选的点，由于一个集合里面只能选择一个代表，只要两个元素 $i_1,\;i_2$ 出现在同一个强连通分量里就说明矛盾，那么就是无解的情况</p>
<p>由于写过强连通分量的板子，就不再此放出代码了</p>
<h3 id="染色法（重点）"><a href="#染色法（重点）" class="headerlink" title="染色法（重点）"></a>染色法（重点）</h3><p>枚举每个集合，从代表 1 出发，递归地把必选的点都染上颜色，如果染色过程中发现有有同一集合的两个元素都被染色就铁定是无解，<strong>这时需要把之前染过的色清除掉，并从代表 2 开始新的一轮染色，如果代表 2 也返回了无解的结果，才判定整张图是无解的状态</strong></p>
<p>染色法的思路和二分图判定相似，但是要注意<strong>，每次判断局部无解时，一遇到染色失败的情况可以直接返回无解，但是染色成功时却不能直接返回有解（想想应该能明白……）</strong></p>
<p>最后的选择方案就是所有染色点的编号，并且这是字典序最小的选择方案</p>
<h2 id="例题代码"><a href="#例题代码" class="headerlink" title="例题代码"></a>例题代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 8001*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 20001*4</span></span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n,m,other[maxn],stk[maxn];</span><br><span class="line"><span class="type">bool</span> color[maxn];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v; nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(color[u]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(color[other[u]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	color[u]=<span class="number">1</span>; stk[++stk[<span class="number">0</span>]]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">DFS</span>(to[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">twoSAT</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(color[<span class="number">2</span>*i<span class="number">-1</span>] &amp;&amp; color[<span class="number">2</span>*i]) <span class="keyword">continue</span>;</span><br><span class="line">		stk[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">DFS</span>(<span class="number">2</span>*i<span class="number">-1</span>))&#123;</span><br><span class="line">			<span class="keyword">while</span>(stk[<span class="number">0</span>]) color[stk[stk[<span class="number">0</span>]]]=<span class="number">0</span>,stk[<span class="number">0</span>]--;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">DFS</span>(<span class="number">2</span>*i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m); <span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&amp;<span class="number">1</span>) other[i]=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> other[i]=i<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,other[y]); <span class="built_in">Eadd</span>(y,other[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">twoSAT</span>()) <span class="built_in">printf</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) <span class="keyword">if</span>(color[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="洛谷P4782：2-SAT-问题"><a href="#洛谷P4782：2-SAT-问题" class="headerlink" title="洛谷P4782：2-SAT 问题"></a><a href="https://www.luogu.org/problemnew/show/P4782">洛谷P4782：2-SAT 问题</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>有n个布尔变量x1x_1x1~xnx_nxn，另有m个需要满足的条件，每个条件的形式都是“xi为true/false或xj为true/false”。比如“x1为真或x3为假”、“x7为假或x2为假”。2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数n和m，意义如体面所述。</p>
<p>接下来m行每行4个整数 i a j b，表示“xi为a或xj为b”(a,b∈{0,1})</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>如无解，输出“IMPOSSIBLE”（不带引号）; 否则输出”POSSIBLE”（不带引号),下<br>一行n个整数x1~xn（xi∈{0,1}），表示构造出的解。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 1 3 0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POSSIBLE</span><br><span class="line">0 0 0</span><br><span class="line">// ANOTHER POSSIBLE RESULT:</span><br><span class="line">// 1 1 0</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>1&lt;=n,m&lt;=1e6 , 前3个点卡小错误，后面5个点卡效率，由于数据随机生成，可能会含有（ 10 0 10 0）之类的坑，但按照最常规写法的写的标程没有出错，各个数据点卡什么的提示在标程里。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><del>刚开始没看到 <strong>或</strong> 导致刚了半个小时出来全 WA……</del>，一道 2-SAT 模板题，题意大致是给定 m 组条件，给 n 个变量赋值使得每组条件中至少一个得到满足，那么假设 条件1 已经不满足了，则必须满足条件2，反之亦然，于是对于样例 <code>1 1 3 0</code> ，假设 $2i-1$ 和 $2i$ 分别表示第$i$ 个变量是 1 和 0 的情况，连接的有向边（必选边）就是 $4\to6$ 和 $5\to 1$ </p>
<p>最后按照染色方案输出就可以了</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000001*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 1000001*4</span></span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n,m,other[maxn],stk[maxn];</span><br><span class="line"><span class="type">bool</span> color[maxn];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v; nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(color[u]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(color[other[u]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	color[u]=<span class="number">1</span>; stk[++stk[<span class="number">0</span>]]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">DFS</span>(to[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">twoSAT</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(color[<span class="number">2</span>*i<span class="number">-1</span>] &amp;&amp; color[<span class="number">2</span>*i]) <span class="keyword">continue</span>;</span><br><span class="line">		stk[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">DFS</span>(<span class="number">2</span>*i<span class="number">-1</span>))&#123;</span><br><span class="line">			<span class="keyword">while</span>(stk[<span class="number">0</span>]) color[stk[stk[<span class="number">0</span>]]]=<span class="number">0</span>,stk[<span class="number">0</span>]--;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">DFS</span>(<span class="number">2</span>*i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m); <span class="type">int</span> x,y,z,w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&amp;<span class="number">1</span>) other[i]=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> other[i]=i<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2*i 表示 xi=0 ， 2*i-1 表示 xi=0  </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);<span class="built_in">fcin</span>(w);</span><br><span class="line">		x=y?<span class="number">2</span>*x<span class="number">-1</span>:<span class="number">2</span>*x; z=w?<span class="number">2</span>*z<span class="number">-1</span>:<span class="number">2</span>*z;</span><br><span class="line">		<span class="built_in">Eadd</span>(other[x],z); <span class="built_in">Eadd</span>(other[z],x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">twoSAT</span>()) <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;POSSIBLE\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(color[<span class="number">2</span>*i<span class="number">-1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="CQYZOJ-P2061：炸弹游戏"><a href="#CQYZOJ-P2061：炸弹游戏" class="headerlink" title="CQYZOJ_P2061：炸弹游戏"></a><a href="https://newoj.cqyz.cn/problem/P2061">CQYZOJ_P2061：炸弹游戏</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p> 给n对平面上的点，你可以在每对点中选择一个放置炸弹（不能同时都放），炸弹爆炸后所摧毁的区域是一个圆，且每个炸弹的摧毁区域的半径都一样。当然作为游戏者，你可以控制这个半径的大小。</p>
<p>现在请你确定这个半径的最大值，使得放完n个炸弹后，没有任何两个炸弹有重合的部分（注意相接不算相交）。  </p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数n，表示有n对顶点。接下来的n行，第i行表示第i对顶点的横纵坐标。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>一个保留两位小数的实数，表示炸弹爆炸的半径的最大值。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input #1"></a>Sample Input #1</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1 1 -1</span><br><span class="line">-1 -1 -1 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output #1"></a>Sample Output #1</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.41</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input #2"></a>Sample Input #2</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1 -1 -1</span><br><span class="line">1 -1 -1 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output #2"></a>Sample Output #2</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.00</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>2 &lt;= n &lt; 1000坐标为[-10000,10000]内的实数。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>做法：<strong>二分答案 + 2-SAT 验证可行性</strong></p>
<p>二分半径 R 之后，每次都跑 2-SAT 来判断当前半径 R 是否可取，可取则缩小 R 的范围，不可取则扩大 R 的范围直到 L 和 R 的差值可以忽略</p>
<p>建图的时候，<strong>考虑每两组之间的约束关系，用 A1，A2，B1，B2 表示两组中的四个炸弹，如果 A1 和 B1 爆炸范围相交（超过 $2\times R$）则只能选 B2，连接 $A_1\to B_2$，如果 A1 和 B2 爆炸范围相交则连接 $A_1 \to B_1$ 以此类推判断四次加边与否</strong> 就可以用 <strong>染色大法</strong> 尽情的 2-SAT 了</p>
<p>这道题起初较的时候 TLE 了，看到同学们都是 990ms+ 卡着时限过的，以为又是一道费优化的题目，<strong>然后做了一个小优化，把两点之间的距离存进二维数组就不用每次都去算一遍</strong></p>
<p>抱着能过就行的心态点了 Submit，结果跑了 272ms ??? <del>数组这么快的吗？？</del></p>
<p><img src="https://s2.ax1x.com/2019/06/28/ZMlIqf.png" alt="附图：测评记录"></p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1001*4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 1001*1001*4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e-7</span></span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n,m,other[maxn],stk[maxn];</span><br><span class="line"><span class="type">bool</span> color[maxn];</span><br><span class="line"><span class="type">double</span> dists[<span class="number">2002</span>][<span class="number">2002</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);&#125;</span><br><span class="line">	<span class="type">double</span> <span class="keyword">operator</span> -(<span class="type">const</span> node &amp;obj)<span class="type">const</span></span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">fabs</span>((<span class="type">double</span>)x-obj.x),<span class="number">2</span>)+<span class="built_in">pow</span>(<span class="built_in">fabs</span>((<span class="type">double</span>)y-obj.y),<span class="number">2</span>));&#125;</span><br><span class="line">&#125;b1[maxn],b2[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v; nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(color[u]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(color[other[u]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	color[u]=<span class="number">1</span>; stk[++stk[<span class="number">0</span>]]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">DFS</span>(to[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">twoSAT</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(color[<span class="number">2</span>*i<span class="number">-1</span>] &amp;&amp; color[<span class="number">2</span>*i]) <span class="keyword">continue</span>;</span><br><span class="line">		stk[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">DFS</span>(<span class="number">2</span>*i<span class="number">-1</span>))&#123;</span><br><span class="line">			<span class="keyword">while</span>(stk[<span class="number">0</span>]) color[stk[stk[<span class="number">0</span>]]]=<span class="number">0</span>,stk[<span class="number">0</span>]--;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">DFS</span>(<span class="number">2</span>*i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fcin</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&amp;<span class="number">1</span>) other[i]=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> other[i]=i<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		b1[i].<span class="built_in">init</span>(),b2[i].<span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">// 神乎其神的优化 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			dists[i][j]=dists[j][i]=b1[i]-b1[j],</span><br><span class="line">			dists[i][j+n]=dists[j+n][i]=b1[i]-b2[j],</span><br><span class="line">			dists[i+n][j]=dists[j][i+n]=b2[i]-b1[j],</span><br><span class="line">			dists[i+n][j+n]=dists[j+n][i+n]=b2[i]-b2[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cls</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 清除数据 </span></span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(color,<span class="literal">false</span>,<span class="built_in">sizeof</span>(color));stk[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 2*i-1 表示 b1[i] , 2*i 表示 b2[i] </span></span><br><span class="line">	<span class="type">double</span> L=<span class="number">0.0</span>,R=<span class="number">1000000.0</span>,ans=<span class="number">0.0</span>,mid;</span><br><span class="line">	 <span class="keyword">while</span>(R-L&gt;INF)&#123;</span><br><span class="line">	 	<span class="built_in">cls</span>(); mid=(L+R)/<span class="number">2.0</span>;</span><br><span class="line">	 	<span class="comment">// 建造 2-SAT 图 </span></span><br><span class="line">	 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	 		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">	 			<span class="keyword">if</span>(dists[i][j]&lt;<span class="number">2</span>*mid) <span class="built_in">Eadd</span>(<span class="number">2</span>*i<span class="number">-1</span>,<span class="number">2</span>*j),<span class="built_in">Eadd</span>(<span class="number">2</span>*j<span class="number">-1</span>,<span class="number">2</span>*i);</span><br><span class="line">	 			<span class="keyword">if</span>(dists[i][j+n]&lt;<span class="number">2</span>*mid) <span class="built_in">Eadd</span>(<span class="number">2</span>*i<span class="number">-1</span>,<span class="number">2</span>*j<span class="number">-1</span>),<span class="built_in">Eadd</span>(<span class="number">2</span>*j,<span class="number">2</span>*i);</span><br><span class="line">	 			<span class="keyword">if</span>(dists[i+n][j]&lt;<span class="number">2</span>*mid) <span class="built_in">Eadd</span>(<span class="number">2</span>*i,<span class="number">2</span>*j),<span class="built_in">Eadd</span>(<span class="number">2</span>*j<span class="number">-1</span>,<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">	 			<span class="keyword">if</span>(dists[i+n][j+n]&lt;<span class="number">2</span>*mid) <span class="built_in">Eadd</span>(<span class="number">2</span>*i,<span class="number">2</span>*j<span class="number">-1</span>),<span class="built_in">Eadd</span>(<span class="number">2</span>*j,<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">	 		&#125;</span><br><span class="line">	 	<span class="keyword">if</span>(<span class="built_in">twoSAT</span>()) ans=<span class="built_in">max</span>(ans,mid),L=mid;</span><br><span class="line">	 	<span class="keyword">else</span> R=mid;</span><br><span class="line">	 &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 二分图 | 二分图最大匹配  ：学习笔记</title>
    <url>/2019/07/09/2019-07-09-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>首先，回顾一下什么是二分图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1---4;</span><br><span class="line">2---5;2---6</span><br><span class="line">3---6</span><br></pre></td></tr></table></figure>
<p>图中的点能被分成两个集合，使得每一条边两端的点均分属于两个集合，判断二分图可以用 <strong>染色法</strong> 来解决，例如图中就可以取：${1,\;4}\quad{2,5}\quad{3,\;6}$</p>
<h3 id="二分图的最大匹配-1"><a href="#二分图的最大匹配-1" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><p>二分图的匹配，故名思义，就是寻找二分图中的一些点对，使得这些点对分属于二分图的两个集合，最大匹配，就是寻找最多能选择的点对的数量，<strong>上图中，最大匹配为 3</strong></p>
<p>解决最大匹配，可以用到 <strong>网络流</strong> 中的 <strong>费用流</strong> ，建立源点 S 和 汇点 T 跑费用流，还有一种著名的算法就是 <strong>匈牙利算法</strong></p>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h3><blockquote>
<p><strong>通过数代人的努力，你终于赶上了剩男剩女的大潮，假设你是一位光荣的新世纪媒人，在你的手上有N个剩男，M个剩女，每个人都可能对多名异性有好感（暂时不考虑特殊的性取向），如果一对男女互有好感，那么你就可以把这一对撮合在一起，现在让我们无视掉所有的单相思（好忧伤的感觉），你拥有的大概就是下面这样一张关系图，每一条连线都表示互有好感。</strong></p>
<p><strong>本着救人一命，胜造七级浮屠的原则，你想要尽可能地撮合更多的情侣，匈牙利算法的工作模式会教你这样做：</strong><sup><a href="#fn_摘自CSDN博客：算法讲解：二分图匹配【图论】" id="reffn_摘自CSDN博客：算法讲解：二分图匹配【图论】">摘自CSDN博客：算法讲解：二分图匹配【图论】</a></sup></p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20130503155150538" alt="pic"></p>
<p><strong>匈牙利算法的核心就是：发扬谦让精神</strong></p>
<ol>
<li><p>从男一开始，就是（男一，女一）第一组</p>
</li>
<li><p>给男二选择，发现女二没有被选择，（男二，女二）就是第二组</p>
</li>
<li><p>男三想选女一，但是女一已经被男一预定了，这时就需要男一 <strong>发扬谦让精神</strong> 了，把女一让给男三，自己选择女二，但是无奈女二又先被男二看上，男二也 <strong>发扬谦让精神</strong> 选择女三，这样三个男生都选择到了女生，情况变成下图（出现三组匹配）</p>
</li>
</ol>
<p><em>黄色边表示男生放弃的选择，蓝色边是当前的选择情况</em><code>cdea</code></p>
<p><img src="https://img-blog.csdn.net/20130503162147840" alt="pic2"></p>
<ol>
<li>最后考虑男四，男四想选女三，但是女三被男二选择，这是如果男二 <strong>发扬谦让精神</strong> 将会落单，男二要守住自己的底线，所以他没有谦让，导致男四最后落单</li>
</ol>
<p>完成上述四步之后，已经求出了二分图的最大匹配数为 3</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>用 $ref$ 数组表示右侧点当前对应的左侧点，用 DFS 递归为左侧点选择组合</p>
<p>$DFS(u)$ 表示第正在考虑点 $u$  的对应点，对于 $u$ 连接的每个点，判断是否已经有对应点，如果没有对应点（$ref=0$）就直接 $ref[to[i]]=u$ 更新，并且返回 true，否则需要递归 $ref[to[i]]$，看看 $ref[to[i]]$ 能不能改变组合，如果能则 $ref[to[i]=u]$ 更新</p>
<p>过程中若有一个点不能完成匹配，应该中止并且返回 false ，在主程序里枚举 $1\to n$ 的每个点，看能否增广，并且更新对应的 $ans$</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">			vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ref[to[i]] || <span class="built_in">dfs</span>(ref[to[i]]))&#123;</span><br><span class="line">				ref[to[i]]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>还是总结一些例题：</strong></p>
<h2 id="洛谷P2756-飞行员配对方案问题"><a href="#洛谷P2756-飞行员配对方案问题" class="headerlink" title="洛谷P2756 飞行员配对方案问题"></a><a href="https://www.luogu.org/problemnew/show/P2756">洛谷P2756 飞行员配对方案问题</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1  名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。</p>
<p>对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第 1 行有 2 个正整数 m 和 n。n 是皇家空军的飞行员总数(n&lt;100)；m 是外籍飞行员数(m&lt;=n)。外籍飞行员编号为 1~m；英国飞行员编号为 m+1~n。</p>
<p>接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。最后以 2个-1 结束。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。接下来 M 行是最佳飞行员配对方案。每行有 2个正整数 i 和 j，表示在最佳飞行员配对方案中，飞行员 i 和飞行员 j 配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">1 7</span><br><span class="line">1 8</span><br><span class="line">2 6</span><br><span class="line">2 9</span><br><span class="line">2 10</span><br><span class="line">3 7</span><br><span class="line">3 8</span><br><span class="line">4 7</span><br><span class="line">4 8</span><br><span class="line">5 10</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 7</span><br><span class="line">2 9</span><br><span class="line">3 8</span><br><span class="line">5 10 </span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>No Hint</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>典型的二分图最大匹配判定，图中的左侧点就是编号 $1\to m$ 的点，右侧点就是编号 $(m+1)\to n$ 的点，直接跑一遍匈牙利算法就可以，按照 $ref$ 里面的内容输出方案</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匈牙利算法  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2019</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> ref[maxn];<span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	to[++tot]=y; nxt[tot]=head[x];</span><br><span class="line">	head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">			vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ref[to[i]] || <span class="built_in">dfs</span>(ref[to[i]]))&#123;</span><br><span class="line">				ref[to[i]]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(m);<span class="built_in">fcin</span>(n); <span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">-1</span> &amp;&amp; y!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y);<span class="built_in">Eadd</span>(y,x);</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">	&#125; <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!ans) <span class="built_in">printf</span>(<span class="string">&quot;No Solution!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=m+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(ref[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ref[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CQYZOJ-Contest-181-Pro-02-棋盘覆盖"><a href="#CQYZOJ-Contest-181-Pro-02-棋盘覆盖" class="headerlink" title="CQYZOJ_Contest:181_Pro:02 棋盘覆盖"></a><a href="https://newoj.cqyz.cn/contest/181/problem/P02">CQYZOJ_Contest:181_Pro:02 棋盘覆盖</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>给出一张n*n (n&lt;=100)的国际象棋棋盘，其中被删除了一些点，问可以使用多少1*2的多米诺骨牌进行掩盖。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行为n，m（表示有m个删除的格子）</p>
<p>第二行到m+1行为x,y，分别表示删除格子所在的位置</p>
<p>x为第x行，y为第y列</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>一个数，即最大覆盖格数</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">8 0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>No Hint</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>一个格子（x，y）可以与它上下左右的相邻四个格子构成 $1\times 2$ 的形状从而被覆盖，那么对于任意一个格子，就先将其编号之后与上下左右四个相邻格子连一条有向边（被删除的点除外）</p>
<p>接下来如何把二分图匹配的思想和这道题联系起来呢？考虑将棋盘按照黑白相间的方式染色：</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1562681175899&amp;di=72d978fe1e31b8f83a24aaf9ef166a81&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F9fo3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F9922720e0cf3d7ca91445f40f01fbe096b63a952.jpg" alt="pic3"></p>
<p>可以发现，<strong>一个格子和它四周的四个格子总是分属于黑或白两个集合，但是我们又要将他们连接起来，也就是将黑和白集合里面的元素配对，求最大的配对数量</strong>，一个二分图匹配解决问题的思路就浮出水面了，建图之后直接套模板解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 400001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> id(x,y) ((x-1)*m+y)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> offx[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,offy[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,tot,k; <span class="type">bool</span> del[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> ref[maxn]; <span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	to[++tot]=y; nxt[tot]=head[x];</span><br><span class="line">	head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">			vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ref[to[i]] || <span class="built_in">dfs</span>(ref[to[i]]))&#123;</span><br><span class="line">				ref[to[i]]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> dx,dy; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(del[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">					<span class="keyword">if</span>(!del[k][y] &amp;&amp; k!=x) <span class="built_in">Eadd</span>(<span class="built_in">id</span>(x,y),<span class="built_in">id</span>(k,y));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">					<span class="keyword">if</span>(!del[x][k] &amp;&amp; k!=y) <span class="built_in">Eadd</span>(<span class="built_in">id</span>(x,y),<span class="built_in">id</span>(x,k));</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;qpfg.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;qpfg.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="built_in">fcin</span>(k); <span class="type">int</span> dx,dy;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(dx);<span class="built_in">fcin</span>(dy);</span><br><span class="line">		del[dx][dy]=<span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="built_in">build</span>(); <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote id="fn_摘自CSDN博客：算法讲解：二分图匹配【图论】">
<sup>摘自CSDN博客：算法讲解：二分图匹配【图论】</sup>. <a href="https://blog.csdn.net/qq_41730082/article/details/81162561">https://blog.csdn.net/qq_41730082/article/details/81162561</a><a href="#reffn_摘自CSDN博客：算法讲解：二分图匹配【图论】" title="Jump back to footnote [摘自CSDN博客：算法讲解：二分图匹配【图论】] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 | 最小生成树 | 动态规划 |  \ 线段树 | 主席树 | 20190710考试：解题  报告</title>
    <url>/2019/07/10/2019-07-10-0710%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">内存限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">抓蛇 Snake</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$256$ MB</td>
</tr>
<tr>
<td style="text-align:center">分组行走 Walk</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$512$ MB</td>
</tr>
<tr>
<td style="text-align:center">谈笑风生 Talk</td>
<td style="text-align:center">$2000$ MS</td>
<td style="text-align:center">$512$ MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Problem-1-抓蛇-Snake"><a href="#Problem-1-抓蛇-Snake" class="headerlink" title="Problem#1.    抓蛇 Snake"></a><a href="https://www.luogu.org/problemnew/show/P5424">Problem#1.    抓蛇 Snake</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>传说，数千年前圣帕特里克消灭了哞尔兰所有的蛇。然而，蛇们现在卷土重来了！圣帕特里克节是在每年的3月17日，所以小明要用彻底清除哞尔兰所有的蛇来纪念圣帕特里克。小明装备了一个捕网，用来捕捉N组排成一行的蛇（1≤N≤400）。小明必须按照这些组在这一行中出现的顺序捕捉每一组的所有蛇。每当小明抓完一组蛇之后，她就会将蛇放在笼子里，然后带着空的捕网开始捕捉下一组。</p>
<p>一个大小为s的捕网意味着小明可以抓住任意包含g条的一组蛇，其中g≤s。然而，每当小明用大小为s的捕网抓住了一组g条蛇，就意味着浪费了s−g的空间。小明可以任意设定捕网的初始大小，并且她可以改变K次捕网大小（1≤K&lt;N）。</p>
<p>请告诉小明她捕捉完所有组的蛇之后可以达到的总浪费空间的最小值。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含N和K。第二行包含N个整数a1,…,aN，其中ai（0≤ai≤10^6）为第i组蛇的数量。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，为小明抓住所有蛇的总浪费空间的最小值。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6 2</span><br><span class="line">7 9 8 2 3 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>小明可以设置她的捕网开始时大小为7。当她抓完第一组蛇之后，她将她的捕网的大小调整为9，保持这个大小直到抓完第4组蛇，再将捕网大小调整为3。总浪费空间为 (7−7)+(9−9)+(9−8)+(3−2)+(3−3)+(3−2)=3。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：DP，空间二维 + $O(n^3)$ 时间复杂度</strong></p>
</blockquote>
<p>设 $f[i][j]$ 表示抓到第 $i$ 组蛇，并且改变了 $j$ 次网的大小的最小的浪费空间，则转移方程为：</p>
<p>$f[i][j]=min(f[i][j],\;f[k][j-1]+r[k+1][i])$</p>
<p>其中 $k$ 是枚举的中转点，$r[k+1][j]$ 表示 $[k+1,\;j]$ 这段区间内剩余空间的最小值，$r[k+1][j]$ 可以用这段区间内的最大元素 $max[k+1][j]$ 减去每个元素累加得到，进一步化简就是：</p>
<p>$r[k+1][j]=max[k+1][j]\times(j-(k+1)+1)-sum[k+1][j]$ ，其中 $sum[k+1][j]$ 为区间和</p>
<p>由于 $max[i][j]$，$sum[i][j]$，$r[i][j]$ 都可以通过预处理得到，所以它们的时间复杂度可以忽略不计</p>
<blockquote>
<p><strong>做法二：DP，空间三维 + $O(n^3)$ 时间复杂度 + 滚动优化</strong></p>
</blockquote>
<p>设 $f[i][j][k]$ 表示表示抓到第 $i$ 组蛇，并且改变了 $j$ 次网的大小，现在的网的大小为 $a[k]$ 的最小浪费，则转移方程为：</p>
<p>$f[i][j][k]=min(f[i][j][k]，f[i-1][j-1][k’])+a[k]-a[i]\quad(k’\in[1，n]，a[k]\geq a[i])$ </p>
<p>这种方法是考试的时候写的，很容易想到的一个思路，虽然小明每次改变网大小的时候可以任意，但是直接改变成某一组蛇的数量显然是最明智的选择</p>
<p>算法看上去像是 $O(n^4)$ 的时间复杂度，<strong>然而注意到 $f[i-1][j-1][k]$ 一遍for 循环算完之后不会再算了，于是我用了一个 $f[i][j][0]$ 存储 $min{f[i][j][k]，k\in[1，n]}$ 好像就能把时间提升到 $O(n^3)$ 的水平（相当于预处理吧）</strong></p>
<p>最后加一个滚动优化就能 2MB 过了（原题的空间限制为 $128$ MB，不是 $256$ MB）</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 401</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][maxn][maxn];</span><br><span class="line"><span class="type">int</span> a[maxn],n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;snake.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;snake.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(k);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">127</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">fcin</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;=a[<span class="number">1</span>]) f[<span class="number">1</span>][<span class="number">0</span>][i]=a[i]-a[<span class="number">1</span>];</span><br><span class="line">		f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">0</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f[i&amp;<span class="number">1</span>],<span class="number">127</span>,<span class="built_in">sizeof</span>(f[i&amp;<span class="number">1</span>]));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;p++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[p]&lt;a[i]) <span class="keyword">continue</span>;</span><br><span class="line">			f[i&amp;<span class="number">1</span>][j][p]=<span class="built_in">min</span>(f[i&amp;<span class="number">1</span>][j][p],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][p]+a[p]-a[i]);</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=<span class="number">1</span>) f[i&amp;<span class="number">1</span>][j][p]=<span class="built_in">min</span>(f[i&amp;<span class="number">1</span>][j][p],f[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+a[p]-a[i]);</span><br><span class="line">			f[i&amp;<span class="number">1</span>][j][<span class="number">0</span>]=<span class="built_in">min</span>(f[i&amp;<span class="number">1</span>][j][<span class="number">0</span>],f[i&amp;<span class="number">1</span>][j][p]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n&amp;<span class="number">1</span>][k][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Problem-2-分组行走-walk"><a href="#Problem-2-分组行走-walk" class="headerlink" title="Problem#2.    分组行走 walk"></a><a href="https://www.luogu.org/problemnew/show/P5425">Problem#2.    分组行走 walk</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>小明喜欢养宠物，想要将编号为1…N的N只宠物（N≤7500）分为非空的K组（2≤K≤N），使得任意两只来自不同组的宠物都需要走一定的距离才能相遇。宠物x和宠物y（其中1≤x&lt;y≤N）愿意为了见面走 (2019201913x+2019201949y) mod 2019201997英里。给定一个将N只宠物分为K个非空小组的分组方案，令M为任意两头来自不同组的宠物愿意为了见面行走的英里数的最小值。为了测试宠物们相互之间的忠诚度，小明想要将N头宠物以最佳的方式分为K组，使得M尽可能大。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>输入仅有一行，包含N和K，用空格分隔。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出最优的M。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2019201769</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>在这个例子中，宠物1和宠物2愿意为了见面走2019201817英里。宠物2和宠物3愿意走2019201685英里。宠物1和宠物3愿意走2019201769英里。所以，将宠物1单独分为一组，宠物2和宠物3分为一组，M=min(2019201817,2019201769)=2019201769（这是我们在这个问题中能够达到的最佳结果）。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>常规思路 #1.    最小生成树</strong></p>
</blockquote>
<p>考虑将每一对宠物 $(x，y)(x&lt;y)$ 的距离计算出来并算成一条无向边，那么划分出 K 个集合之后，原本连通的图会出现 K 个连通支，那么问题就转化为：<strong>找到一个最小的 $d<em>{min}$，使得去掉权值大于$d</em>{min}$ 的边之后，原图被分为 K 个连通支</strong></p>
<p>那么此题的思路就和<a href="http://wuyanxi.top/%E9%A2%98%E7%9B%AE/2019/03/22/%E5%8C%97%E6%9E%81%E9%80%9A%E8%AE%AF%E7%BD%91%E7%BB%9C.html">北极通讯网络</a> 一模一样了，注意到 $N\leq7500$，意味着加入的边数为 $N\times (N-1)$ 会达到一个巨大的数量级，此时进行 Kruskal 的排序操作会消耗很多时间，所以求最小生成树的时候可以采用 Prim 算法</p>
<blockquote>
<p><strong>进阶思路 #2.    贪心<em>（By <a href="https://www.luogu.org/blog/108191/">LTX</a>）</em></strong></p>
</blockquote>
<p>设 $f(x)=min{dist(i,x)，i\in [1，n]，i\neq x}$，即为 $x$ 与其他宠物之间的最短距离</p>
<p><strong>同上述最小生成树的思想有着相似之处，答案为第 $n-k+1$ 大的 $f(x)$ 值</strong></p>
<blockquote>
<p><strong>进阶思路 #3.    找规律</strong></p>
</blockquote>
<p>设 $P=2019201997$，则 $d(x,y)=((P-84)x+(P-48)y)\mod P$</p>
<p>化简：$((P-84)x+(P-48)y)\mod P \Leftrightarrow ((-84x-48y)\mod P+P)\mod P$ </p>
<p>由于$x&lt;y\leq7500$ ，所以认为 $(-84x-48y)\mod P=-84x-48y+P$</p>
<p><strong>则原式：$D=-84x-48y+P$，可以发现，要使 $D$ 尽量大，就是让 $x$ 尽量小，由于选出了非空 $K$ 组，把 $1\to K-1$ 的每个元素独自成组，然后 $K\to N$ 的元素分成一组</strong></p>
<p>那么答案就是 $D=-84x-48y+P$ ，时间复杂度仅仅 $O(1)$</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 7502</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*(maxn-1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pets</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((ll)<span class="number">2019201913</span>*x+(ll)<span class="number">2019201949</span>*y)%<span class="number">2019201997</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;walk.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;walk.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">pets</span>(k<span class="number">-1</span>,n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Problem-3-谈笑风生-talk"><a href="#Problem-3-谈笑风生-talk" class="headerlink" title="Problem#3.    谈笑风生 talk"></a><a href="https://www.luogu.org/problemnew/show/P3899">Problem#3.    谈笑风生 talk</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>设 T 为一棵有根树，我们做如下的定义：</p>
<p>• 设 a 和 b 为 T 中的两个不同节点。如果 a 是 b 的祖先，那么称“a 比 b 不知道高明到哪里去了”。</p>
<p>• 设 a 和 b 为 T 中的两个不同节点。如果 a 与 b 在树上的距离不超过某个给定常数 x，那么称“a 与 b 谈笑风生”。</p>
<p>给定一棵 n 个节点的有根树 T，节点的编号为 1 ∼ n，根节点为 1 号节点。你需要回答 q 个询问，询问给定两个整数 p 和 k，问有多少个有序三元组 (a; b; c) 满足：</p>
<ol>
<li>a、 b 和 c 为 T 中三个不同的点，且 a 为 p 号节点；</li>
<li>a 和 b 都比 c 不知道高明到哪里去了；</li>
<li>a 和 b 谈笑风生。这里谈笑风生中的常数为给定的 k。</li>
</ol>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>输入文件的第一行含有两个正整数 n 和 q，分别代表有根树的点数与询问的个数。</p>
<p>接下来 n − 1 行，每行描述一条树上的边。每行含有两个整数 u 和 v，代表在节点 u 和 v 之间有一条边。</p>
<p>接下来 q 行，每行描述一个操作。第 i 行含有两个整数，分别表示第 i 个询问的 p 和 k。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>输出 q 行，每行对应一个询问，代表询问的答案。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">4 5</span><br><span class="line">2 2</span><br><span class="line">4 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>样例中的树如下图所示：</p>
<p><img src="https://cdn.luogu.org/upload/pic/6858.png" alt="pic"></p>
<p>对于第一个和第三个询问，合法的三元组有 (2,1,4)、 (2,1,5) 和 (2,4,5)。</p>
<p>对于第二个询问，合法的三元组只有 (4,2,5)。</p>
<p>所有测试点的数据规模如下：</p>
<p><img src="https://cdn.luogu.org/upload/pic/6859.png" alt="pic2"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>显然如果b在a上面可以直接算</p>
<p>考虑在a子树中的情况</p>
<p>由于要求的答案是一个深度连续的区间,考虑以深度为下标建主席树</p>
<p>将每个点的贡献size[i]-1依次插入主席树</p>
<p>直接查一个点子树就可以了</p>
</blockquote>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn (300001*10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm (maxn*2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> newp,root[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TT</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TTNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> LC,RC; ll VAL;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> val(x) T[x].VAL</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1) </span></span><br><span class="line">	&#125;T[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> pos,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		x=++newp;<span class="built_in">val</span>(x)=<span class="built_in">val</span>(y)+d;</span><br><span class="line">		<span class="keyword">if</span>(L==R) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">lc</span>(x)=<span class="built_in">lc</span>(y);<span class="built_in">rc</span>(x)=<span class="built_in">rc</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">init</span>(<span class="built_in">lc</span>(x),<span class="built_in">lc</span>(y),L,mid,pos,d);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">init</span>(<span class="built_in">rc</span>(x),<span class="built_in">rc</span>(y),mid+<span class="number">1</span>,R,pos,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">res</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>; y=(y&gt;R)?R:y;</span><br><span class="line">		<span class="keyword">if</span>(x==L &amp;&amp; y==R) <span class="keyword">return</span> <span class="built_in">val</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(y&lt;=mid) <span class="keyword">return</span> <span class="built_in">res</span>(<span class="built_in">lc</span>(k),L,mid,x,y);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;mid) <span class="keyword">return</span> <span class="built_in">res</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">res</span>(<span class="built_in">lc</span>(k),L,mid,x,mid)+<span class="built_in">res</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,mid+<span class="number">1</span>,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;st;<span class="type">int</span> ref[maxn],dep[maxn],siz[maxn];</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n,s,dfn,ld[maxn],rd[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123;</span><br><span class="line">	ld[u]=++dfn;ref[dfn]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fu)&#123;</span><br><span class="line">			dep[to[i]]=dep[u]+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(to[i],u);siz[u]+=siz[to[i]]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	rd[u]=dfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;talk.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;talk.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(s);<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y);<span class="built_in">Eadd</span>(y,x);</span><br><span class="line">	&#125; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>); ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dep[<span class="number">0</span>]=<span class="built_in">max</span>(dep[<span class="number">0</span>],dep[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		st.<span class="built_in">init</span>(root[i],root[i<span class="number">-1</span>],<span class="number">0</span>,dep[<span class="number">0</span>],dep[ref[i]],siz[ref[i]]);</span><br><span class="line">	<span class="keyword">while</span>(s--)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);ans=<span class="number">0</span>;</span><br><span class="line">		ans+=(ll)siz[x]*<span class="built_in">min</span>(dep[x],y);</span><br><span class="line">		ans+=st.<span class="built_in">res</span>(root[rd[x]],<span class="number">0</span>,dep[<span class="number">0</span>],dep[x]+<span class="number">1</span>,dep[x]+y);</span><br><span class="line">		ans-=st.<span class="built_in">res</span>(root[ld[x]<span class="number">-1</span>],<span class="number">0</span>,dep[<span class="number">0</span>],dep[x]+<span class="number">1</span>,dep[x]+y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分 | 线段树 | 树链剖分：  学习笔记</title>
    <url>/2019/06/05/2019-06-05-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86Notes/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p><strong>树链剖分解决的主要是树上的区间修改，区间查询问题</strong>，其本质就相当于把线段树的操作从连续的序列移动到了一棵树上，当然操作的区间 $[L,\;R]$ 就变成了树上的点 $(u\,\;v)$ ，以下问题可以用树剖解决：</p>
<ul>
<li><p>将树上两点 $(u,\;v)$ 之间的所有点权值加上 $\delta$</p>
</li>
<li><p>询问 $\sum^{v}_{i=u}w[i]$，表示从 $u$ 到 $v$ 的唯一路径上的所有点权值之和</p>
</li>
<li><p>询问 $max\lbrace w[i]\;\;\; i\in\lbrace u,\;v \rbrace \rbrace$，表示询问 $u$ 到 $v$ 的唯一路径上的点权最大（最小亦同）</p>
</li>
</ul>
<p>从上述问题中可以看出，<strong>树链剖分着力于树上的区间问题，常常是点区间问题</strong>（当然你也可以用去单点修改），因此，<strong>树链剖分需要配合线段树使用</strong></p>
<p>但是普通的区间线段树针对的是连续的序列，<strong>对于一棵静态的树，需要把他的结点编排成有序的序列，使得每棵子树的根结点与他的所有儿子（直接儿子 &amp; 隔代儿子）构成连续的序列关系</strong>，这就是树链剖分的工作所在了 </p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在解剖一棵树前，需要做些准备工作</p>
<ol>
<li><strong>重儿子</strong>：结点的重儿子定义为结点的直接儿子中，子树大小最大的那一个结点</li>
</ol>
<ul>
<li>对于儿子们的子树大小相等的情况，随意取一个作为重儿子即可，不会造成影响</li>
</ul>
<ol>
<li><strong>轻儿子</strong>：除去重儿子之外的其他直接儿子</li>
<li><strong>重边</strong>：结点与他的重儿子之间的边</li>
<li><strong>轻边</strong>：结点与他的轻儿子之间的边</li>
<li><strong>深度</strong>：根结点到这个结点的结点个数（包括根结点和他自己）</li>
</ol>
<p>还需要计算的是：</p>
<ol>
<li><strong>子树大小</strong>（包括子树的根结点）</li>
<li><strong>TOP 值</strong>：记录的是当前结点所在重边的起点（轻儿子的 TOP 值是他自己的编号）</li>
</ol>
<p>树链剖分其实就是将树上的所有边分成轻边和重边两个集合的过程，需要两次 DFS 来实现</p>
<h2 id="计算和预处理"><a href="#计算和预处理" class="headerlink" title="计算和预处理"></a>计算和预处理</h2><p>预处理出上面的 7 个值，需要跑两次 DFS，<strong>跑 DFS 时一定要确定根结点</strong>（没有也要乱找一个）</p>
<h3 id="第一次-DFS：计算前面-6-个值"><a href="#第一次-DFS：计算前面-6-个值" class="headerlink" title="第一次 DFS：计算前面 6 个值"></a>第一次 DFS：计算前面 6 个值</h3><p>轻边和重边其实只是概念，无需存在程序中，这一遍 DFS 求出结点的轻重儿子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; <span class="type">int</span> maxsize=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!dep[to[i]])&#123;</span><br><span class="line">			dep[to[i]]=dep[u]+<span class="number">1</span>; </span><br><span class="line">			<span class="built_in">DFS</span>(to[i]); </span><br><span class="line">			siz[u]+=siz[to[i]]; fa[to[i]]=u;</span><br><span class="line">			<span class="keyword">if</span>(siz[to[i]]&gt;maxsize)&#123;</span><br><span class="line">				maxsize=siz[to[i]];</span><br><span class="line">				Xson[u]=to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二次-DFS：计算-TOP-值"><a href="#第二次-DFS：计算-TOP-值" class="headerlink" title="第二次 DFS：计算 TOP 值"></a>第二次 DFS：计算 TOP 值</h3><p>画个图就很容易发现，每个结点的 TOP 值都等于他父亲结点的 TOP 值，注意重儿子先访问，轻儿子后访问，TOP 值是他自己的编号，这一步可以顺便把每个结点的 DFS 序存下来，这个 DFS 序就是线段树来做区间操作的根据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> TOP)</span></span>&#123;</span><br><span class="line">	id[u]=++ids;</span><br><span class="line">	top[u]=TOP;</span><br><span class="line">	<span class="keyword">if</span>(siz[u]==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS</span>(Xson[u],TOP);<span class="comment">// 优先走重儿子  </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=Xson[u] &amp;&amp; fa[u]!=to[i])</span><br><span class="line">			<span class="built_in">DFS</span>(to[i],to[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与线段树的配合"><a href="#与线段树的配合" class="headerlink" title="与线段树的配合"></a>与线段树的配合</h3><p>树链剖分能将树上的点结合线段树来做区间操作，就在于剖分出轻重儿子后，得到的树的 DFS 序将是一个有趣的序列，如下图，加粗的边是重边：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">1---2;2===4;2---5;</span><br><span class="line">1===3;3---6;3===7;7===8</span><br></pre></td></tr></table></figure>
<p>如果沿着<strong>先重边，再轻边</strong>的方式遍历，就会得到这样的 DFS 序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">d1((&quot;1,1&quot;));d3((&quot;3,2&quot;));d7((&quot;7,3&quot;))</span><br><span class="line">d8((&quot;8,4&quot;));d6((&quot;6,5&quot;));d2((&quot;2,6&quot;))</span><br><span class="line">d4((&quot;4,7&quot;));d5((&quot;5,8&quot;))</span><br><span class="line">d1---d2;d1===d3;</span><br><span class="line">d2---d5;d2===d4;d3===d7;</span><br><span class="line">d3---d6; d7===d8</span><br></pre></td></tr></table></figure>
<p>逗号两边分别是 结点编号 和 DFS序，现在来看，如果想要修改以 3 为根结点的子树，将子树里的结点权值加上 d，那么就相当于在序列中修改了 (2,5) 的连续和，注意到 2 是结点 3 的 DFS序，而 5=2+4-1，于是可以得出，一个子树的根结点 $K$ 和子树代表的连续区间为：$[K,\;K+size(K)-1]$，这样树链剖分就和线段树联系了起来</p>
<h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>树链剖分的修改操作可以分为 <strong>绝对路径点权修改</strong> 和 <strong>子树点权修改</strong></p>
<h3 id="修改-u-v-绝对路径上的点权值"><a href="#修改-u-v-绝对路径上的点权值" class="headerlink" title="修改 $(u,v)$ 绝对路径上的点权值"></a>修改 $(u,v)$ 绝对路径上的点权值</h3><p>经过树链剖分可以发现，<strong>在同一条重链上的点，它们的 TOP 值相同，更重要的是他们的 DFS 序是连续的，深度更深的点的 DFS 序是连续区间的右端点，深度更浅的点的 DFS 序是左端点</strong>，因此如果遇到 $u,\;v$ 的 TOP 值一样了，直接线段树区间修改就完事</p>
<p>如果 $u,\;v$ 的 TOP 值不一样，就要让 $u,\;v$ 向上跳，直到 TOP 值一样，在 $u$ 或 $v$ 向上跳的时候，可以把 $TOP(u)$ 和 $u$ 形成的链进行区间更新，之后再让 $u$ 跳到 $father(TOP(u))$ （ $v$ 也是一样）进行比较，直到 $u,\;v$ 的 TOP 值一样</p>
<p>然而这种方法如果遇到一棵轻重儿子交替出现在一条链上的树时，时间复杂度就将退化到朴素的单点更新，所以说树链剖分本质上还是暴力<del>（只不过稍微优雅了一点）</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pathadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dt)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 将 x-&gt;y 最短路径上的点权值都加上 d </span></span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		SST.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],dt);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	SST.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x],dt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改-u-的子树的结点权值"><a href="#修改-u-的子树的结点权值" class="headerlink" title="修改 $u$ 的子树的结点权值"></a>修改 $u$ 的子树的结点权值</h3><p>经过上面的分析，一经发现 $u$ 和他的子树中的所有结点有着连续的 DFS 序，因此直接线段树区间修改完事</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+siz[x]<span class="number">-1</span>,z);</span><br></pre></td></tr></table></figure>
<h2 id="询问操作"><a href="#询问操作" class="headerlink" title="询问操作"></a>询问操作</h2><p>写完了修改操作，询问操作自然水到渠成</p>
<h3 id="询问-u-v-绝对路径上的点权值和"><a href="#询问-u-v-绝对路径上的点权值和" class="headerlink" title="询问 $(u,v)$ 绝对路径上的点权值和"></a>询问 $(u,v)$ 绝对路径上的点权值和</h3><p>SST 在代码中表示用结构体定义的线段树，支持区间修改 &amp; 区间求和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pathsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 返回 x-&gt; y 的最短路径上的点权值和 </span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		ret+=SST.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ret+=SST.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x]);</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改-u-的子树的结点权值和"><a href="#修改-u-的子树的结点权值和" class="headerlink" title="修改 $u$ 的子树的结点权值和"></a>修改 $u$ 的子树的结点权值和</h3><p>SST 在代码中表示用结构体定义的线段树，支持区间修改 &amp; 区间求和（再说一遍）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SST.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+siz[x]<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="例题1：洛谷P3384【模板】树链剖分"><a href="#例题1：洛谷P3384【模板】树链剖分" class="headerlink" title="例题1：洛谷P3384【模板】树链剖分"></a>例题1：<a href="https://www.luogu.org/problemnew/show/P3384"><strong>洛谷P3384【模板】树链剖分</strong></a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：</p>
<p>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</p>
<p>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</p>
<p>操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z</p>
<p>操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含4个正整数N、M、R、P，分别表示树的结点个数、操作个数、根节点序号和取模数（<strong>即所有的输出结果均对此取模</strong>）。</p>
<p>接下来一行包含N个非负整数，分别依次表示各个节点上初始的数值。</p>
<p>接下来N-1行每行包含两个整数x、y，表示点x和点y之间连有一条边（保证无环且连通）</p>
<p>接下来M行每行包含若干个正整数，每行表示一个操作，格式如下：</p>
<p>操作1： 1 x y z</p>
<p>操作2： 2 x y</p>
<p>操作3： 3 x z</p>
<p>操作4： 4 x</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出包含若干行，分别依次表示每个操作2或操作4所得的结果（<strong>对P取模</strong>）</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 5 2 24</span><br><span class="line">7 3 7 8 0 </span><br><span class="line">1 2</span><br><span class="line">1 5</span><br><span class="line">3 1</span><br><span class="line">4 1</span><br><span class="line">3 4 2</span><br><span class="line">3 2 2</span><br><span class="line">4 5</span><br><span class="line">1 5 1 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>时空限制：1s，128M</p>
<p>数据规模：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">百分比</th>
<th style="text-align:center">N</th>
<th style="text-align:center">M</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>30%</strong></td>
<td style="text-align:center">$\leq 10$</td>
<td style="text-align:center">$\leq 10$</td>
</tr>
<tr>
<td style="text-align:center"><strong>70%</strong></td>
<td style="text-align:center">$\leq 10^3$</td>
<td style="text-align:center">$\leq 10^3$</td>
</tr>
<tr>
<td style="text-align:center"><strong>100%</strong></td>
<td style="text-align:center">$\leq 10^5$</td>
<td style="text-align:center">$\leq 10^5$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>板子题，直接套上模板解决即可</p>
<p><strong>注意取模的时候不能只在线段树外部取模，内部凡是涉及到加法的时候都要取模</strong></p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 洛谷 P3384 树链剖分 模板  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,root,mod,ids;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegSumTree</span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SegSumTreeNode</span>&#123;</span><br><span class="line">		ll V; <span class="type">int</span> LC,RC;</span><br><span class="line">		ll TAG;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> val(x) T[x].V</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> tag(x) T[x].TAG</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">	&#125;T[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> nodes;</span><br><span class="line">	<span class="type">int</span> Tr[maxn];</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">		<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">		x*=sign;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="built_in">val</span>(k)=<span class="built_in">val</span>(<span class="built_in">lc</span>(k))+<span class="built_in">val</span>(<span class="built_in">rc</span>(k));&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Spr</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="built_in">tag</span>(k)+=d; <span class="built_in">val</span>(k)+=(R-L+<span class="number">1</span>)*(ll)d;</span><br><span class="line">		<span class="built_in">tag</span>(k)%=mod; <span class="built_in">val</span>(k)%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">tag</span>(k)==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">Spr</span>(<span class="built_in">lc</span>(k),L,mid,<span class="built_in">tag</span>(k));</span><br><span class="line">		<span class="built_in">Spr</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,<span class="built_in">tag</span>(k));</span><br><span class="line">		<span class="built_in">tag</span>(k)=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">		nodes=<span class="number">0</span>;<span class="built_in">build</span>(<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> now=++nodes;</span><br><span class="line">		<span class="keyword">if</span>(L==R) &#123;<span class="built_in">val</span>(now)=Tr[L];<span class="keyword">return</span> now;&#125;</span><br><span class="line">		<span class="built_in">lc</span>(now)=<span class="built_in">build</span>(L,mid);	</span><br><span class="line">		<span class="built_in">rc</span>(now)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">		<span class="keyword">return</span> now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">Spr</span>(k,L,R,d);</span><br><span class="line">		<span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">		<span class="keyword">if</span>(mid&gt;=x) <span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,y,d);</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;y) <span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y,d);</span><br><span class="line">		<span class="built_in">pushup</span>(k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">SegSum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">val</span>(k);</span><br><span class="line">		<span class="built_in">pushdown</span>(k,L,R); ll sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid&gt;=x) sum+=<span class="built_in">SegSum</span>(<span class="built_in">lc</span>(k),L,mid,x,y),sum%=mod;</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;y) sum+=<span class="built_in">SegSum</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y),sum%=mod;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">SegSumTree SST;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn],siz[maxn],id[maxn]; <span class="comment">// id 存新编号  </span></span><br><span class="line"><span class="type">int</span> w[maxn],Xson[maxn],dep[maxn],fa[maxn],top[maxn],tot;<span class="comment">// 注意这里是点权值，不是边权值  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; <span class="type">int</span> maxsize=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!dep[to[i]])&#123;</span><br><span class="line">			dep[to[i]]=dep[u]+<span class="number">1</span>; <span class="built_in">DFS</span>(to[i]);</span><br><span class="line">			siz[u]+=siz[to[i]]; fa[to[i]]=u;</span><br><span class="line">			<span class="keyword">if</span>(siz[to[i]]&gt;maxsize)&#123;</span><br><span class="line">				maxsize=siz[to[i]];</span><br><span class="line">				Xson[u]=to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> TOP)</span></span>&#123;</span><br><span class="line">	id[u]=++ids; SST.Tr[ids]=w[u];</span><br><span class="line">	top[u]=TOP;</span><br><span class="line">	<span class="keyword">if</span>(siz[u]==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS</span>(Xson[u],TOP);<span class="comment">// 优先走重儿子  </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=Xson[u] &amp;&amp; fa[u]!=to[i])</span><br><span class="line">			<span class="built_in">DFS</span>(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	nxt[++tot]=head[u];</span><br><span class="line">	to[tot]=v; head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pathadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dt)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 将 x-&gt;y 最短路径上的点权值都加上 d </span></span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		SST.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],dt);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	SST.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x],dt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pathsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 返回 x-&gt; y 的最短路径上的点权值和 </span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		ret+=SST.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);</span><br><span class="line">		ret%=mod; x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ret+=SST.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x]);</span><br><span class="line">	<span class="keyword">return</span> ret%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	SST.<span class="built_in">fcin</span>(n); SST.<span class="built_in">fcin</span>(m);</span><br><span class="line">	SST.<span class="built_in">fcin</span>(root); SST.<span class="built_in">fcin</span>(mod);</span><br><span class="line">	<span class="type">int</span> x,y,z,op;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) SST.<span class="built_in">fcin</span>(w[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		SST.<span class="built_in">fcin</span>(x);SST.<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y);<span class="built_in">Eadd</span>(y,x);</span><br><span class="line">	&#125; dep[root]=<span class="number">1</span>; <span class="built_in">DFS</span>(root); </span><br><span class="line">	<span class="built_in">DFS</span>(root,root); SST.<span class="built_in">BuildTree</span>(ids);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		SST.<span class="built_in">fcin</span>(op);</span><br><span class="line">		<span class="keyword">switch</span>(op)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: SST.<span class="built_in">fcin</span>(x);SST.<span class="built_in">fcin</span>(y);SST.<span class="built_in">fcin</span>(z);</span><br><span class="line">				<span class="built_in">pathadd</span>(x,y,z);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: SST.<span class="built_in">fcin</span>(x);SST.<span class="built_in">fcin</span>(y);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">pathsum</span>(x,y));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: SST.<span class="built_in">fcin</span>(x);SST.<span class="built_in">fcin</span>(z);</span><br><span class="line">				SST.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+siz[x]<span class="number">-1</span>,z);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: SST.<span class="built_in">fcin</span>(x);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,SST.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+siz[x]<span class="number">-1</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>下面 2 道题也是树链剖分的题，而且<strong>是裸题</strong></p>
<p><del>说实话这难度连模板题都比不上是认真的吗</del></p>
<ol>
<li><p><a href="https://www.luogu.org/problemnew/show/P3833"><strong>洛谷P3833 SHOI2012 魔法树</strong></a></p>
</li>
<li><p><a href="https://www.luogu.org/problemnew/show/P2590"><strong>洛谷P2590 ZJOI2008 树的统计</strong></a></p>
</li>
<li><a href="https://www.luogu.org/problemnew/show/P2590"><strong>P2590 ZJOI2008 树的统计</strong></a><ul>
<li>这个题把区间最大线段树和区间求和线段树 rua 在了一起，但是本质没有变化，按照模板格式直接套进去就完事</li>
</ul>
</li>
</ol>
<h2 id="例题2：洛谷P2146-NOI2015软件包管理器"><a href="#例题2：洛谷P2146-NOI2015软件包管理器" class="headerlink" title="例题2：洛谷P2146 NOI2015软件包管理器"></a>例题2：<a href="https://www.luogu.org/problemnew/show/P2146"><strong>洛谷P2146 NOI2015软件包管理器</strong></a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。</p>
<p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包A依赖软件包B，那么安装软件包A以前，必须先安装软件包B。同时，如果想要卸载软件包B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2)个软件包A1,A2,A3,⋯,Am，其中A1依赖A2，A2依赖A3，A3依赖A4，……，A[m-1]依赖Am，而Am依赖A1，则称这m个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p>
<p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>从文件manager.in中读入数据。</p>
<p>输入文件的第1行包含1个整数n，表示软件包的总数。软件包从0开始编号。</p>
<p>随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,⋯,n−2,n−1号软件包依赖的软件包的编号。</p>
<p>接下来一行包含1个整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种：</p>
<p>install x：表示安装软件包x</p>
<p>uninstall x：表示卸载软件包x</p>
<p>你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态。</p>
<p>对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出到文件manager.out中。</p>
<p>输出文件包括q行。</p>
<p>输出文件的第i行输出1个整数，为第i步操作中改变安装状态的软件包数。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0 0 0 1 1 5</span><br><span class="line">5</span><br><span class="line">install 5</span><br><span class="line">install 6</span><br><span class="line">uninstall 1</span><br><span class="line">install 4</span><br><span class="line">uninstall 0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>【样例说明】</p>
<p><img src="https://cdn.luogu.org/upload/pic/1504.png" alt="SampleExplain"></p>
<p>一开始所有的软件包都处于未安装状态。</p>
<p>安装5号软件包，需要安装0,1,5三个软件包。</p>
<p>之后安装6号软件包，只需要安装6号软件包。此时安装了0,1,5,6四个软件包。</p>
<p>卸载1号软件包需要卸载1,5,6三个软件包。此时只有0号软件包还处于安装状态。</p>
<p>之后安装4号软件包，需要安装1,4两个软件包。此时0,1,4处在安装状态。最后，卸载0号软件包会卸载所有的软件包。</p>
<p>【数据范围】</p>
<p><img src="https://cdn.luogu.org/upload/pic/1505.png" alt="DataRange"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先题目中说明软件包的依赖关系不构成环，那么就一定是一颗树了<del>（是不是森林我们先不管）</del></p>
<p><strong>安装一个软件包 $k$ ，相当于把根结点到 $k$ 的路径上的点的权值全部覆盖为 1，被修改的软件包数就是这条路径上原来的点权值之和和现在的点权值之和的差</strong></p>
<p><strong>卸载一个软件包 $k$ ，相当于把 $k$ 的子树中所有结点权值覆盖为 0，被修改的软件包是子树的大小，因为 $k$ 的子树中的软件包一定事先安装完了，所以不用做差</strong></p>
<p>注意这里的 区间覆盖 和 区间修改 是有区别的，所以线段树要改写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegCovTree</span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SegCovTreeNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> VAL,LC,RC,TAG;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> val(x) T[x].VAL</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> tag(x) T[x].TAG</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">	&#125;T[maxn&lt;&lt;<span class="number">1</span>]; <span class="type">int</span> nodes;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">		<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">		x*=sign;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="built_in">val</span>(k)=<span class="built_in">val</span>(<span class="built_in">lc</span>(k))+<span class="built_in">val</span>(<span class="built_in">rc</span>(k));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">tag</span>(k)==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">val</span>(<span class="built_in">lc</span>(k))=<span class="built_in">tag</span>(k)*(mid-L+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">val</span>(<span class="built_in">rc</span>(k))=<span class="built_in">tag</span>(k)*(R-mid);</span><br><span class="line">		<span class="built_in">tag</span>(<span class="built_in">lc</span>(k))=<span class="built_in">tag</span>(<span class="built_in">rc</span>(k))=<span class="built_in">tag</span>(k);</span><br><span class="line">		<span class="built_in">tag</span>(k)=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">		nodes=<span class="number">0</span>; <span class="built_in">build</span>(<span class="number">1</span>,N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> now=++nodes; <span class="built_in">tag</span>(now)=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L==R)&#123; <span class="built_in">val</span>(now)=<span class="number">0</span>;<span class="keyword">return</span> now; &#125;</span><br><span class="line">		<span class="built_in">lc</span>(now)=<span class="built_in">build</span>(L,mid);</span><br><span class="line">		<span class="built_in">rc</span>(now)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">		<span class="built_in">pushup</span>(now);</span><br><span class="line">		<span class="keyword">return</span> now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="comment">// d 为要覆盖的值  </span></span><br><span class="line">		<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y)&#123;</span><br><span class="line">			<span class="built_in">val</span>(k)=d*(R-L+<span class="number">1</span>); <span class="built_in">tag</span>(k)=d;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,y,d); </span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) <span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y,d);</span><br><span class="line">		<span class="built_in">pushup</span>(k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">SegSum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">val</span>(k);</span><br><span class="line">		<span class="built_in">pushdown</span>(k,L,R); <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) sum+=<span class="built_in">SegSum</span>(<span class="built_in">lc</span>(k),L,mid,x,y);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) sum+=<span class="built_in">SegSum</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y);</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;; SegCovTree SCT;</span><br><span class="line"><span class="type">int</span> n,q,ids,root;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn],siz[maxn],id[maxn]; </span><br><span class="line"><span class="type">int</span> w[maxn],Xson[maxn],dep[maxn],fa[maxn],top[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	nxt[++tot]=head[u];</span><br><span class="line">	to[tot]=v; head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; <span class="type">int</span> maxsize=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(!dep[to[i]])&#123;</span><br><span class="line">			dep[to[i]]=dep[u]+<span class="number">1</span>; </span><br><span class="line">			<span class="built_in">DFS</span>(to[i]); </span><br><span class="line">			siz[u]+=siz[to[i]]; fa[to[i]]=u;</span><br><span class="line">			<span class="keyword">if</span>(siz[to[i]]&gt;maxsize)&#123;</span><br><span class="line">				maxsize=siz[to[i]];</span><br><span class="line">				Xson[u]=to[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> TOP)</span></span>&#123;</span><br><span class="line">	id[u]=++ids;</span><br><span class="line">	top[u]=TOP;</span><br><span class="line">	<span class="keyword">if</span>(siz[u]==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">DFS</span>(Xson[u],TOP);<span class="comment">// 优先走重儿子  </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=Xson[u] &amp;&amp; fa[u]!=to[i])</span><br><span class="line">			<span class="built_in">DFS</span>(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pathcov</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		SCT.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],dt);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	SCT.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x],dt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 返回 x-&gt; y 的最短路径上的点权值和 </span></span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		ret+=SCT.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ret+=SCT.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x]);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	SCT.<span class="built_in">fcin</span>(n); root=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> a,b; <span class="type">char</span> op[<span class="number">19</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		SCT.<span class="built_in">fcin</span>(a);a++;</span><br><span class="line">		<span class="built_in">Eadd</span>(i,a);<span class="built_in">Eadd</span>(a,i);</span><br><span class="line">	&#125; dep[root]=<span class="number">1</span>; <span class="type">int</span> TMP;</span><br><span class="line">	<span class="built_in">DFS</span>(root);<span class="built_in">DFS</span>(root,root);</span><br><span class="line">	SCT.<span class="built_in">BuildTree</span>(n); SCT.<span class="built_in">fcin</span>(q);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">		SCT.<span class="built_in">fcin</span>(a);a++;</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;i&#x27;</span>)&#123;</span><br><span class="line">			TMP=<span class="built_in">pathsum</span>(root,a);</span><br><span class="line">			<span class="built_in">pathcov</span>(root,a,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">pathsum</span>(root,a)-TMP);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SCT.<span class="built_in">SegSum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[a],id[a]+siz[a]<span class="number">-1</span>));</span><br><span class="line">			SCT.<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[a],id[a]+siz[a]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>树链剖分由于成功结合了类似于 倍增LCA 的跳跳法，和本来就很冗长的区间线段树，使得模板题竟出现 149 行代码量的 <del>惨绝人寰</del> 的现象，因此写树链剖分一定要静下心来认真写，稍微漏掉一个语句编有可能导致程序卡死掉（然而你无论如何也查不出来），分享一句我经常忘记写的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dep[root]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>启发式合并 | 二分 | 线段树 | 主  席树 | 20190712考试：解题报告</title>
    <url>/2019/07/12/2019-07-12-0712%E8%80%83%E8%AF%95%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. pudding</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$256$ M</td>
</tr>
<tr>
<td style="text-align:center">2. trouble</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$256$ M</td>
</tr>
<tr>
<td style="text-align:center">3. tree</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$256$ M</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-梦幻布丁（pudding-cpp）"><a href="#1-梦幻布丁（pudding-cpp）" class="headerlink" title="1. 梦幻布丁（pudding.cpp）"></a><a href="https://www.luogu.org/problemnew/show/P3201">1. 梦幻布丁（pudding.cpp）</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>N个布丁摆成一行,进行M次操作.每次将某个颜色的布丁全部变成另一种颜色的,然后再询问当前一共有多少段颜色.例如颜色分别为1,2,2,1的四个布丁一共有3段颜色.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行给出N,M表示布丁的个数和好友的操作次数.<br>第二行N个数A1,A2…An表示第i个布丁的颜色从第三行起有M行,对于每个操作,若第一个数字是1表示要对颜色进行改变，其后的两个整数X,Y表示将所有颜色为X的变为Y，X可能等于Y.<br>若第一个数字为2表示要进行询问当前有多少段颜色，这时你应该输出一个整数. </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>针对第二类操作即询问，依次输出当前有多少段颜色.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">2</span><br><span class="line">1 2 1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>1&lt;=n,m&lt;=100,000; 0&lt;Ai,x,y&lt;1,000,000</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：暴力（50分）</strong></p>
</blockquote>
<p>考试时想的暴力方法，用 $fir[x]$ 和 $las[x]$ 记录颜色 $x$ 第一次和最后一次出现的位置，修改时只需要在这两个点之间循环修改即可</p>
<p>合并 $x$ 到 $y$ 就是 $fir[y]=min(fir[x],\;fir[y])$，$las[y]=max(las[x],\;las[y])$ 得了一半的分</p>
<blockquote>
<p><strong>做法二：暴力 + 启发式合并（100分）</strong></p>
</blockquote>
<p>应该算是考试时的想法更进一步，考虑用类似前向星的方式存储颜色 $x$ 出现的所有位置，然后统计一次原序列得到最初的 $ans$，<strong>可以发现好友操作之后的 $ans’\leq ans$ ，因此只需在原来的 $ans$ 上做减法即可</strong></p>
<p>结合启发式合并，用 $siz(x)$ 存颜色 $x$ 出现的次数，<strong>每次覆盖时 $x\to y$ 选择把 $siz$ 较小的那一个合并到较大的那一个上去，由于最后的零散颜色段长度会越来越短，因此合并的时间复杂度会逐步降低（最后甚至达到近似 $O(1)$ 的复杂度）</strong>，但是这样做有些时候会违背题目的要求，因此用 $vis(x)$ 表示 $x$ 经过修改后的实际颜色，合并时若 $siz(x)&gt;siz(y)$ 则 $swap(vis(x),\;vis(y))$ 再合并 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fir[maxn],las[maxn],nex[maxn];</span><br><span class="line"><span class="type">int</span> vis[maxn];<span class="type">int</span> n,m,siz[maxn];</span><br><span class="line"><span class="type">int</span> ans;<span class="type">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=las[x];i;i=nex[i]) ans-=(a[i<span class="number">-1</span>]==y)+(a[i+<span class="number">1</span>]==y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=las[x];i;i=nex[i]) a[i]=y;</span><br><span class="line">	nex[fir[x]]=las[y];las[y]=las[x];siz[y]+=siz[x];</span><br><span class="line">	fir[x]=siz[x]=las[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;pudding.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;pudding.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(a[i]);vis[a[i]]=a[i];</span><br><span class="line">		ans+=a[i]!=a[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(!las[a[i]]) fir[a[i]]=i;</span><br><span class="line">		siz[a[i]]++;nex[i]=las[a[i]];las[a[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> op,x,y;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(op);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(siz[vis[x]]&gt;siz[vis[y]]) <span class="built_in">swap</span>(vis[x],vis[y]);</span><br><span class="line">			<span class="keyword">if</span>(!siz[vis[x]]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">merge</span>(vis[x],vis[y]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-皇帝的烦恼（trouble-cpp）"><a href="#2-皇帝的烦恼（trouble-cpp）" class="headerlink" title="2. 皇帝的烦恼（trouble.cpp）"></a><a href="https://www.luogu.org/problemnew/show/P3201">2. 皇帝的烦恼（trouble.cpp）</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置n名将军。不幸的是这n名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。</p>
<p>秦皇已经准备好了秘密处决这些无礼的边防大将。</p>
<p>不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第i个将军要求得到ai枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为i的将军和编号为i+1的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号1和编号n的将军也相邻）。</p>
<p>皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个整数n(1&lt;=n&lt;=20000)。</p>
<p>接下来n行每行一个整数ai，表示第i个将军要求得到多少种勋章。(1&lt;=ai&lt;=100000)</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，即最少需要多少种勋章。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 2 1 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>1&lt;=n,m&lt;=100,000; 0&lt;Ai,x,y&lt;1,000,000</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：瞎搞（60分）</strong></p>
</blockquote>
<p>考试时，手算了几个样例（都是n=4）发现最小的勋章数就是序列中相邻元素和的最大值，即</p>
<p>$ans=max(a[1]+a[n],\; a[i]+a<a href="i\in[1,\;n-1]">i+1</a>)$</p>
<p>考完了才发现 没有考虑奇数情况，例如一个反例就是 $5\quad 5\quad 5$ ，答案应是 15，但是程序输出 10</p>
<blockquote>
<p><strong>做法二：二分 + 递推（100分）</strong></p>
</blockquote>
<p>二分最大的勋章数 $mid$，设 $max(i)$ 为 $i$ 号将军和 1 号将军最多会有多少个相同的勋章，$min(i)$ 则表示最少的相同数，<strong>对于 $max(i)$，因为 $i$ 号将军最多有 $a[i]$ 个勋章，又 $i$ 号将军和 $i-1$ 号将军不能有相同的勋章，则最多有 $a[1]-max(i-1)$ 个勋章和 1 号将军相同，即</strong></p>
<p>$max(i)=min(a[i],\;a[1]-max(i-1))$</p>
<p><strong>又根据容斥原理可以得出 $min(i)$ 的表达式</strong></p>
<p>$min(i)=max(0,\;a[1]+a[i-1]-max(i-1)+a[i]-mid)$</p>
<p>其中也可不写 $max$，只要 $min(n)\leq0$ 就能说明 $n$ 号将军不会与 1 号将军冲突，当前的勋章数还可以更少，否则只能增加勋章数</p>
<blockquote>
<p><strong>做法三：数学原理（100分）</strong></p>
</blockquote>
<p>做法一在 n 为偶数时是可行的，因为总能给将军们两两配对，于是可以单独考虑 n 为奇数的情况，<strong>由于奇数条件下，$n$ 和 1 的相邻关系不可忽略，因此每一个种类的勋章都只能使用$\lfloor \frac{n}{2} \rfloor$ (表示向下取整) 的次数</strong>，那么就可以推出</p>
<p>$ans=\lceil sum\div \lfloor \frac{n}{2} \rfloor \rceil$ （因为不能发放不足一个的勋章，所以 $ans$ 向上取整）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 20002 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[maxn],n;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;trouble.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;trouble.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(a[i]),sum+=a[i];</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,a[<span class="number">1</span>]+a[n]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) ans=<span class="built_in">max</span>(ans,a[i]+a[i+<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(!n&amp;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		n=n/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>((<span class="type">int</span>)<span class="built_in">ceil</span>((<span class="type">double</span>)sum/(<span class="type">double</span>)n),ans));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-二叉树（tree-cpp）"><a href="#3-二叉树（tree-cpp）" class="headerlink" title="3. 二叉树（tree.cpp）"></a>3. 二叉树（tree.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>现在有一棵二叉树，所有非叶子节点都有两个孩子。在每个叶子节点上有一个权值(有n个叶子节点，满足这些权值为1..n的一个排列)。可以任意交换每个非叶子节点的左右孩子。</p>
<p>要求进行一系列交换，使得最终所有叶子节点的权值按照中序遍历写出来，逆序对个数最少。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行n下面每行，一个数x</p>
<p>如果x==0，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息，</p>
<p>如果x!=0，表示这个节点是叶子节点，权值为x。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>一行，最少逆序对个数。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0 3 1 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>一行，最少逆序对个数。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：瞎搞（4分）</strong></p>
</blockquote>
<p>考试时想的是只能交换叶子节点，那么那些只有一个叶子节点的非叶子节点就不能动，因此把所有的叶子节点按照升序交换之后直接中序遍历，然后树状数组求遍历后的序列的逆序对数</p>
<blockquote>
<p><strong>做法二：暴力 + 主席树（100分）</strong></p>
</blockquote>
<p>可以对每个叶子节点建立一颗线段树来统计逆序对数，每次访问到一个非叶子节点都暴力地来交换一下左右子树的位置，看交换前和交换后形成的逆序对数哪一个更少，由此得出答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 400003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ch[maxn][<span class="number">2</span>],w[maxn],newp=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> lc[maxn&lt;&lt;<span class="number">4</span>],rc[maxn&lt;&lt;<span class="number">4</span>],nodes;</span><br><span class="line">ll val[maxn&lt;&lt;<span class="number">4</span>],cnt[<span class="number">2</span>];<span class="type">int</span> root[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	val[k]=val[lc[k]]+val[rc[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="built_in">fcin</span>(w[k]);</span><br><span class="line">	<span class="keyword">if</span>(!w[k])&#123;</span><br><span class="line">		ch[k][<span class="number">0</span>]=++newp;</span><br><span class="line">		<span class="built_in">init</span>(ch[k][<span class="number">0</span>]);</span><br><span class="line">		ch[k][<span class="number">1</span>]=++newp;</span><br><span class="line">		<span class="built_in">init</span>(ch[k][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> &amp;k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!k) k=++nodes;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;val[k]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">build</span>(lc[k],L,mid,pos);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">build</span>(rc[k],mid+<span class="number">1</span>,R,pos);</span><br><span class="line">	<span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x?x:y;</span><br><span class="line">	cnt[<span class="number">0</span>]+=(ll)val[rc[x]]*val[lc[y]];</span><br><span class="line">	cnt[<span class="number">1</span>]+=(ll)val[lc[x]]*val[rc[y]];</span><br><span class="line">	lc[x]=<span class="built_in">unite</span>(lc[x],lc[y]);</span><br><span class="line">	rc[x]=<span class="built_in">unite</span>(rc[x],rc[y]);</span><br><span class="line">	<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!k) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(ch[k][<span class="number">0</span>]);<span class="built_in">dfs</span>(ch[k][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span>(!w[k])&#123;</span><br><span class="line">		<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">		root[k]=<span class="built_in">unite</span>(root[ch[k][<span class="number">0</span>]],root[ch[k][<span class="number">1</span>]]);</span><br><span class="line">		ans+=<span class="built_in">min</span>(cnt[<span class="number">0</span>],cnt[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;tree.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;tree.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">init</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=newp;i++)</span><br><span class="line">		<span class="keyword">if</span>(w[i]) <span class="built_in">build</span>(root[i],<span class="number">1</span>,n,w[i]);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>主席树</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | 01分数规划 | 并查集  \ | 拓扑排序 | 二分| 图论 | 20190716考试  ：解题报告</title>
    <url>/2019/07/16/2019-07-16-0716%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. magician</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$128$ MB</td>
</tr>
<tr>
<td style="text-align:center">2. seq</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$128$ MB</td>
</tr>
<tr>
<td style="text-align:center">3. show</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$128$ MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-黑魔法师之门（magician-cpp）"><a href="#1-黑魔法师之门（magician-cpp）" class="headerlink" title="1. 黑魔法师之门（magician.cpp）"></a>1. 黑魔法师之门（magician.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>经过了 16 个工作日的紧张忙碌，未来的人类终于收集到了足够的能源。然而在与 Violet 星球的战争中，由于 Z 副官的愚蠢，地球的领袖 applepi 被邪恶的黑魔法师 Vani 囚禁在了 Violet 星球。为了重启 Nescafé这一宏伟的科技工程，人类派出了一支由 HQX 1人组成的精英队伍，穿越时空隧道，去往 Violet 星球拯救领袖 applepi。</p>
<p> applepi 被囚禁的地点只有一扇门，当地人称它为“黑魔法师之门”。这扇门上画着一张无向无权图，而打开这扇门的密码就是图中每个点的度数大于零且都是偶数的子图的个数 对 1000000009 取模的值。此处子图 (V, E) 定义为：点集 V和边集 E 都是原图的任意子集， 其中 E 中的边的端点都在 V中。 但是 Vani 认为这样的密码过于简单，因此门上的图是动态的。起初图中只有 N 个顶点 而没有边。Vani 建造的门控系统共操作 M 次，每次往图中添加一条边。你必须在每次操作 后都填写正确的密码，才能够打开黑魔法师的牢狱，去拯救伟大的领袖 applepi。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数 N 和 M。 接下来 M 行，每行两个整数 A和 B，代表门控系统添加了一条无向边 (A, B)。 </p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一共 M 行，表示每次操作后的密码。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0 </span><br><span class="line">0</span><br><span class="line">1 </span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">7</span><br><span class="line">15</span><br><span class="line">31 </span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>第三次添加之后，存在一个满足条件的子图 {1, 2, 3}（其中 1, 2, 3 是数据中边的标号）。</p>
<p>第四次添加之后，存在三个子图 {1, 2, 3}，{1, 2, 4}，{3, 4}。</p>
<p>【数据范围】</p>
<p>对于 30% 的数据，N, M≤10。 对于 100% 的数据，N≤200000，M≤300000。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>考试时一看到这个题，脑子里各种统计点的度数还有排列组合搅在一起，感觉过于复杂就果断放弃去做了第三题，<del>考完试才知道这个题是最简单的？</del></p>
<p>可以发现一个简单环上的所有点都满足度数大于 0 且度数为偶数 2 的条件，所以简单环就可以看作一个符合条件的子图（如果是 2 个点形成简单环则需他们之间连有 2 条无向边）</p>
<p>设某一时刻图中存在 $n$ 个环，则所有符合条件的子图的个数就是从这 $n$ 个环中选，每个环都有选和不选两种状态，又因为不能一个环都不选所以 $ans=2^n-1$</p>
<p>由于题目不断加边的操作，<strong>简单环的个数明显是增加或者不变的</strong>，用并查集维护点的集合关系，如果要加边的两个点属于同一个集合就环数+1，否则把他们俩合并到一个集合就完了</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[maxn];<span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sfind</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=<span class="built_in">Sfind</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;magician.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;magician.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">	<span class="type">int</span> x,y;<span class="type">int</span> fx,fy;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		fx=<span class="built_in">Sfind</span>(x);fy=<span class="built_in">Sfind</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(fx==fy) ans=(ans&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">		<span class="keyword">else</span> f[fx]=fy;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-检测序列（seq-cpp）"><a href="#2-检测序列（seq-cpp）" class="headerlink" title="2. 检测序列（seq.cpp）"></a>2. 检测序列（seq.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>有M（1≤M≤50,000）个序列（称作检测序列）， 每个序列有mi个不同的数字，且每个数字都属于[1,N]，其中1≤N≤10^5。每个序列描述了数字间的相对位置关系（谁在前谁在后），比如序列2、5、1 描述了2在5的前面，5在1的前面。</p>
<p>求一个字典序最小的1…N的排列，且尽可能多的满足前若干个检测序列描述的相对位置关系。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行包含N和M。接下来的M行，每行描述了一个检测序列：第一个数是mi，紧跟同一行后面是mi个整数，表示一个检测序列。所有mi的和至多为200,000。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>如题目描述，输出N个空格分隔的整数，给出一个1…N的排列。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">3 1 2 3</span><br><span class="line">2 4 2</span><br><span class="line">3 3 4 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 4 2 3</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>无</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>做法：<strong>二分需要满足前 $mid$ 个检测序列，连有向边跑拓扑排序</strong></p>
<p>如题目所说，只需要尽量满足前若干个检测序列，可以二分答案 $mid$ 表示需要满足前 $mid$ 个检测序列，按照序列的数字从前往后连有向边，然后跑拓扑排序，若图中存在环则说明这 $mid$ 个检测序列不能同时满足，否则 $mid$ 可以更大</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,out_[maxn],ans[maxn];</span><br><span class="line"><span class="type">int</span> n,m,indeg[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; mi[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> qh;</span><br><span class="line">	priority_queue&lt; <span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; wait;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>) wait.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(!wait.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		qh=wait.<span class="built_in">top</span>();</span><br><span class="line">		out_[++out_[<span class="number">0</span>]]=qh;</span><br><span class="line">		wait.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[qh];i;i=nxt[i])</span><br><span class="line">			<span class="keyword">if</span>(--indeg[to[i]]==<span class="number">0</span>) wait.<span class="built_in">push</span>(to[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out_[<span class="number">0</span>]==n; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">	out_[<span class="number">0</span>]=<span class="number">0</span>;<span class="built_in">memset</span>(indeg,<span class="number">0</span>,<span class="built_in">sizeof</span>(indeg));</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">	<span class="keyword">for</span>(iter=mi[i].<span class="built_in">begin</span>();iter+<span class="number">1</span>!=mi[i].<span class="built_in">end</span>();iter++)</span><br><span class="line">		<span class="built_in">Eadd</span>(*iter,*(iter+<span class="number">1</span>)),indeg[*(iter+<span class="number">1</span>)]++;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">topp</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> L=<span class="number">1</span>,R=m;</span><br><span class="line">	<span class="type">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">		mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) L=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> R=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	out_[<span class="number">0</span>]=<span class="number">0</span>;<span class="built_in">memset</span>(indeg,<span class="number">0</span>,<span class="built_in">sizeof</span>(indeg));</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">check</span>(mid);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=out_[<span class="number">0</span>];i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,out_[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;seq.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;seq.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)</span><br><span class="line">			<span class="built_in">fcin</span>(y),mi[i].<span class="built_in">push_back</span>(y); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-达牛秀（show-cpp）"><a href="#3-达牛秀（show-cpp）" class="headerlink" title="3. 达牛秀（show.cpp）"></a>3. 达牛秀（show.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>编号为1…N的奶牛！第i头奶牛重量为wi，才艺水平为ti，两者都是整数。</p>
<p>在到达时，HQX 就被今年达牛秀的新规则吓到了：</p>
<p>（一）参加比赛的一组奶牛必须总重量至少为W（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且</p>
<p>（二）总才艺值与总重量的比值最大的一组获得胜利。</p>
<p>HQX注意到他的所有奶牛的总重量不小于W，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含N（1≤N≤250）和W（1≤W≤1000）。下面N行，每行用两个整数wi（1≤wi≤10^6）和ti（1≤ti≤10^3）描述了一头奶牛。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>请求出HQX用一组总重量最少为W的奶牛最大可能达到的总才艺值与总重量的比值。如果你的答案是A，输出1000A向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 15</span><br><span class="line">20 21</span><br><span class="line">10 11</span><br><span class="line">30 31</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1066</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为11、重量为10的奶牛，但是由于我们需要至少15单位的重量，最优解最终为使用这头奶牛加上才艺值为21、重量为20的奶牛。这样的话才艺与重量的比值为(11+21)/(10+20) = 32/30 = 1.0666666…，乘以1000向下取整之后得到1066。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：01分数规划 + 背包 DP</strong></p>
</blockquote>
<p>看到“才艺与重量的比值最大”就会想起 01 分数规划的思路，要求 $\sum t[i]\div \sum w[i]$ 的最大值，设答案为 $x$ ，原式变形得 $\sum (t[i]-w[i]\times x)$ </p>
<p>二分 $x$ ，带入进行背包 DP 即可，注意实数域上的二分精度问题</p>
<blockquote>
<p><strong>做法二：DP</strong></p>
</blockquote>
<p>设 $f[i][j]$ 表示考虑了第 $i$ 头牛，当前的总重量为 $j$ 的比值的最大值，转移方程为：</p>
<ol>
<li>不选择第 $i+1$ 头奶牛：$f[i+1][j]=max(f[i+1][j],\;f[i][j])$</li>
<li>选择第 $i+1$ 头奶牛：$f[i+1][j+w[i]]=max(f[i+1][j+w[i],\;x)$</li>
</ol>
<p>其中 $i\in[1,\;n-1]$，$j\in[0,\;W]$</p>
<p>这个 $x$ 就是选择第 $i+1$ 头奶牛后，新的总才艺值和总重量的比值，由于 $x$ 不能直接由 $f[i][j]$ 得到，需要新设 $s[i][j]$ 表示 $f[i][j]$ 对应的总才艺值， $p[i][j]$ 表示 $f[i][j]$ 对应的总重量，于是：</p>
<p>$f[i+1][j+w[i]]=max(f[i+1][j+w[i]],\;(s[i][j]+t[i+1])\div(p[i][j]+w[i+1])$</p>
<p>$s[i][j]$ 和 $p[i][j]$ 在 $f[i][j]$ 发生变化的时候一起更新，<strong>但是注意到 $f[i][j]$ 里面 $j$ 是表示重量的，而对应的 $p[i][j]$ 也是表示重量的，看起来是重复表示了重量，实际上是因为避免 MLE，转移方程的 $j$ 只开到了 $W$(1000) ,而题目中奶牛的重量和可能远大于这个值，在 $j&gt;W$ 时可以把它累积到 $j=W$ 也就是 $f[i][W]$ 来转移，但是要对应真实的重量和，所以新设的 $p[i][j]$ 是用来表示 $f[i][j]$ 对应的实际重量和</strong></p>
<p>边界为 $f[1][w[1]]=t[1]\div w[1]$，最后的答案在 $f[1\to n][W]$ 里面取最大值</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 251</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxs 1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v(x) (x&gt;maxw?maxw:x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,maxw;</span><br><span class="line"><span class="type">int</span> t[maxn],w[maxn];</span><br><span class="line"><span class="type">int</span> s[maxn][maxs],p[maxn][maxs];</span><br><span class="line"><span class="type">double</span> f[maxn][maxs];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>][<span class="built_in">v</span>(w[<span class="number">1</span>])]=(<span class="type">double</span>)t[<span class="number">1</span>]/(<span class="type">double</span>)w[<span class="number">1</span>];</span><br><span class="line">	s[<span class="number">1</span>][<span class="built_in">v</span>(w[<span class="number">1</span>])]=t[<span class="number">1</span>];p[<span class="number">1</span>][<span class="built_in">v</span>(w[<span class="number">1</span>])]=w[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=maxw;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i][j]&gt;f[i+<span class="number">1</span>][j])&#123;</span><br><span class="line">			f[i+<span class="number">1</span>][j]=f[i][j];</span><br><span class="line">			s[i+<span class="number">1</span>][j]=s[i][j];</span><br><span class="line">			p[i+<span class="number">1</span>][j]=p[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((<span class="type">double</span>)(s[i][j]+t[i+<span class="number">1</span>])/(<span class="type">double</span>)(p[i][j]+w[i+<span class="number">1</span>])&gt;f[i+<span class="number">1</span>][<span class="built_in">v</span>(p[i][j]+w[i+<span class="number">1</span>])])&#123;</span><br><span class="line">			f[i+<span class="number">1</span>][<span class="built_in">v</span>(p[i][j]+w[i+<span class="number">1</span>])]=(<span class="type">double</span>)(s[i][j]+t[i+<span class="number">1</span>])/(<span class="type">double</span>)(p[i][j]+w[i+<span class="number">1</span>]);</span><br><span class="line">			s[i+<span class="number">1</span>][<span class="built_in">v</span>(p[i][j]+w[i+<span class="number">1</span>])]=s[i][j]+t[i+<span class="number">1</span>];</span><br><span class="line">			p[i+<span class="number">1</span>][<span class="built_in">v</span>(p[i][j]+w[i+<span class="number">1</span>])]=p[i][j]+w[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> ans=<span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,f[i][maxw]);</span><br><span class="line">	ans*=<span class="number">1000.0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="type">long</span> <span class="type">long</span>)ans); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;show.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;show.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(maxw);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">fcin</span>(w[i]),<span class="built_in">fcin</span>(t[i]);</span><br><span class="line">	<span class="built_in">dp</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分</tag>
        <tag>图论</tag>
        <tag>01分数规划</tag>
        <tag>并查集</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟 | SPFA | 递推 | 并查集 | 20190713考试  ：解题报告</title>
    <url>/2019/07/13/2019-07-13-0713%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. buckets</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$256$ MB</td>
</tr>
<tr>
<td style="text-align:center">2. factory</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$256$ MB</td>
</tr>
<tr>
<td style="text-align:center">3. dining</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$512$ MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-救火（buckets-cpp）"><a href="#1-救火（buckets-cpp）" class="headerlink" title="1. 救火（buckets.cpp）"></a>1. 救火（buckets.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>农场上起火了，奶牛们正在紧急赶去灭火！</p>
<p>农场可以用一个像这样的10×10的字符方阵来描述：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..B.......</span><br><span class="line">..........</span><br><span class="line">.....R....</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">.....L....</span><br><span class="line">..........</span><br></pre></td></tr></table></figure>
<p>字符’B’表示正着火的牛棚。字符’L’表示一个湖，而字符’R’表示农场上的一块巨大岩石。</p>
<p>奶牛们想要沿着一条湖到牛棚之间的路径组成一条“水桶传递队列”，这样她们就可以沿着这条路径传递水桶来帮助灭火。当两头奶牛在东南西北四个方向上相邻时水桶可以在她们之间传递。这对于湖边的奶牛也是对的——奶牛只能在紧挨着湖的时候才能用水桶从湖里取水。类似地，奶牛只能在紧挨着牛棚的时候才能用水去灭牛棚的火。</p>
<p>请帮助求出奶牛们为了组成这样的“水桶传递队列”需要占据的’.’格子的最小数量。</p>
<p>奶牛不能站在岩石所在的方格之内，此外保证牛棚和湖不是相邻的。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入包含10行，每行10个字符，描述这个农场的布局。输入保证图案中恰有一个字符’B’、一个字符’L’以及一个字符’R’。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，为组成一条可行的水桶传递队列所需要的奶牛的最小数量。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..B.......</span><br><span class="line">..........</span><br><span class="line">.....R....</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">.....L....</span><br><span class="line">..........</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>在这个例子中，以下是一个可行的方案，使用了最小数量的奶牛（7）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..........</span><br><span class="line">..B.......</span><br><span class="line">..C.......</span><br><span class="line">..CC.R....</span><br><span class="line">...CCC....</span><br><span class="line">.....C....</span><br><span class="line">.....L....</span><br><span class="line">..........</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：BFS（100分）</strong></p>
</blockquote>
<p>用 <strong>洪水填充法</strong> 填表，设 $f[i][j]=min(f[i][j],f[i’][j’]+1)$ ，$i’$ 和 $j’$ 来自于上下左右的格子</p>
<p>边界为 $f[sx][sy]=0$ 表示为 $L$ 的格子坐标</p>
<blockquote>
<p><strong>做法二：计算（100分）</strong></p>
</blockquote>
<p>发现数据中只有一块岩石 $R$，那么显然从 $L$ 格子走一个 L 形路线到 B 格子就行了，因为 L 形路线有两条，不可能全被 $R$ 阻挡所以一定可以走通</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 13</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; pp;</span><br><span class="line"><span class="type">char</span> M[maxn][maxn];<span class="type">bool</span> vis[maxn][maxn];</span><br><span class="line"><span class="type">int</span> offX[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,offY[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn];<span class="type">int</span> sx,sy,ex,ey;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(M[i][j]==<span class="string">&#x27;L&#x27;</span>)&#123;sx=i;sy=j;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(M[i][j]==<span class="string">&#x27;B&#x27;</span>)&#123;ex=i;ey=j;<span class="keyword">continue</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">127</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	queue&lt;pp&gt; q; pp head; <span class="type">int</span> newx,newy;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(sx,sy),<span class="number">0</span>));</span><br><span class="line">	f[sx][sy]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> x head.first.first</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> y head.first.second</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> z head.second</span></span><br><span class="line">		head=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			newx=x+offX[i];newy=y+offY[i];</span><br><span class="line">			<span class="keyword">if</span>(newx&lt;<span class="number">1</span> || newx&gt;<span class="number">10</span> || newy&lt;<span class="number">1</span> || newy&gt;<span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(M[newx][newy]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			f[newx][newy]=<span class="built_in">min</span>(f[newx][newy],f[x][y]+<span class="number">1</span>);</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="built_in">make_pair</span>(newx,newy),z+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;buckets.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;buckets.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;M[i][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[ex][ey]<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-奶牛工厂（factory-cpp）"><a href="#2-奶牛工厂（factory-cpp）" class="headerlink" title="2.奶牛工厂（factory.cpp）"></a>2.奶牛工厂（factory.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>牛奶生意正红红火火！Farmer John的牛奶加工厂内有N个加工站，编号为1…N（1≤N≤100），以及N−1条通道，每条连接某两个加工站。（通道建设很昂贵，所以Farmer John选择使用了最小数量的通道，使得从每个加工站出发都可以到达所有其他加工站）。</p>
<p>为了创新和提升效率，Farmer John在每条通道上安装了传送带。不幸的是，当他意识到传送带是单向的已经太晚了，现在每条通道只能沿着一个方向通行了！所以现在的情况不再是从每个加工站出发都能够到达其他加工站了。</p>
<p>然而，Farmer John认为事情可能还不算完全失败，只要至少还存在一个加工站i满足从其他每个加工站出发都可以到达加工站i。注意从其他任意一个加工站j前往加工站i可能会经过i和j之间的一些中间站点。请帮助Farmer John求出是否存在这样的加工站i。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含一个整数N，为加工站的数量。以下N−1行每行包含两个空格分隔的整数ai和bi，满足1≤ai,bi≤N以及ai≠bi。这表示有一条从加工站ai向加工站bi移动的传送带，仅允许沿从ai到bi的方向移动。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>如果存在加工站i满足可以从任意其他加工站出发都可以到达加工站i，输出最小的满足条件的i。否则，输出−1。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>无</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：暴力 + DFS（100分）</strong></p>
</blockquote>
<p>看到 $N\leq100$ 我们就知道这个题有多水了，存了反图之后直接对每个点暴力地 DFS 一遍看能不能遍历到所有点，把最先满足条件的输出就行</p>
<blockquote>
<p><strong>做法二：暴力 + 并查集（100分）</strong></p>
</blockquote>
<p>稍微优雅一点的暴力，维护每个点的并查集 $f(i)$ ，每次连边 $u\to v$ 就把 $f(u)$ 搬进 $f(v)$ 里面即可，最后判断有没有点的 $siz(f(i))=n$ ，由于数据太水，甚至不需要启发式合并</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n;<span class="type">bool</span> vis[maxn];<span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	cnt++;vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="built_in">dfs</span>(to[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;factory.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;factory.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n); <span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">Eadd</span>(y,x);&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(i);<span class="keyword">if</span>(cnt==n)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-奶牛觅食（dining-cpp）"><a href="#3-奶牛觅食（dining-cpp）" class="headerlink" title="3.奶牛觅食（dining.cpp）"></a>3.奶牛觅食（dining.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>漫长的一天结束了，饥困交加的奶牛们准备返回牛棚。农场由N片牧场组成（2≤N≤50,000），方便起见编号为1…N。所有奶牛都要前往位于牧场N的牛棚。其他N−1片牧场中每片有一头奶牛。奶牛们可以通过M条无向的小路在牧场之间移动（1≤M≤100,000）。第i条小路连接牧场ai和bi，通过需要时间ti。每头奶牛都可以经过一些小路回到牛棚。</p>
<p>由于饥饿，奶牛们很乐于在他们回家的路上停留一段时间觅食。农场里有K(1≤K≤n)个有美味的干草捆，第ii个干草捆的美味值为yi。每头奶牛都想要在她回牛棚的路上在某一个干草捆处停留，但是她这样做仅当经过这个干草捆使她回牛棚的时间增加不超过这个干草捆的美味值。注意一头奶牛仅仅“正式地”在一个干草捆处因进食而停留，即使她的路径上经过其他放有干草捆的牧场；她会简单地无视其他的干草捆。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含三个空格分隔的整数N，M和K。以下M行每行包含三个整数ai，bi和ti，表示牧场ai和bi之间有一条需要ti时间通过的小路（ai不等于bi，ti为不超过10^4的正整数）。</p>
<p>以下K行，每行以两个整数描述了一个干草捆：该干草捆所在牧场的编号，以及它的美味值（一个不超过10^9的正整数）。同一片牧场中可能会有多个干草捆。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>输出包含N−1行。如果牧场i里的奶牛可以在回牛棚的路上前往某一个干草捆并且在此进食，则第i行为一个整数1，否则为一个整数0。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 5 1</span><br><span class="line">1 4 10</span><br><span class="line">2 1 20</span><br><span class="line">4 2 3</span><br><span class="line">2 3 5</span><br><span class="line">4 3 2</span><br><span class="line">2 7</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>在这个例子中，牧场3里的奶牛可以停留进食，因为她回去的时间仅会增加6（从2增加到8），而这个增加量并没有超过干草捆的美味值7。牧场2里的奶牛显然可以吃掉牧场2里的干草，因为这并不会导致她的最佳路径发生变化。对于牧场1里的奶牛是一个有趣的情况，因为看起来她的最佳路径（10）可能会因为前去进食而有过大的增加量。然而，确实存在一条路径使得她可以前去干草捆处停留：先到牧场4，然后去牧场2（吃草），然后回到牧场4。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：SPFA + 少量递推（100分）</strong></p>
</blockquote>
<p>首先用 SPFA 求出所有点到点 n 的单源最短路径，考虑经过有干草的牧场对于奶牛心理的影响</p>
<p>设 $dist[i][0]$ 表示原本的单源最短路径，$dist[i][1]$ 表示在某一个牧场吃过草后心理上的最短路径，显然，若对于奶牛 $i$ 有 $dist[i][1]\leq dist[i][0]$，则奶牛 $i$ 是可以吃了草再走回牛棚的</p>
<p>其实在第一遍用 SPFA 求 $dist[i][0]$ 的时候可以把 $dist[i][1]$ 顺带求了，具体是：</p>
<p>$dist[i’][1]=min(dist[i][1]+w,\;dist[i][0]+w-f[i’])$ </p>
<p>其中 $i’$ 表示 SPFA 当前考虑的下一个点，$f[i’]$ 表示其美味程度，<strong>注意要严格控制 $dist[i][1]$ 为吃了草才能形成的最短路径，可以将没有干草的点弄成 $f[x]=-inf$</strong> </p>
<blockquote>
<p><strong>做法二：两次 SPFA（100分）</strong></p>
</blockquote>
<p>第一遍 SPFA 求各个点到 n 的单源最短路径，第二遍 SPFA 开始时不要将 $dist$ 数组全部赋值 INF，<strong>将带有干草的那几个点的 $dist$ 值设定成美味程度，n 点的 $dist$ 为零，其他点的 $dist$ 设置为 INF 即可求出通过吃草走出的到 n 点的最短路径</strong>，剩下的部分处理思路同做法一</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> deli[maxn];</span><br><span class="line"><span class="type">int</span> dist[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> to[maxm],w[maxm],nxt[maxm];</span><br><span class="line"><span class="type">int</span> head[maxn],tot;<span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> ww)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;w[tot]=ww;</span><br><span class="line">	nxt[tot]=head[u];head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	dist[s][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	vis[s]=<span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> qhead; q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		qhead=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[qhead]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[qhead];i;i=nxt[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[to[i]][<span class="number">0</span>]&gt;dist[qhead][<span class="number">0</span>]+w[i])&#123;</span><br><span class="line">				dist[to[i]][<span class="number">0</span>]=dist[qhead][<span class="number">0</span>]+w[i];</span><br><span class="line">				<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">					vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dist[to[i]][<span class="number">1</span>]&gt;dist[qhead][<span class="number">1</span>]+w[i])&#123;</span><br><span class="line">				dist[to[i]][<span class="number">1</span>]=dist[qhead][<span class="number">1</span>]+w[i];</span><br><span class="line">				<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">					vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dist[to[i]][<span class="number">1</span>]&gt;dist[qhead][<span class="number">0</span>]+w[i]-deli[to[i]])&#123;</span><br><span class="line">				dist[to[i]][<span class="number">1</span>]=dist[qhead][<span class="number">0</span>]+w[i]-deli[to[i]];</span><br><span class="line">				<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">					vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;dining.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;dining.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="built_in">fcin</span>(k);</span><br><span class="line">	<span class="type">int</span> x,y,z,fx,fy;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y,z);<span class="built_in">Eadd</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(deli,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(deli));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		deli[x]=<span class="built_in">max</span>(deli[x],y);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(deli[n]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SPFA</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist[i][<span class="number">0</span>]&gt;=dist[i][<span class="number">1</span>]) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
        <tag>并查集</tag>
        <tag>模拟</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>递推 | 矩阵 | SPFA | 模拟 | 数论 | 20190723考  试：解题报告</title>
    <url>/2019/07/23/2019-07-23-190723%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. traffic</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$128$ MB</td>
</tr>
<tr>
<td style="text-align:center">2. paint</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$512$ MB</td>
</tr>
<tr>
<td style="text-align:center">3. airline</td>
<td style="text-align:center">$1000$ MS</td>
<td style="text-align:center">$128$ MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-车流量（traffic-cpp）"><a href="#1-车流量（traffic-cpp）" class="headerlink" title="1. 车流量（traffic.cpp）"></a>1. 车流量（traffic.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>工人打算用一组传感器测量公路上的车流量，每个传感器被用来测量一小段路面上的车流量的数值。不幸的是，某一天装有传感器的盒子进了水，之后它们就不能精确的测量了。现在每个传感器只能输出一个可能结果的范围。例如，一个传感器可能会给出范围[7,13]，表示在这段路面上的车流量不小于7，并且不大于13。</p>
<p>高速路要测量的这一段长N英里，当然高速路都是单向的，从第1英里驶向第N英里。工人想要安装N个传感器——每个监测1英里长的路段。在其中某些路段上，有能够使得车辆进入高速公路的上匝道，在这样的路段上，工人会将传感器装在上匝道上，测量流入的车流量。在某些路段上有能够使得车辆离开高速公路的下匝道，在这样的路段上，工人会将传感器装在下匝道上。每一个路段包含至多一个匝道。如果在公路的一个路段上没有上匝道或下匝道，工人就将传感器装在高速公路的主路上。</p>
<p>给定N个传感器的读数，请求出在高速公路第1英里之前和第N英里之后车流量的最为准确的可能范围。这些范围应当与所有N个传感器的读数相一致。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含N（1≤N≤100）。余下N行每行按从第1英里至第N英里的顺序描述一段1英里长的路段。每行包含一个字符串，为”on”（如果这段路上有一个上匝道），”off”（如果这段路上有一个下匝道），或者是”none”（如果这段路上没有匝道），然后是两个范围为0…1000的整数，表示这段路上的传感器的读数所给出的下界、上界。至少一个高速公路路段的描述会是”none”。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出的第一行包含两个整数，为第1英里之前的车流量的最准确的可能范围。第二行包含两个整数，为第N英里之后的车流量的最准确的可能范围。输入保证存在符合要求的解。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">on 1 1</span><br><span class="line">none 10 14</span><br><span class="line">none 11 15</span><br><span class="line">off 2 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10 13</span><br><span class="line">8 12</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>在这个例子中，路段2和路段3的读数组合在一起告诉我们通过这两个路段的车流量为范围$[11,14]$之间的某个值，因为只有这个范围与两个读数$[10,14]$和$[11,15]$均一致。在第1英里，恰有1单位的车辆通过上匝道进入，所以在第1英里之前，车流量一定在范围$[10,13]$之内。在第4英里，2单位到3单位之间的车辆通过下匝道离开，所以这段路之后可能的车流量范围为$[8,12]$。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>简单的模拟</strong>，可以通过预处理<strong>把连续的且没有匝道的路段的 L，R 值取交集，把有匝道的连续路段合并起来计算影响流量可能的最大值和最小值</strong></p>
<p>要计算 1 英里之前的流量，从前往后扫一遍，遇到有匝道的就计算和更新造成影响的最大值和最小值，遇到没有匝道的就与当前的答案取交集（此时要把影响加上去），对于 N 英里之后的流量，可以当作是反过来求 1 英里之前的流量，所以反着再扫一遍，把上下道造成的影响反过来计算即可</p>
<p><del>考试的时候因为没有全部扫一遍只得了 70 分……（我真是越来越弱了）</del></p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 101</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> L,R;<span class="type">int</span> k;</span><br><span class="line">	<span class="comment">// k=0,1,2 ==&gt; on,none,off </span></span><br><span class="line">&#125;a[maxn],road[maxn];</span><br><span class="line"><span class="type">int</span> n,cnt; <span class="type">char</span> op[<span class="number">11</span>];</span><br><span class="line"><span class="function">node <span class="title">calc</span><span class="params">(node x,node y,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">	node z;</span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">1</span>) z=&#123;<span class="built_in">max</span>(x.L,y.L),<span class="built_in">min</span>(x.R,y.R),cnt&#125;;</span><br><span class="line">	<span class="keyword">else</span> z=&#123;x.L+y.L,x.R+y.R,cnt&#125;;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		node T=a[i];i++;</span><br><span class="line">		<span class="keyword">while</span>(a[i].k==T.k)&#123;</span><br><span class="line">			T=<span class="built_in">calc</span>(T,a[i],T.k);</span><br><span class="line">			i++;</span><br><span class="line">		&#125; road[++cnt]=T;i--;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	node ansR=(node)&#123;<span class="number">-2139062143</span>,<span class="number">2139062143</span>&#125;,ansL=(node)&#123;<span class="number">-2139062143</span>,<span class="number">2139062143</span>&#125;;</span><br><span class="line">	<span class="type">int</span> deltaL=<span class="number">0</span>,deltaR=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Get ansL </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(road[i].k==<span class="number">0</span>)&#123;</span><br><span class="line">			deltaL+=road[i].L;</span><br><span class="line">			deltaR+=road[i].R;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(road[i].k==<span class="number">1</span>)&#123;</span><br><span class="line">			ansL.L=<span class="built_in">max</span>(ansL.L,road[i].L-deltaR);</span><br><span class="line">			ansL.R=<span class="built_in">min</span>(ansL.R,road[i].R-deltaL);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			deltaL-=road[i].R;</span><br><span class="line">			deltaR-=road[i].L;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; deltaL=<span class="number">0</span>;deltaR=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">max</span>(ansL.L,<span class="number">0</span>),<span class="built_in">max</span>(ansL.R,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cnt;i;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(road[i].k==<span class="number">0</span>)&#123;</span><br><span class="line">			deltaL-=road[i].R;</span><br><span class="line">			deltaR-=road[i].L;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(road[i].k==<span class="number">1</span>)&#123;</span><br><span class="line">			ansR.L=<span class="built_in">max</span>(ansR.L,road[i].L-deltaR);</span><br><span class="line">			ansR.R=<span class="built_in">min</span>(ansR.R,road[i].R-deltaL);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			deltaL+=road[i].L;</span><br><span class="line">			deltaR+=road[i].R;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,<span class="built_in">max</span>(ansR.L,<span class="number">0</span>),<span class="built_in">max</span>(ansR.R,<span class="number">0</span>)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;traffic.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;traffic.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);<span class="built_in">fcin</span>(a[i].L);<span class="built_in">fcin</span>(a[i].R);</span><br><span class="line">		<span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">&#x27;n&#x27;</span>) a[i].k=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">&#x27;o&#x27;</span>) a[i].k=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> a[i].k=<span class="number">2</span>;</span><br><span class="line">	&#125; <span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-刷墙（paint-cpp）"><a href="#2-刷墙（paint-cpp）" class="headerlink" title="2. 刷墙（paint.cpp）"></a>2. 刷墙（paint.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>Todobe要把她的寝室弄得漂漂酿酿，所以她管Yashem66要了一些墙纸。</p>
<p>Todobe有一面墙，可分为n块，Yashem66提供的所有墙纸都是统一规格的，均只可覆盖连续k块完整的墙面，但是有m种不同的颜色的墙纸，每种颜色的墙纸都有无限张。Todobe要用这些墙纸把墙贴满，墙纸不可以裁剪，墙纸与墙纸之间可以有重叠部分。当墙纸重叠时，只能看到最外层的墙纸颜色。</p>
<p>Todobe想知道她以不同的方式贴墙纸，共能贴出多少种不同配色方案的墙面，两种方案不同当且仅当两种方案中至少有一块墙面的颜色不同。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>输入一行3个整数n,m,k。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个整数代表方案数量，答案取模1e9+7。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input #1"></a>Sample Input #1</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 2 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output #1"></a>Sample Output #1</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input #2"></a>Sample Input #2</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10 4 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output #2"></a>Sample Output #2</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">371740</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>对于样例输入1，我们假设两种颜色分别是A,B</p>
<p>那么6种方案分别是：AAA，AAB，ABB，BAA，BBA，BBB</p>
<p>【数据范围与约定】</p>
<p>对于0%的数据，与样例数据相同;</p>
<p>对于20%的数据，n&lt;=10,m&lt;=5;</p>
<p>对于另20%的数据n&lt;=500; </p>
<p>对于另20%的数据n&lt;=10^5;</p>
<p>对于100%的数据n&lt;=2^31-1,m&lt;=10^5，k&lt;=100。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>应该是考试中最难的题了，这道题正向思考不好想，可以逆向考虑一下，每种墙纸都能覆盖连续 $k$ 块墙，它们之间又可以相互覆盖，可以知道，<strong>不管墙纸之间的覆盖关系如何，一定存在一种颜色看起来连续覆盖了 $k$ 块墙面，一旦满足这个条件，剩下的 $n-k$ 块墙面形成的任何的颜色和顺序都是可以通过覆盖得到的合法方案</strong>，所以想到合法的方案数应该是所有方案数减去不合法的方案数</p>
<p>由于 $n$ 块墙，每块墙都有可能涂上 $1\to m$ 的颜色，总的方案数应该为 $m^n$ 种（不考虑连续 $k$ 块为同一种颜色），设 $f[i]$ 表示涂到第 $i$ 块墙都没有连续 $k$ 块墙是一种颜色的方案数， 则 $ans=m^n-f[n]$，考虑怎么递推得到 $f[n]$</p>
<p>可以发现此处 $f[n]$ 的定义和 <strong>核电站问题</strong> 中的 $f[n]$ 定义很相似，考虑 <strong>核电站问题</strong> 中的 $f[n]$ ，要使得前 $n$ 个反应堆不爆炸，若在 $n$ 位置不放反应堆，那么只需 $n-1$ 位置不爆炸即可，若在 $n$ 位置放反应堆而不在 $n-1$ 位置放，则需要 $n-2$ 位置不爆炸，以此类推到 $n-k$ 位置，那么就得到：</p>
<p>$f[n]=\sum_{i=n-k}^{n-1}f[i]$，特别地，当 $n&lt;k$ 时，$f[n]=2^n$</p>
<p>那么这个题在 $n\geq k$ 时和 <strong>核电站问题</strong> 非常相似，在 $n&lt;k$ 时可以选择的有 $m-1$ 种颜色（除了自己之外），那么递推方程为：</p>
<p>$f[n]=\left(\sum_{i=n-k}^{n-1}f[i]\right)\times (m-1)$，特别地，当 $n&lt;k$ 时，$f[n]=m^n$</p>
<p><strong>得到了这个方程还没完，由于 $n\leq 2^{31}-1$，直接计算显然会超时，考虑用矩阵加速计算：</strong></p>
<p>设：$F(k)=\begin{bmatrix}f(k)&amp;f(k-1)&amp;f(k-2)&amp;…&amp;f(1)\end{bmatrix}$</p>
<p>则：$F(k+1)=\begin{bmatrix}f(k+1)&amp;f(k)&amp;f(k-1)&amp;…&amp;f(2)\end{bmatrix}$</p>
<p>考虑 $F(k) \times A=F(k+1)$，演算得到 $A$ 的表达式为：</p>
<p>$A=\begin{bmatrix}m-1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;…&amp;0\\ m-1&amp;0&amp;1&amp;0&amp;0&amp;0&amp;…&amp;0\\ m-1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;…&amp;0\\ m-1&amp;0&amp;0&amp;0&amp;1&amp;0&amp;…&amp;0\\ m-1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;…&amp;0\\ …&amp;…&amp;…&amp;…&amp;…&amp;…&amp;…&amp;…\\ m-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;…&amp;1\end{bmatrix}$，然后找规律，发现一共有 $k-1$ 行，$k$ 列，且第一列的数都为 $m-1$，除去第一列的矩阵对角线上为 $1$ ，其他地方为 $0$</p>
<p>此时 $F(n)=F(k)\times A^{n-k}$ ，用 <strong>矩阵快速幂</strong> 就可以提高运算的速度了</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span>&#123; </span><br><span class="line">    ll val[maxn][maxn];</span><br><span class="line">    <span class="type">int</span> row,col; <span class="comment">// 行 列  </span></span><br><span class="line">    <span class="built_in">mat</span>(<span class="type">int</span> n=<span class="number">-1</span>,<span class="type">int</span> m=<span class="number">-1</span>,<span class="type">int</span> __sourceval=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">-1</span> &amp;&amp; m==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        row=n; col=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=col;j++) </span><br><span class="line">                val[i][j]=__sourceval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=col;j++) cout&lt;&lt;val[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;val[i][j];</span><br><span class="line">        row=n;col=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=col;j++) cin&gt;&gt;val[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    mat <span class="keyword">operator</span> *(<span class="type">const</span> mat &amp;obj)<span class="type">const</span>&#123; </span><br><span class="line">        <span class="comment">// 矩阵乘法   </span></span><br><span class="line">        <span class="function">mat <span class="title">ret</span><span class="params">(row,obj.col,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=obj.col;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=col;k++)</span><br><span class="line">                    ret.val[i][j]+=val[i][k]*obj.val[k][j];</span><br><span class="line">        ret.row=row;</span><br><span class="line">        ret.col=obj.col;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mat <span class="title">mul</span><span class="params">(mat B,ll md)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 矩阵 a*b % p </span></span><br><span class="line">        <span class="function">mat <span class="title">ret</span><span class="params">(row,B.col,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=B.col;j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=col;k++)</span><br><span class="line">                    (ret.val[i][j]+=</span><br><span class="line">                    val[i][k]*B.val[k][j])%=md;</span><br><span class="line">        ret.row=row;</span><br><span class="line">        ret.col=B.col;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll m,n,k,ans;</span><br><span class="line"><span class="function">ll <span class="title">Quickpow</span><span class="params">(ll b,ll p,ll K)</span></span>&#123;</span><br><span class="line">	ll sol=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">1</span>) sol=(sol*b)%K;</span><br><span class="line">		b=(b*b)%K;</span><br><span class="line">		p/=<span class="number">2</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> sol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">mat <span class="title">Fastpow</span><span class="params">(mat A,ll b,ll p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵快速幂 </span></span><br><span class="line">    <span class="function">mat <span class="title">res</span><span class="params">(A.row,A.col)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=res.row;i++) res.val[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res.<span class="built_in">mul</span>(A,p);</span><br><span class="line">        A=A.<span class="built_in">mul</span>(A,p);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;paint.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;paint.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;k--;</span><br><span class="line">	ans=<span class="built_in">Quickpow</span>(m,n,mod);</span><br><span class="line">	<span class="function">mat <span class="title">A</span><span class="params">(<span class="number">1</span>,k)</span>,<span class="title">T</span><span class="params">(k,k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	A.val[<span class="number">1</span>][k]=m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>;i;i--) A.val[<span class="number">1</span>][i]=(A.val[<span class="number">1</span>][i+<span class="number">1</span>]*m%mod);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) T.val[i][<span class="number">1</span>]=m<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) T.val[i][i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	T=<span class="built_in">Fastpow</span>(T,n-k,mod);A=A.<span class="built_in">mul</span>(T,mod);</span><br><span class="line">	ans=(ans-A.val[<span class="number">1</span>][<span class="number">1</span>]+mod)%mod;cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-航线（airline-cpp）"><a href="#3-航线（airline-cpp）" class="headerlink" title="3. 航线（airline.cpp）"></a>3. 航线（airline.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>Farmer John正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到T个城镇 (1 &lt;= T &lt;= 25,000)，编号为1到T。这些城镇之间通过R条道路 (1 &lt;= R &lt;= 50,000，编号为1到R) 和P条航线 (1 &lt;= P &lt;= 50,000，编号为1到P) 连接。每条道路i或者航线i连接城镇Ai (1 &lt;= Ai &lt;= T)到Bi (1 &lt;= Bi &lt;= T)，花费为Ci。对于道路，0 &lt;= Ci &lt;= 10,000；然而航线的花费很神奇，花费Ci可能是负数(-10,000 &lt;= Ci &lt;= 10,000)。道路是双向的，可以从Ai到Bi，也可以从Bi到Ai，花费都是Ci。然而航线与之不同，只可以从Ai到Bi。事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从Ai到Bi，那么保证不可能通过一些道路和航线从Bi回到Ai。由于FJ的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇S(1 &lt;= S &lt;= T) 把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第1行：四个空格隔开的整数: T, R, P, and S </p>
<p>第2到R+1行：三个空格隔开的整数（表示一条道路）：Ai, Bi 和 Ci</p>
<p>第R+2到R+P+1行：三个空格隔开的整数（表示一条航线）：Ai, Bi 和 Ci</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>第1到T行：从S到达城镇 i 的最小花费，如果不存在输出”NO PATH”。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6 3 3 4</span><br><span class="line">1 2 5</span><br><span class="line">3 4 5</span><br><span class="line">5 6 10</span><br><span class="line">3 5 -100</span><br><span class="line">4 6 -100</span><br><span class="line">1 3 -10</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NO PATH</span><br><span class="line">NO PATH</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">-95</span><br><span class="line">-100</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>【样例输入解释】</p>
<p>一共六个城镇。在1-2，3-4，5-6之间有道路，花费分别是5，5，10。同时有三条航线：3-&gt;5，</p>
<p>4-&gt;6和1-&gt;3，花费分别是-100，-100，-10。FJ的中心城镇在城镇4。</p>
<p>【样例输出解释】</p>
<p>FJ的奶牛从4号城镇开始，可以通过道路到达3号城镇。然后他们会通过航线达到5和6号城镇。</p>
<p>但是不可能到达1和2号城镇。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这个题看似是 SPFA 的裸题（实际上也差不多），但是根据 USACO 的尿性，一定会出几个稠密图的测试点来卡 SPFA，因此需要设计一些优化算法</p>
<blockquote>
<p><strong>做法一：SPFA + SLF 优化</strong></p>
</blockquote>
<h4 id="SPFA-的-SLF-优化（Small-Label-First）"><a href="#SPFA-的-SLF-优化（Small-Label-First）" class="headerlink" title="SPFA 的 SLF 优化（Small Label First）"></a>SPFA 的 SLF 优化（Small Label First）</h4><p><strong>优化思路</strong>：将原队列改成双端队列，对要加入队列的点 $p$，如果 $dist[p]$ 小于队头元素 $u$ 的 $dist[u]$，将其插入到队头，否则插入到队尾。</p>
<p><strong>实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  	...</span><br><span class="line">    <span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.empty &amp;&amp; dist[to[i]]&lt;dist[q.<span class="built_in">front</span>()]) q.<span class="built_in">push_front</span>(to[i]);</span><br><span class="line">        <span class="keyword">else</span> q.<span class="built_in">push_back</span>(to[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SPFA-的-LLL-优化（Large-Label-Last）"><a href="#SPFA-的-LLL-优化（Large-Label-Last）" class="headerlink" title="SPFA 的 LLL 优化（Large Label Last）"></a>SPFA 的 LLL 优化（Large Label Last）</h4><p><strong>优化思路</strong>：对每个要出队的队头元素 $u$，比较 $dist[u]$ 和队列中点的 $dist$ 的平均值，如果 $dist[u]$ 更大，将其弹出放到队尾，然后取队首元素进行相同操作，直到队头元素的 $dist$ 小于等于平均值。</p>
<p><strong>实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(dist[q.<span class="built_in">front</span>()]*cnt&gt;sum)&#123;</span><br><span class="line">        x=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();q.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲道理这 2 个优化方式互不干扰，结合使用应该效果会更好的，但是实际测试却是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">优化方式</th>
<th style="text-align:center">通过测试点数目（/16）</th>
<th style="text-align:center">得分（/100）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SPFA</td>
<td style="text-align:center">13</td>
<td style="text-align:center">87</td>
</tr>
<tr>
<td style="text-align:center">SPFA + SLF + LLL</td>
<td style="text-align:center">13</td>
<td style="text-align:center">87</td>
</tr>
<tr>
<td style="text-align:center">SPFA + SLF</td>
<td style="text-align:center">16</td>
<td style="text-align:center">100</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>做法二：SPFA + 强连通分量缩点 优化</strong></p>
</blockquote>
<p>根据题意可以发现图中不可能存在负环的情况（无向边构成的环一定是正环），<strong>而且通过 $A\to B$ 后就不可能再回到 $A$ 了，结合题目中存在有向边，可以发现原图非常像一个有向无环 DAG 图</strong>，只要把所有构成环的无向边缩点，就可以在新的图上跑 SPFA 了</p>
<p>对于 $dist[u]$，若 $u$ 和 $s$ 处在同一个连通分量内，则直接在里面 SPFA，否则就先预处理出 $dist[p]$ 的值，其中 $p$ 是连通分量的代表，然后设 $S$ 代表 $s$ 所处的连通分量（缩点后的新点），则 $dist[u]=dist[p]+dist’[S]$</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 25001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 150001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],w[maxm],nxt[maxm];</span><br><span class="line"><span class="type">int</span> head[maxn],tot,dist[maxn];</span><br><span class="line"><span class="type">int</span> T,R,P,S;<span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PAIR</span>&#123;</span><br><span class="line">	<span class="type">int</span> dis,node;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> PAIR &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dis&lt;obj.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> W)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	w[tot]=W;head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="comment">// advanced by SLF </span></span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">127</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	deque&lt;<span class="type">int</span>&gt; q; <span class="type">int</span> x=<span class="number">0</span>,cnt=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push_back</span>(s);dist[s]=<span class="number">0</span>;vis[x]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		x=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=nxt[i])</span><br><span class="line">			<span class="keyword">if</span>(dist[to[i]]&gt;dist[x]+w[i])&#123;</span><br><span class="line">				dist[to[i]]=dist[x]+w[i];</span><br><span class="line">				<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">					vis[to[i]]=<span class="literal">true</span>;cnt++;sum+=dist[to[i]];</span><br><span class="line">					<span class="keyword">if</span>(!q.<span class="built_in">empty</span>() &amp;&amp; dist[to[i]]&gt;=dist[q.<span class="built_in">front</span>()]) q.<span class="built_in">push_back</span>(to[i]);</span><br><span class="line">					<span class="keyword">else</span> q.<span class="built_in">push_front</span>(to[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		vis[x]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;airline.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;airline.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fcin</span>(T);<span class="built_in">fcin</span>(R);<span class="built_in">fcin</span>(P);<span class="built_in">fcin</span>(S);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=R;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y,z);<span class="built_in">Eadd</span>(y,x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=P;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y,z);</span><br><span class="line">	&#125; <span class="built_in">SPFA</span>(S);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dist[i]==<span class="number">2139062143</span>) <span class="built_in">printf</span>(<span class="string">&quot;NO PATH&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dist[i]);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>SPFA</tag>
        <tag>模拟</tag>
        <tag>递推</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>自制的对拍器！</title>
    <url>/2019/07/24/2019-07-24-%E5%AF%B9%E6%8B%8D%E5%99%A8/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>对拍是帮助我们检验算法正确性（或者帮助我们死了用高级算法的心）的极其有效的方式</strong>，最近上网查了查对拍器的写法和检验器的写法，放一个比较花哨的对拍与检验器在这，有改进意见的 DALAO 们也可以提出来~</p>
<p>在开始之前，可能需要了解以下东西：</p>
<ol>
<li>整个对拍器并没有使用 <code>freopen</code> ，并且在对拍器头文件（以下有说明）里也不允许使用 <code>freopen</code>，因为<strong>对拍程序会频繁的在控制台和文件输入输出流之间切换</strong>，所以我采用的是 <code>ifstream</code> 和 <code>ofstream</code></li>
<li><code>ifstream</code> 和 <code>ofstream</code> 是对应输入输出流的数据类型，头文件为 <code>include &lt;fstream&gt;</code>，实例化以后可以用类似 <code>cin</code> 和 <code>cout</code> 的形式往文件里面输入内容或从文件里面读取内容，写入和读取的机制也和 <code>cin</code> 和 <code>cout</code> 相似，例如，往 <code>TEST.txt</code> 写入内容 <code>Hello World!</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream ofile;</span><br><span class="line">ofile.<span class="built_in">open</span>(<span class="string">&quot;TEST.txt&quot;</span>);</span><br><span class="line">ofile&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>由于在随机数生成时不需要用到 <code>ifstream</code>（就是说不用自己写）所以在此不多介绍，那么使用 <code>ofstream</code> 为经典的 A+B Problem 生成一组数据到 input.txt 里面，就是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">ofstream ofile;</span><br><span class="line">ofile.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">ofile&lt;&lt;<span class="built_in">rand</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="built_in">rand</span>();</span><br><span class="line">ofile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br></pre></td></tr></table></figure>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>我写的对拍程序包含以下几个部分：</p>
<ol>
<li>随机数头文件 data.h（注意不是CPP！直接将对拍的代码写到一个叫做 <code>makedata</code> 的无参数且为 <code>void</code> 型的函数里面即可，不写 <code>main()</code> 函数），头文件不用编译直接保存即可</li>
<li>标准程序 <code>std.exe</code> ，注意是编译好的可执行文件不是源代码 </li>
<li>要对拍的程序 <code>my.exe</code> ，注意是编译好的可执行文件不是源代码</li>
<li>统一的文件输入从 <code>testin.txt</code> 里面输入，输出时，标准程序输出到 <code>r_testout.txt</code>，要对拍的程序输出到 <code>testout.txt</code> （当然也可以进入检验器里面更改文件名）</li>
<li><strong>以上文件和检验器必须处在同一目录下</strong></li>
</ol>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ol>
<li>在下方复制检验器的源代码，编译后生成一个可执行文件，<strong>将上述的所有文件放到同一目录下</strong>，运行检验器</li>
<li>一来会提示你检查需要的程序以及文件（其中输出输出文件可以不用专门创建，但是一定要写在程序的文件输入输出的代码内并编译通过）确定无误后输入 <code>y</code>，随后输入数据组数就可以开始对拍了</li>
<li>如果要修改文件名，可以进入检验其源代码，修改对应的部分即可</li>
</ol>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="检验器源代码（Judge-cpp）"><a href="#检验器源代码（Judge-cpp）" class="headerlink" title="检验器源代码（Judge.cpp）"></a>检验器源代码（Judge.cpp）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;data.h&quot;</span> <span class="comment">// 随机数头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> op;<span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">1000001</span>],s2[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">	ifstream infile1,infile2,rdfile;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎使用对拍器！\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_BLUE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请确保以下文件与对拍器在同一目录内：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;对拍程序：std.exe\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;测试程序：my.exe\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;随机数头文件：data.h\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;对拍输出：r_testout.txt\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;测试输出：testout.txt\n&quot;</span>);</span><br><span class="line">	<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED |</span><br><span class="line">		FOREGROUND_GREEN | FOREGROUND_BLUE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;确定开始对拍请输入[y]\n&quot;</span>);</span><br><span class="line">	cin&gt;&gt;op;<span class="keyword">if</span>(op!=<span class="string">&#x27;y&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>); <span class="type">int</span> col=<span class="number">0</span>;<span class="type">bool</span> sign=<span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入数据组数：&quot;</span>);<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">makedata</span>();</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;my.exe&quot;</span>); <span class="comment">// 在这里修改要对拍的程序名</span></span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;std.exe&quot;</span>); col=<span class="number">0</span>;<span class="comment">// 在这里修改标准答案程序名</span></span><br><span class="line">		infile1.<span class="built_in">open</span>(<span class="string">&quot;testout.txt&quot;</span>);<span class="comment">// 在这里修改对拍程序输出文件的名字</span></span><br><span class="line">		infile2.<span class="built_in">open</span>(<span class="string">&quot;r_testout.txt&quot;</span>);<span class="comment">// 在这里标准程序输出文件的名字</span></span><br><span class="line">		<span class="keyword">while</span>(!infile1.<span class="built_in">eof</span>() &amp;&amp; !infile2.<span class="built_in">eof</span>())&#123;</span><br><span class="line">			col++;sign=<span class="literal">true</span>;</span><br><span class="line">			infile1.<span class="built_in">getline</span>(s1,<span class="number">1000000</span>);</span><br><span class="line">			infile2.<span class="built_in">getline</span>(s2,<span class="number">1000000</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s1,s2))&#123;</span><br><span class="line">				<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;#%d:	在第 %d 行，标准输出 %s，测试输出 %s\n&quot;</span>,i,col,s2,s1);</span><br><span class="line">				<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED |</span><br><span class="line">		FOREGROUND_GREEN | FOREGROUND_BLUE);sign=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sign)&#123;</span><br><span class="line">			<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;#%d:	测试输出与对拍输出一致\n&quot;</span>,i);</span><br><span class="line">			<span class="built_in">SetConsoleTextAttribute</span>(<span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED |</span><br><span class="line">		FOREGROUND_GREEN | FOREGROUND_BLUE);</span><br><span class="line">		&#125;</span><br><span class="line">		infile1.<span class="built_in">close</span>();</span><br><span class="line">		infile2.<span class="built_in">close</span>();</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">&quot;------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d 组&quot;</span>,n);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;echo 评测完成 &amp; pause&gt;nul&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="随机数源代码样例（data-h）"><a href="#随机数源代码样例（data-h）" class="headerlink" title="随机数源代码样例（data.h）"></a>随机数源代码样例（data.h）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makedata</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ofstream ofile;</span><br><span class="line">	ofile.<span class="built_in">open</span>(<span class="string">&quot;testin.txt&quot;</span>);<span class="comment">// 在这里指定输入文件的名字</span></span><br><span class="line">    <span class="comment">// 以下内容根据题目需要编写，生成符合题目的数据</span></span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">rand</span>()%<span class="number">40</span>;</span><br><span class="line">	ofile&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="built_in">rand</span>()%<span class="number">2000000</span>+<span class="number">2000000</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ofile&lt;&lt;<span class="built_in">rand</span>()%<span class="number">2000000</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎各位 DALAO 提出改进建议或者与我交流！！！</p>
<p>2019 / 07 / 24</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数论| 组合数学 | Polya定理：学习  笔记</title>
    <url>/2019/07/25/2019-07-25-Polya%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Polya-定理"><a href="#Polya-定理" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><p>Redfield-Polya （Pólya enumeration theorem，简称PET）定理是<a href="https://baike.baidu.com/item/组合数学/821134">组合数学</a>理论中最重要的定理之一。</p>
<p>其提出者波里亚在众多数学的分支：函数论、变分学、概率论、数论、组合数学以及计算数学和应用数学领域中，都颇有建树，他共发表了200多篇著名论文，以他的名字命名的Polya计数定理，则是近代组合数学的重要工具。波里亚还是杰出的数学教育家，有著丰富的数学教育思想和精湛的数学教学艺术，他对数学思维一般规律的研究，堪称是对人类思想宝库的特殊贡献。</p>
<p>Polya 定理可以用<strong>于解决关于集合互异状态的计数问题，是解决此类问题的简洁高效的一个工具</strong></p>
<h2 id="例题引入"><a href="#例题引入" class="headerlink" title="例题引入"></a>例题引入</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>把一个 $2\times 2$ 的方格棋盘用黑白两色涂色，规定经过旋转重合的图案是一种图案，问能涂出多少种不同的图案？</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>不考虑旋转，所有涂色方案如下图：</p>
<p><img src="https://s2.ax1x.com/2019/07/25/eeoH0g.png" alt="pic1"></p>
<p>可以发现图中共有 16 种涂色方案，<strong>但是把经过旋转的 $\begin{Bmatrix} 1&amp;2&amp;3&amp;4 \end{Bmatrix}$，$\begin{Bmatrix} 5&amp;6&amp;7&amp;8 \end{Bmatrix}$，$\begin{Bmatrix} 9&amp;10&amp;11&amp;12 \end{Bmatrix}$，$\begin{Bmatrix} 13&amp;14 \end{Bmatrix}$ 都算作一种方案，我们发现方案数其实只有 6 种</strong></p>
<p>问题规模较小时，我们固然可以通过枚举所有可能的情况计算得出满足题目条件的情况数目，但如果我们面对了一个 $20\times 20$，甚至 $200\times 200$，穷举算法在那时将会达到 $O(2^{200})$ 的时间复杂度，就连计算机也不能保证在有生之年给我们问题的答案</p>
<p>于是，数学家就开始研究这类问题的共性，试图得出这类问题的通式，然后就有了 <strong>Polya 定理</strong></p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>若一个一个集合 $G$ 和二元运算 $a \bullet b$ ，满足下列条件：</p>
<ol>
<li><strong>封闭性：</strong>对于 $\forall a,\;b\in G$，有 $(a \bullet b)\in G$</li>
<li><strong>结合律：</strong>对于 $\forall a,\;b,\;c\in G$，有 $(a\bullet b)\bullet c=a\bullet (b\bullet c)$ </li>
<li><strong>单位元：</strong>对于 $\forall a\in G$， 存在 $e\in G$，使得 $a\bullet e=a$</li>
<li><strong>逆元：</strong>对于 $\forall a\in G$，存在 $f\in G$，使得 $a\bullet f=f\bullet a=e$，且记 $f=a^{-1}$</li>
</ol>
<p><strong>则称集合 $G$ 是运算法则 $\bullet$ 下的一个群， $\bullet$ 通常表示乘法运算，此时则称 $G$ 是一个乘法群</strong></p>
<p>一个简单的例子：对于 $\forall a\in Z$，即所有整数组成的集合，在加法原则下满足上面四个条件，其中 1，2 很好解释，单位元则是 0，逆元则是 $a$ 的对应相反数，这个群便叫做 <strong>整数加法群</strong></p>
<p>群按照集合中元素个数分为 <strong>无限群</strong> 和 <strong>有限群</strong>，<strong>Polya定理</strong> 主要针对有限群进行分析操作</p>
<h3 id="置换和置换群"><a href="#置换和置换群" class="headerlink" title="置换和置换群"></a>置换和置换群</h3><p>简单来说，<strong>置换就是把集合 $A$ 中的所有元素 $a_i$ 重新排列，形成集合 $B$，然后做映射</strong> $a_i \to b_i,\;i\in[1,\;n]$ ，例如：</p>
<p>$\begin{pmatrix} 1&amp;2&amp;3&amp;4\\2&amp;3&amp;4&amp;1 \end{pmatrix}$，下面的 $\begin{pmatrix} 2&amp;3&amp;4&amp;1 \end{pmatrix}$，就是对上面的 $\begin{pmatrix} 1&amp;2&amp;3&amp;4 \end{pmatrix}$ 的重新排列，并映射 $1\to2$，$2\to3$，$3\to4$，$4\to1$，置换群就是 <strong>若干个置换组成的集合和置换之间的二元运算法则构成的群</strong>，这种置换之间的二元运算法则可以理解成是 <strong>连续映射（或者是向量求和）</strong>，例如置换之间的运算：（运算符定义为 $\bullet$ ）</p>
<p>$\begin{pmatrix} 1&amp;2&amp;3&amp;4\\3&amp;1&amp;2&amp;4 \end{pmatrix} \bullet \begin{pmatrix} 1&amp;2&amp;3&amp;4\\4&amp;3&amp;2&amp;1 \end{pmatrix}=\begin{pmatrix} 1&amp;2&amp;3&amp;4\\3&amp;1&amp;2&amp;4 \end{pmatrix} \bullet \begin{pmatrix} 3&amp;1&amp;2&amp;4\\2&amp;4&amp;3&amp;1 \end{pmatrix} = \begin{pmatrix} 1&amp;2&amp;3&amp;4\\2&amp;4&amp;3&amp;1\end{pmatrix}$</p>
<p><strong>可以发现运算结果是连续映射的结果</strong>，如 $1\to3\to2$，$2\to1\to4$，$3\to2\to3$，$4\to4\to1$</p>
<p><strong>可以证明，这样的运算法则和置换之间构成的集合满足构成群的 4 个条件</strong></p>
<p>现在，<strong>设顺时针转动 0度，90度，180度，270度 为原来的 16 种方案的四个置换</strong>，可以得到：</p>
<p>$\begin{pmatrix} a_1=&amp;1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8&amp;9&amp;10&amp;11&amp;12&amp;13&amp;14&amp;15&amp;16\\ a_2=&amp;2&amp;3&amp;4&amp;1&amp;6&amp;7&amp;8&amp;5&amp;12&amp;11&amp;9&amp;10&amp;14&amp;13&amp;15&amp;16\\ a_3=&amp;3&amp;4&amp;1&amp;2&amp;7&amp;8&amp;5&amp;6&amp;10&amp;9&amp;12&amp;11&amp;13&amp;14&amp;15&amp;16\\ a_4=&amp;4&amp;1&amp;2&amp;3&amp;8&amp;5&amp;6&amp;7&amp;11&amp;12&amp;10&amp;9&amp;14&amp;13&amp;15&amp;16 \end{pmatrix}$</p>
<p>下面，我们对上述 4 种置换深入研究</p>
<h4 id="不动置换类：-Z-K"><a href="#不动置换类：-Z-K" class="headerlink" title="不动置换类：$Z_K$"></a>不动置换类：$Z_K$</h4><p>设 $G$ 是 $1……n$ 的一个置换群，且 $K$ 是 $G$ 的集合中的一个元素，<strong>$G$ 中使得 $K$ 映射之后不变的置换组成的集合称之为 K不动置换类</strong>：$Z_K$，通常用 $\lvert Z_K \rvert$ 表示这个集合当中的元素个数，如上述例子中：</p>
<ol>
<li>K=1 时，使得 1 在映射之后保持不变的置换只有 $a_1$，故 $Z_1=\begin{Bmatrix} a_1 \end{Bmatrix}$，$\lvert Z_1 \rvert=1$</li>
<li>K=13 时，使得 13 映射之后不变的置换只有 $a<em>1$，$a_3$，故 $Z</em>{13}=\begin{Bmatrix} a<em>1&amp;a_3 \end{Bmatrix}$，$\lvert Z</em>{13} \rvert=2$</li>
<li>K=15 时，使得 15 映射之保持不变的置换有 $a<em>1$，$a_2$，$a_3$，$a_4$，故 $Z</em>{15}=\begin{Bmatrix} a<em>1&amp;a_2&amp;a_3&amp;a_4 \end{Bmatrix}$，$\lvert Z</em>{15} \rvert=4$</li>
</ol>
<h4 id="等价置换类：-E-K"><a href="#等价置换类：-E-K" class="headerlink" title="等价置换类：$E_K$"></a>等价置换类：$E_K$</h4><p>设 $G$ 是 $1……n$ 的一个置换群，且 $K$ 是 $G$ 的集合中的一个元素，$K$ <strong>在 $G$ 中的置换作用下能变化到的元素组成的集合叫做 $K$ 的等价置换类：</strong>$E_K$，通常用 $\lvert E_K \rvert$ 表示这个集合当中的元素个数，如上述例子中：</p>
<ol>
<li>K=1 时，1 能变化到的元素集合为 $\begin{Bmatrix} 1&amp;2&amp;3&amp;4 \end{Bmatrix}$，故 $\lvert E_1 \rvert=4$</li>
<li>K=13 时，13 能变化到的元素集合为 $\begin{Bmatrix} 13&amp;14 \end{Bmatrix}$，故 $\lvert E_{13} \rvert=2$</li>
<li>K=15 时，15 能变化到的元素集合为 $\begin{Bmatrix} 15 \end{Bmatrix}$，故 $\lvert E_{15} \rvert=1$</li>
</ol>
<p>可以发现<strong>对于群 $G$ 中的任一元素 $K$，总有 $\lvert E_K \rvert \times \lvert Z_K \rvert = \lvert G \rvert$</strong>，证明过程较为复杂，在此不详细展开</p>
<h3 id="Burnside-引理"><a href="#Burnside-引理" class="headerlink" title="Burnside 引理"></a>Burnside 引理</h3><p>若设函数 $f(x,\;y)$ 表示元素 $x$ 在置换 $a_y$ 的映射下是否发生改变，并定义函数 $a_i(x)=y$ 表示 $x$ 在 $a_i$ 置换下的映射</p>
<p>则 $f(x,y)=\begin{cases} 1,\quad a_y(x)=x \\ 0, \quad a_y(x)\neq x \end{cases}$，下面我们看看对于上述 4 个有关旋转的置换中 $f(x,y)$ 的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元素 / 置换</th>
<th style="text-align:center">$a_1$</th>
<th style="text-align:center">$a_2$</th>
<th style="text-align:center">$a_3$</th>
<th style="text-align:center">$a_4$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">Sum()</td>
<td style="text-align:center">16</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p><strong>可以发现 $\sum<em>{i=1}^{16}\lvert Z_i \rvert=\sum</em>{j=1}^4Sum(j)$，其中 $Sum(j)$ 为上表中的 $a_j$ 对应列之和，也就是在置换 $a_j$ 下保持不变的元素个数</strong>，我们可以称经过旋转重合的多种涂色方案（至少 2 种）组成的集合为一个等价类 $E$，则原来的 16 种涂色方案中实际上包含了 4 个等价类，为 $\begin{Bmatrix} 1&amp;2&amp;3&amp;4 \end{Bmatrix}$，$\begin{Bmatrix} 5&amp;6&amp;7&amp;8 \end{Bmatrix}$，$\begin{Bmatrix} 9&amp;10&amp;11&amp;12 \end{Bmatrix}$，$\begin{Bmatrix} 13&amp;14 \end{Bmatrix}$</p>
<p>可以发现当 $i$ 和 $j$ 同属一个等价类时，$\lvert Z_i \rvert = \lvert Z_j \rvert$，设原方案集合中存在 $m$ 个等价类</p>
<p>则 $\sum<em>{i=1}^n \lvert Z_i \rvert =\sum</em>{i=1}^m\sum<em>{K\in E_i}\lvert Z_K \rvert=\sum</em>{i=1}^m \lvert E_i \rvert \times \lvert Z_i \rvert=m \times \lvert G \rvert$，这个式子只是简单变形，本质和上述式子相同</p>
<p><strong>Burnside 引理：</strong>集合中存在的所有互异组合状态的个数就是等价类的个数，即 $m=\frac{\sum<em>{i=1}^n\lvert Z_i \rvert}{\lvert G \rvert}$，由于上述的等价关系也可以写成 $m=\frac{\sum</em>{j=1}^4Sum(j)}{\lvert G \rvert}$，这里的 $\lvert G \rvert$ 是指置换的个数，为 4</p>
<p>结合这个例子，我们发现 $m=\frac{16+2+4+2}{4}=6$，与枚举得到的答案吻合</p>
<p>有了 <strong>Burnside 引理</strong>，已经可以大大降低计数的时间复杂度了，可是我们发现 $Sum(j)$ 并不是那么的好算，现在直接采用搜索的方法的话将会达到 $O(n\times \lvert G \rvert \times N)$，分别表示元素个数（涂色的方案数），置换个数（此例中为4）和实际的方格数，显然还是会超时，<strong>Polya 算法就旨在寻找一种简便的计算 $Sum(j)$ 的方法，进一步优化</strong></p>
<h2 id="Polya-定理-1"><a href="#Polya-定理-1" class="headerlink" title="Polya 定理"></a>Polya 定理</h2><h3 id="高级循环"><a href="#高级循环" class="headerlink" title="高级循环"></a>高级循环</h3><p>记一种对于 $\begin{pmatrix} a_1&amp;a_2&amp;a_3&amp;……&amp;a_n \end{pmatrix}$ 的高级循环为它的一个置换，并满足：</p>
<p> $\begin{pmatrix} a_1&amp;a_2&amp;a_3&amp;……&amp;a_n \end{pmatrix} \Rightarrow \begin{pmatrix} a_1&amp;a_2&amp;a_3&amp;……&amp;a_n \\ a_2&amp;a_3&amp;a_4&amp;……&amp;a_1  \end{pmatrix} $，这样的涉及 $n$ 个元素的高级循环称之为 <strong>n阶循环</strong></p>
<p><strong>每个置换都可以由若干个互不相交的循环组成（互不相交是指两个循环没有公共元素）如：</strong></p>
<p>$ \begin{pmatrix} 1&amp;2&amp;3&amp;4&amp;5 \\ 3&amp;5&amp;1&amp;4&amp;2  \end{pmatrix}= \begin{pmatrix} 1&amp;3  \end{pmatrix} \bullet \begin{pmatrix} 2&amp;5  \end{pmatrix} \bullet \begin{pmatrix} 4  \end{pmatrix} = \begin{pmatrix} 1&amp;3 \\ 3&amp;1  \end{pmatrix} \bullet \begin{pmatrix} 2&amp;5 \\ 5&amp;2  \end{pmatrix} \bullet \begin{pmatrix} 4 \\ 4  \end{pmatrix}$，（定义 $\bullet$ 表示连接或合并）</p>
<p>对于每个置换都有且仅有这样一种被表示为循环的方式，且定义循环节的个数 $C$ 为组成的循环个数，如上例中循环节数 $C=3$</p>
<p>按照上述规则，给 $2\times 2$ 的方格编号，旋转之后如图：</p>
<p><img src="https://s2.ax1x.com/2019/07/25/emp8eA.png" alt="pic2"></p>
<p>定义 4 个置换为：转 0度，90度，180度，270度，用 $g$ 表示置换，$C(g)$ 表示置换对应的循环节个数，则：</p>
<ol>
<li><p>转 0 度时，$g_1=\begin{pmatrix} 1&amp;2&amp;3&amp;4 \\ 1&amp;2&amp;3&amp;4  \end{pmatrix}=(1)\bullet(2)\bullet(3)\bullet(4)$，故 $C(g_1)=4$</p>
</li>
<li><p>转 90 度时，$g_2=\begin{pmatrix} 1&amp;2&amp;3&amp;4 \\ 3&amp;2&amp;4&amp;1  \end{pmatrix}=(4\quad 3\quad2\quad 1)$，故 $C(g_2)=1$</p>
</li>
<li><p>转 180 度时，$g_3=\begin{pmatrix} 1&amp;2&amp;3&amp;4 \\ 3&amp;4&amp;1&amp;2  \end{pmatrix}=(1\quad 3)\bullet(2\quad 4)$，故 $C(g_3)=2$</p>
</li>
<li><p>转 270 度时，$g_4=\begin{pmatrix} 1&amp;2&amp;3&amp;4 \\ 2&amp;1&amp;4&amp;3  \end{pmatrix}=(1\quad 2\quad 3\quad 4)$，故 $C(g_4)=1$</p>
</li>
</ol>
<p>进一步研究发现，$Sum(i)=2^{C(g_i)}$，也就是说，<strong>该置换下不变的涂色方案数和以它对应的循环节个数为指数，涂色选择数为底数的幂相同</strong>，若有 $T$ 种颜色可以涂，则此处应为 $Sum(i)=T^{C(g_i)}$ </p>
<p><strong>Polya 定理：</strong>设 $G$ 是 $p$ 个对象的一个置换群，用 $T$ 种颜色染色 $p$ 个对象，则本质不同的方案数为：</p>
<p>$m=\frac{1}{\lvert G \rvert}\times \sum_{i=1}^sT^{C(g_i)}$，其中 $s$ 为置换的个数</p>
<p>利用 <strong>Polya 定理</strong> 的时间复杂度为 $O(s\times N)$，分别为置换的个数和格子总数，在前面的引理上实现了优化</p>
<h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>对于一开头提出的例子，利用 <strong>Polya 定理</strong> 求出表达式之后，其实还可以继续找规律，最后答案的方案数应为：<br>$m=\frac{1}{4}\times (T^{n^2}+T^{\frac{n^2+3}{4}}+T^{\frac{n^2+1}{2}}+T^{\frac{n^2+3}{4}})$</p>
<p>这与我们前面通过枚举和归纳表达式计算出来的结果完全一致</p>
<p>参考文献：<a href="https://wenku.baidu.com/view/bf92a95f804d2b160b4ec0be.html">Polya定理——符文杰</a></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>VB.NET | 2048小游戏！</title>
    <url>/2019/08/12/2019-08-12-2048%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<span id="more"></span>
<p><img src="https://s2.ax1x.com/2019/08/13/mCvc4O.png" alt="pic"></p>
<p>暑期刷题太无聊？来试一下这款弱智小游戏：<strong>2048</strong> ！</p>
<p>参考了网络上经典的 2048 玩法，附加 8×8，16×16 玩法，历时 2 天赶工完成的 <strong>2048</strong> 小游戏！</p>
<p>附1：下载链接（解压后，<code>A2048.exe</code> 就是游戏文件，注意 <code>images</code> 文件夹不能丢！）</p>
<p><a href="https://github.com/Yan2u/A-2048">https://github.com/Yan2u/A-2048</a></p>
<p>附2：比较简陋的游戏界面截图</p>
<p><img src="https://s2.ax1x.com/2019/08/14/mkTaut.png" alt="pic2"></p>
<p><img src="https://s2.ax1x.com/2019/08/14/mkTdDP.png" alt="pic3"></p>
<p><img src="https://s2.ax1x.com/2019/08/14/mkTNjI.png" alt="pic4"></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>VB.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟 | 珂朵莉树：学习笔记</title>
    <url>/2019/08/23/2019-08-23-%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="珂朵莉树：学习笔记"><a href="#珂朵莉树：学习笔记" class="headerlink" title="珂朵莉树：学习笔记"></a>珂朵莉树：学习笔记</h2><p>老司机树，ODT(Old Driver Tree)，又名珂朵莉树（Chtholly Tree)。</p>
<p>起源自 <a href="https://codeforces.com/problemset/problem/896/C">CF896C</a> 。因为这是第一道以此树 AC 的题，又是关于动漫角色 <a href="https://www.baidu.com/link?url=fKEr3qvW8yTxQcNeokB_X7TIeNPFa74y3_jnigC2NYTG8dtGa3h6XqG3u-C4Dn_xEzN-qFjurCC6XT53rmWnyyQx5NQrJFDZm2OkSrkBouL94MiWnRfDTh6lkD6h1ETm0TTYMMjKbEQAEA6MitOjSkPNYhppxw_rcPAfuaLueJkv1f064dClA8MOAaomH555VUGTONRpysQ7K_UvnR-gfYZQBENtEpiUi5Y06XYY_JuGPox3PXi3grxn7Smzge2I7q7lNp8T9xuZIKbWKiTvdbAdajdi34uC8oTxJQKzMFa&amp;wd=&amp;eqid=9da8851000300455000000065d608b73">珂朵莉</a> 的，故因此得名。</p>
<p>是一种非常暴力的数据结构，时间复杂度不好计算，且取决于数据的随机性，珂朵莉树可以用于带有区间覆盖的问题当中，且当覆盖操作比较多的时候，它能发挥出一定优势，<strong>所以珂朵莉树通常用于写不出正统解法时的骗分选择</strong></p>
<p><strong>要保证珂朵莉树的复杂度正确，数据必须随机（也就是出题人不会特意卡），<a href="http://codeforces.com/blog/entry/56135?#comment-398940">证明</a></strong></p>
<p>在很多题目中不是正统的解法，但是有些时候却比正统的解法跑得更快……</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>珂朵莉树的核心思想是：<strong>把值相同的区间合并成一个结点保存在 set 里面。</strong></p>
<p>因此一个树节点只包含三个信息：左右端点 $L,R$ ，和区间值 $v$，定义时注意值 $v$ 要用 <code>mutable</code> 修饰</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> v;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x, <span class="type">int</span> y=<span class="number">-1</span>, <span class="type">int</span> z=<span class="number">0</span>):<span class="built_in">L</span>(x), <span class="built_in">R</span>(y), <span class="built_in">v</span>(z) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; o)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> L &lt; o.L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><del>其实核心思想就很暴力了……</del></p>
<p>一下是珂朵莉树的几种基本操作，无一例外地，实现它们的方式都非常暴力</p>
<h3 id="关键操作：Split"><a href="#关键操作：Split" class="headerlink" title="关键操作：Split"></a>关键操作：Split</h3><p><strong><code>split</code> 是珂朵莉树的核心之一，用于从当前 <code>set</code> 中提取需要的区间结点便于操作</strong>，它会将一个大的区间结点 $[L,R]$ 分裂成两个区间结点，为 $[l,x-1]$ 和 $[x.R]$ ，一般情况下我们都会 <code>split</code> 两次，<code>split(r+1);split(l)</code></p>
<p><strong>注意一定要先 <code>split(r+1)</code>，之后我们会取得两个迭代器，这两个迭代器之间存储的就是操作区间内的结点了</strong></p>
<p>而关于 <code>split</code> 的写法也比较简单，就是暴力找到以 $x$ 作为左端点的结点，然后把原来的大结点直接 <code>erase</code> 掉，新插入两个小结点，返回后一个结点的迭代器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> se(X) set<span class="string">&lt;X&gt;</span>::iterator</span></span><br><span class="line"><span class="built_in">se</span>(node) <span class="built_in">split</span>(<span class="type">int</span> pos)&#123;</span><br><span class="line">	<span class="built_in">se</span>(node) iter=s.<span class="built_in">lower_bound</span>(<span class="built_in">node</span>(pos));</span><br><span class="line">	<span class="keyword">if</span>(iter!=s.<span class="built_in">end</span>() &amp;&amp; iter-&gt;L==pos) <span class="keyword">return</span> iter;</span><br><span class="line">	iter--; <span class="type">int</span> x=iter-&gt;L,y=iter-&gt;R; <span class="type">int</span> z=iter-&gt;v;</span><br><span class="line">	s.<span class="built_in">erase</span>(iter); s.<span class="built_in">insert</span>(<span class="built_in">node</span>(x,pos<span class="number">-1</span>,z));</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">insert</span>(<span class="built_in">node</span>(pos,y,z)).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键操作：fill（assign）"><a href="#关键操作：fill（assign）" class="headerlink" title="关键操作：fill（assign）"></a>关键操作：fill（assign）</h3><p><strong><code>assign</code> 是珂朵莉树用于处理区间覆盖问题的操作，能减少 set 中的结点个数</strong>，区间覆盖操作越多，set 中的节点个数越少，因此每次操作的时间复杂度会降低，这也是珂朵莉树在某些题目中跑的比正统解法快的原因之一吧</p>
<p><code>assign</code> 操作本身非常暴力，代码也很简洁，很好理解，就是先 <code>split</code> 得到覆盖的左右端点对应的迭代器，然后直接 <code>erase</code> 掉，插入一个新的结点……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> se(X) set<span class="string">&lt;X&gt;</span>::iterator</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fill</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="built_in">se</span>(node) iterr=<span class="built_in">split</span>(r+<span class="number">1</span>),iterl=<span class="built_in">split</span>(l);</span><br><span class="line">	s.<span class="built_in">erase</span>(iterl,iterr);s.<span class="built_in">insert</span>(<span class="built_in">node</span>(l,r,d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间加：add"><a href="#区间加：add" class="headerlink" title="区间加：add"></a>区间加：add</h3><p><strong>从区间加操作开始，以下操作全是基于 <code>for</code> 循环或 <code>while</code> 循环的纯暴力遍历来实现的</strong></p>
<p>区间加法，就是 <code>split</code> 得到区间左右端点对应的迭代器，然后遍历这些区间，逐一加上就行了……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> se(X) set<span class="string">&lt;X&gt;</span>::iterator</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="built_in">se</span>(node) iterr=<span class="built_in">split</span>(r+<span class="number">1</span>),iterl=<span class="built_in">split</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(;iterl!=iterr;iterl++) iterl-&gt;v+=d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间求和：sum"><a href="#区间求和：sum" class="headerlink" title="区间求和：sum"></a>区间求和：sum</h3><p>区间求和，也是先 <code>split</code> 然后再遍历，累加，注意中途要乘上区间长度，因为每个结点是一个值完全相同的区间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> se(X) set<span class="string">&lt;X&gt;</span>::iterator</span></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">se</span>(node) iterr=<span class="built_in">split</span>(r+<span class="number">1</span>),iterl=<span class="built_in">split</span>(l);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(iterl!=iterr)</span><br><span class="line">		ans=(ans+(ll)(iterl-&gt;R-iterl-&gt;L+<span class="number">1</span>)*iterl-&gt;v,</span><br><span class="line">		iterl++;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间第K小：kth"><a href="#区间第K小：kth" class="headerlink" title="区间第K小：kth"></a>区间第K小：kth</h3><p>个人感觉这是最暴力的操作了，因为这个操作不但遍历，而且中途还直接使用 <code>vector</code> 排序，计算的时候也要遍历 <code>vector</code>……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> se(X) set<span class="string">&lt;X&gt;</span>::iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line">	vector&lt;pr&gt; X;</span><br><span class="line">	<span class="built_in">se</span>(node) iterr=<span class="built_in">split</span>(r+<span class="number">1</span>),iterl=<span class="built_in">split</span>(l);</span><br><span class="line">	<span class="keyword">while</span>(iterl!=iterr) X.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(iterl-&gt;v,iterl-&gt;R-iterl-&gt;L+<span class="number">1</span>)),iterl++;</span><br><span class="line">	<span class="built_in">sort</span>(X.<span class="built_in">begin</span>(),X.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">ve</span>(pr) iter=X.<span class="built_in">begin</span>();iter!=X.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">		k-=iter-&gt;second;<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>珂朵莉树就是这么暴力的一种数据结构，然而在一些涉及到很多次区间覆盖的问题中却能够跑的很快<del>，果然还是 set 大法好啊……</del>，下面是可以用珂朵莉树 AC 的题选</p>
<p><em>P.S：以下题目的正統解法几乎都是线段树，写法正确的线段树也通常比珂朵莉树跑的快一些</em></p>
<ol>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1858">SCOI2010 序列操作</a>：珂朵莉树模板题，没什么好讲的</li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4592">SHOI2015 脑洞治疗仪</a>：几乎是模板题，注意判断正常脑组织够不够填补脑洞即可</li>
<li><a href="https://www.luogu.org/problemnew/show/P2787">LG2787 理理思维</a>：模板题，输入字符串的时候尽量先把相同的字符合成一个结点</li>
<li><p><a href="https://www.luogu.org/problemnew/show/P4979">LG4979 矿洞坍塌</a>：模板题，注意输出字符串的优化和题目要求的判断条件即可</p>
</li>
<li><p><a href="https://newoj.cqyz.cn/problem/P1204">USCAO1.2.1 挤牛奶</a>：这个<del>弱智</del>题也需要用珂朵莉树？是的！只要是区间覆盖都可以用它<del>骗分</del></p>
</li>
</ol>
<h3 id="附：珂朵莉美图欣赏"><a href="#附：珂朵莉美图欣赏" class="headerlink" title="附：珂朵莉美图欣赏"></a><del>附：珂朵莉美图欣赏</del></h3><p><img src="https://cn.bing.com/th?id=OIP.A7xyeywrZrZK-oE1V7uSsAAAAA&amp;pid=Api&amp;rs=1" alt="pic1"></p>
<p><img src="https://cn.bing.com/th?id=OIP.MLcLKPtJQR1bfUxOVMwnzgAAAA&amp;pid=Api&amp;rs=1" alt="pic2"></p>
<p><img src="http://www.3dmgame.com/uploads/allimg/180122/399_180122100132_1.jpg" alt="pic3"></p>
<p><img src="https://cn.bing.com/th?id=OIP.JZ32Uo8TRzip-iN8q5BYowAAAA&amp;pid=Api&amp;rs=1" alt="pic4"></p>
<p><img src="https://cn.bing.com/th?id=OIP.CZcQfhPzqn9OeI-tl0WKhQAAAA&amp;pid=Api&amp;rs=1" alt="pic5"></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>数论| SPFA | 图论 | 分治 | 20190820考试解  题报告</title>
    <url>/2019/08/20/2019-08-20-0820%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. agent</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">256 MB</td>
</tr>
<tr>
<td style="text-align:center">2. earth</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">256 MB</td>
</tr>
<tr>
<td style="text-align:center">3. aurora</td>
<td style="text-align:center">2000 MS</td>
<td style="text-align:center">512 MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-特工（agent-cpp）"><a href="#1-特工（agent-cpp）" class="headerlink" title="1. 特工（agent.cpp）"></a>1. 特工（agent.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>IMF(不可能任务小组)有<em>N</em>个Agent，每个Agent的能力值互不相同，现在部长先生想要派出<em>A</em>,<em>B</em>两队Agent去参加特别任务。但是参加大战的两个队伍要满足两个要求：</p>
<p><em>1.</em> <em>A</em>队中能力最大的Agent的能力值要小于<em>B</em>队能力最弱的Agent的能力值。</p>
<p><em>2.</em> <em>A</em>,<em>B</em>两队都要有人参加。</p>
<p>并不是所有的Agent都要去参加的，心急的部长先生想知道有多少种安排Agent的方案。由于答案可能很大，所以只需要你求出答案模 $10^9+7$ 的值就可以了。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅一行，为一个整数 N</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个整数，为方案数模 $10^9+7$ 的值</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input #1"></a>Sample Input #1</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output #1"></a>Sample Output #1</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input #2"></a>Sample Input #2</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output #2"></a>Sample Output #2</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">129</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于20%的数据 <em>N</em>≤10</p>
<p>对于40%的数据 <em>N</em>≤1000</p>
<p>对于60%的数据 <em>N</em>≤10^5</p>
<p>对于100%的数据 <em>N</em>≤10^9</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>超级后悔的一个题，考完试才发现我的式子离正确的式子一步之遥……然而因此 TLE 了 40 分……</p>
<p>这个题设特工能力为 1 到 n，<strong>考虑 A 队中能力值最大的特工为 $x$ ，那么 B 队最多只能选择 $n-x$ 个特工，也就是所有能力值大于 $x$ 的特工</strong></p>
<p>数据较小时，列出 A 所有可能的选择方案，若能力为 $x$ 的特工有 $cnt$ 次在方案中充当能力最大的特工，那么方案数就应该加上 $cnt \times C<em>{n-x}^0+C</em>{n-x}^1+……+C_{n-x}^{n-x}$ ，也就是 $cnt \times (2^{n-x}-1)$</p>
<p>通过总结规律发现，在所有可能的选择方案中，上述的 $cnt$ 与 $x$ 有着 $cnt(x)=2^{x-1}$ 的关系，可列出式子：</p>
<p>$Ans=\sum_{i=1}^{n-1}(2^i-1)\times 2^{n-i-1}$ ，只循环到 $n-1$ 是因为至少留一个特工给 B 队</p>
<p><strong>然而这样直接暴力算显然是要超时的（N 达到了 $10^9$ 规模），把原式展开：</strong></p>
<p>$Ans=\sum<em>{i=1}^{n-1}(2^i-1)\times 2^{n-i-1} = \sum</em>{i=1}^{n-1}(2^{n-1}-2^{n-i-1})=(n-1)\times 2^{n-1}-\sum_{i=1}^{n-1}2^{n-i-1}$</p>
<p>后面那一坨等比求和：$\sum_{i=1}^{n-1}2^{n-i-1} = 2^{n-2}\times \frac{1-(\frac{1}{2})^{n-1}}{\frac{1}{2}} = 2^{n-1}-1$</p>
<p>所以原式：$Ans=(n-1)\times 2^{n-1}-(2^{n-1}-1)=(n-2)\times 2^{n-1}+1$</p>
<p>到这一步就可以直接快速幂计算了</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 30000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fastpow</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	ll res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=(res*a)%mod;</span><br><span class="line">		a=(a*a)%mod;b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> res;</span><br><span class="line">&#125; ll n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;agent.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;agent.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">	ll tmp=<span class="built_in">fastpow</span>(<span class="number">2</span>,n<span class="number">-1</span>);</span><br><span class="line">	ll ans=(n<span class="number">-2</span>)*tmp%mod;</span><br><span class="line">	(ans+=<span class="number">1</span>)%=mod;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-小奇回地球（earth-cpp）"><a href="#2-小奇回地球（earth-cpp）" class="headerlink" title="2. 小奇回地球（earth.cpp）"></a>2. 小奇回地球（earth.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>开学了，小奇在回地球的路上，遇到了一个棘手的问题。</p>
<p>简单来说，它要从标号为1的星球到标号为n的星球，某一些星球之间有航线。由于超时空隧道的存在，从一个星球到另一个星球时间可能会倒流，而且，从星球a到b耗费的时间和星球b到a耗费的时间不一定相同。</p>
<p>宇宙法规定：“禁止在出发时间前到达目的地。”</p>
<p>每艘飞船上都有速度调节装置，可以调节飞行的时间。其功能可以使得整次航程中所有两星球间的飞行时间增加或减少相同的整数值。你的任务是帮助它调整速度调节器，使得从 1 到 n 的最短时间满足宇宙法规定</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>输入文件包含多组数据，第1个数为T，表示数据组数。</p>
<p>对于每组数据，输入第1行为两个正整数n，m，为星球的个数和星球间的路线数。接下来m行，每行三个整数i，j和t，表示由星球i到星球j飞行的时间为t。由i到j最多只会有一条飞行线路。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出文件共T行，每组数据输出一行。</p>
<p>如果可以通过调节速度调节器完成任务，则输出一个非负整数，表示由星球1到星球n的最短时间。（注意最短时间要大于或者等于0）。</p>
<p>如果不能由星球1到达星球n，则输出-1。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 3 -3</span><br><span class="line">3 1 1</span><br><span class="line">3 4 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>【数据范围】</p>
<p>1，2号测试点，保证所有星球出度不超过1</p>
<p>3，4号测试点，n&lt;=10</p>
<p>5，6号测试点，-100&lt;=t&lt;=100</p>
<p>对于100%的数据T&lt;=10，n&lt;=100，m&lt;=n*(n-1)，-100000&lt;=t&lt;=100000</p>
<p>数据随机和构造结合生成</p>
<p>【样例解释】</p>
<p>把速度控制器的值设为1,相当于每个时间值加1,得到的最短路径为1→2→3→4,所需时间为2+(-2)+2=2。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>根据题意，是求一个偏移量 $d$，使得原来的所有路径长度加上这个 $d$ 之后存在从 1 到 n 的非负最短路径</p>
<p>不考虑负环的影响，那么这个题明显 <strong>二分+SPFA</strong> 解决</p>
<p>若要考虑负环的问题，则要注意：<strong>并非任意的负环都会对最短路径造成影响，只要图中存在一条不经过负环而能从 1 到达 n 的路径，小奇就可以通过这条路径回到地球，而不是去走负环</strong></p>
<p>举一个例子：（$n=4$）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--5--&gt;4;1--1--&gt;2;</span><br><span class="line">2--&quot;-100&quot;--&gt;3;3--&quot;-100&quot;--&gt;2</span><br></pre></td></tr></table></figure>
<p>图中 2 和 3 形成了负环，然而这并不意味着需要增加偏移量来消除负环，因为小奇可以走 $1\to 5$ 这一条路径回到地球，因此将偏移量设置成 -5，得到的答案是 0，而不是 105</p>
<p>注意到这一点之后，我开始的想法是：<strong>在去掉图中负环（通过偏移量实现）后找到一条 $1\to n$ 的最短路径，并将路径上的点记录，判断负环时，看记录的点是不是在负环上，如果没有在负环上的记录点，就不用增加偏移量</strong></p>
<p>这个想法看似正确，但是它的致命缺陷在于 <strong>SPFA 求出的最短路径随着各个路径的长度变化是会变化的</strong>，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--1--&gt;3;1--1--&gt;2;</span><br><span class="line">2--&quot;-3&quot;--&gt;3;3--1--&gt;1;3--1--&gt;4</span><br></pre></td></tr></table></figure>
<p>这是样例数据构造出的图，现在它的最短路径为 $1\to 2 \to 3\to 4$，路径长度为 -1，若把路径长度统一偏移 3，则得到新的构造图为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1--4--&gt;3;1--4--&gt;2;</span><br><span class="line">2--0--&gt;3;3--4--&gt;1;3--4--&gt;4</span><br></pre></td></tr></table></figure>
<p>现在的最短路径不再是 $1\to 2 \to 3\to 4$，而是 $1\to 3\to 4$，而答案采用的路径是前一种</p>
<p>这就意味着：<strong>如果只是为了去掉负环而将原图中的路径长度改变的话，最短路径是会变化的，记录的最短路径有可能与答案采用的路径不同，这时就很难得出正确答案，上述算法也就只能拿到 40 分了</strong><del>（比纯二分的 50 分还低）</del></p>
<p>正确的做法是：<strong>记录原图中与 1 号结点和 n 号都连通的点，无论最短路径如何变化，一定会经过这些点中的某些点，因此，判断负环的时候同时判断负环上的点是不是与 1 号结点和 n 号都连通的点，如果是才增加偏移</strong></p>
<p>第一个例子说明即使原图存在负环也是可以有最短路径的，但是由于 SPFA 会将所有的边加入队列进行松弛操作，这将可能导致 SPFA 卡死，只需要<strong>让 SPFA 在加边时判断下一个点是不是所谓的连通点即可，因为在之前的负环判断中已经确认所有连通点都不在负环上，所以 SPFA 可以正常运行</strong></p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxPRIME 664588</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll mod;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p[maxPRIME];<span class="type">bool</span> isp[maxn];</span><br><span class="line"><span class="type">int</span> n,m;ll JC[<span class="number">3</span>][maxn];</span><br><span class="line"><span class="function">ll <span class="title">Quickpow</span><span class="params">(ll b,ll p,ll K)</span></span>&#123;</span><br><span class="line">	ll sol=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">1</span>) sol=(sol*b)%K;</span><br><span class="line">		b=(b*b)%K;</span><br><span class="line">		p/=<span class="number">2</span>;</span><br><span class="line">	&#125; <span class="keyword">return</span> sol;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PRIME</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N=<span class="built_in">max</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!isp[i]) p[++p[<span class="number">0</span>]]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;i*p[j]&lt;=maxn;j++)&#123;</span><br><span class="line">			isp[i*p[j]]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%p[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; JC[<span class="number">0</span>][<span class="number">1</span>]=JC[<span class="number">1</span>][<span class="number">1</span>]=JC[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">		JC[<span class="number">0</span>][i]=JC[<span class="number">0</span>][i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		<span class="keyword">if</span>(!isp[i])&#123;</span><br><span class="line">			JC[<span class="number">1</span>][i]=JC[<span class="number">1</span>][i<span class="number">-1</span>]*(i<span class="number">-1</span>)%mod;</span><br><span class="line">			JC[<span class="number">2</span>][i]=JC[<span class="number">2</span>][i<span class="number">-1</span>]*i%mod; </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			JC[<span class="number">1</span>][i]=JC[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">			JC[<span class="number">2</span>][i]=JC[<span class="number">2</span>][i<span class="number">-1</span>];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;puzzled.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;puzzled.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> T;<span class="built_in">fcin</span>(T);<span class="built_in">fcin</span>(mod);</span><br><span class="line">	<span class="built_in">PRIME</span>();<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(JC[<span class="number">0</span>][x]*JC[<span class="number">1</span>][y])%mod*<span class="built_in">Quickpow</span>(JC[<span class="number">2</span>][y],mod<span class="number">-2</span>,mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-极光（aurora-cpp）"><a href="#3-极光（aurora-cpp）" class="headerlink" title="3. 极光（aurora.cpp）"></a>3. 极光（aurora.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>天空中出现了许多的北极光，这些北极光组成了一个长度为n的正整数数列a[i],远古之魔书上记载到：2个位置的graze值为两者位置差与数值差的和：</p>
<p><code>graze(x,y)=|x-y|+|a[x]-a[y]|</code>。</p>
<p>要想破解天罚，就必须支持2种操作（k都是正整数）：</p>
<p>Modify x k：将第x个数的值修改为k。</p>
<p>Query x k：询问有几个i满足graze(x,i)&lt;=k。</p>
<p>由于从前的天罚被圣王lmc破解了，所以rhl改进了她的法术，询问不仅要考虑当前数列，还要考虑任意历史版本，即统计任意位置上<strong>出现过</strong>的任意数值与当前的a[x]的graze值&lt;=k的对数。（<strong>某位置多次修改为同样的数值，按多次统计</strong>）</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第1行两个整数n,q。分别表示数列长度和操作数。</p>
<p>第2行n个正整数，代表初始数列。</p>
<p>第3~q+2行每行一个操作。</p>
<p>N&lt;=40000, 修改操作数&lt;=60000, 询问操作数&lt;=10000, Max{a[i]}(含修改)&lt;=80000</p>
<p>输出若干行，每行一个数，表示每次清点存款时领袖有多少个账房可供他选择</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>对于每次询问操作，输出一个非负整数表示答案</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 4 3</span><br><span class="line">Query 2 2</span><br><span class="line">Modify 1 3</span><br><span class="line">Query 2 2</span><br><span class="line">Modify 1 2</span><br><span class="line">Query 1 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>写在了题目中</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>做法：<strong>转换坐标后，CDQ分治的模板</strong></p>
<p>把序列中的每个元素 $a[x]$ 看做 $(x,\;a[x])$ 的坐标，发现 <code>graze</code> 函数就是求两个坐标之间的<a href="https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin">曼哈顿距离</a><strong>，但是要统计曼哈顿距离在某个范围内的点对数量很复杂，考虑转化成另一种距离：<a href="https://baike.baidu.com/item/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB/8955729?fr=aladdin">切比雪夫距离</a></strong></p>
<p>切比雪夫距离定义为平面两点之间的横纵坐标差值的较大值，也就是 $max(x_1-x_2,\;y_1-y_2)$ ，<strong>在平面中，点的坐标 $(x,\;y)$ 可以通过转换 $(x,\;y)\to (x-y,\;x+y)$ 来让原来的曼哈顿距离变为新坐标系下的切比雪夫距离</strong></p>
<p>这样做了之后，统计切比雪夫距离在某个范围 $k$ 内的思路就很简单了，设参照点为 $(x,\;y)$，那么满足要求的点就位于坐标 $(x-k,\;y-k)$ 到坐标 $(x+k,\;y+k)$ 围成的矩形之中，到这一步就是一个三维偏序的问题，上 CDQ分治的模板解决</p>
<p><strong>至于题目中的可持久化，其实就是在修改时将修改后的点再次插入一遍</strong></p>
<p>本题还要注意的一点就是负数坐标的偏移，由于坐标转换时连续做减法有可能变为很小的负数，因此偏移量要设置大一点</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pro 3 violence </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 60005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> offset=<span class="number">300000</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> px,py,type,val;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> typ,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">		type=typ;px=x;py=y;val=v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(px!=x.px) <span class="keyword">return</span> px&lt;x.px;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> type&lt;x.type;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;op[maxn*<span class="number">5</span>],tmp[maxn*<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n,m,opn,a[maxn],ans[maxn];</span><br><span class="line"><span class="type">int</span> T[offset*<span class="number">2</span>+<span class="number">5</span>],maxy;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	p+=offset;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=<span class="number">500000</span>;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		T[i]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	p+=offset;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=<span class="number">500000</span>;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		<span class="keyword">if</span>(T[i]) T[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;p+=offset;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		 ans+=T[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddNode</span><span class="params">(<span class="type">int</span> posx,<span class="type">int</span> posy)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> newx=posx+posy;</span><br><span class="line">	<span class="type">int</span> newy=posx-posy;</span><br><span class="line">	maxy=<span class="built_in">max</span>(maxy,newy);</span><br><span class="line">	op[++opn].<span class="built_in">get</span>(<span class="number">1</span>,newx,newy,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">AddQuery</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ox pos</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> oy a[pos]</span></span><br><span class="line">	<span class="type">int</span> A=ox+oy-k;</span><br><span class="line">	<span class="type">int</span> B=ox-oy-k; <span class="comment">// 左上角 </span></span><br><span class="line">	<span class="type">int</span> C=ox+oy+k;</span><br><span class="line">	<span class="type">int</span> D=ox-oy+k; <span class="comment">// 右下角  </span></span><br><span class="line">	ans[<span class="number">0</span>]++;</span><br><span class="line">	op[++opn].<span class="built_in">get</span>(<span class="number">2</span>,A<span class="number">-1</span>,D,ans[<span class="number">0</span>]);</span><br><span class="line">	op[++opn].<span class="built_in">get</span>(<span class="number">2</span>,C,B<span class="number">-1</span>,ans[<span class="number">0</span>]);</span><br><span class="line">	op[++opn].<span class="built_in">get</span>(<span class="number">3</span>,C,D,ans[<span class="number">0</span>]);</span><br><span class="line">	op[++opn].<span class="built_in">get</span>(<span class="number">3</span>,A<span class="number">-1</span>,B<span class="number">-1</span>,ans[<span class="number">0</span>]);</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> ox</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> oy</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">cdq</span>(L,mid);<span class="built_in">cdq</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">	<span class="type">int</span> u=L,v=mid+<span class="number">1</span>,p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(u&lt;=mid &amp;&amp; v&lt;=R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[u]&lt;op[v])&#123;</span><br><span class="line">			<span class="keyword">if</span>(op[u].type==<span class="number">1</span>) <span class="built_in">updata</span>(op[u].py,<span class="number">1</span>);</span><br><span class="line">			tmp[p++]=op[u++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(op[v].type==<span class="number">2</span>) ans[op[v].val]-=<span class="built_in">res</span>(op[v].py);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op[v].type==<span class="number">3</span>) ans[op[v].val]+=<span class="built_in">res</span>(op[v].py);</span><br><span class="line">			tmp[p++]=op[v++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(u&lt;=mid)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[u].type==<span class="number">1</span>) <span class="built_in">updata</span>(op[u].py,<span class="number">1</span>);</span><br><span class="line">		tmp[p++]=op[u++];</span><br><span class="line">	&#125;<span class="keyword">while</span>(v&lt;=R)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[v].type==<span class="number">2</span>) ans[op[v].val]-=<span class="built_in">res</span>(op[v].py);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op[v].type==<span class="number">3</span>) ans[op[v].val]+=<span class="built_in">res</span>(op[v].py);</span><br><span class="line">		tmp[p++]=op[v++]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;</span><br><span class="line">		<span class="built_in">clear</span>(tmp[i].py);</span><br><span class="line">		op[i+L]=tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="type">char</span> in[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;aurora.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;aurora.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);maxy=<span class="number">-2139062143</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(a[i]);<span class="built_in">AddNode</span>(i,a[i]); </span><br><span class="line">	&#125; <span class="type">int</span> x,k;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in);</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(k);</span><br><span class="line">		<span class="keyword">if</span>(in[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">			a[x]=k;</span><br><span class="line">			<span class="built_in">AddNode</span>(x,a[x]);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">AddQuery</span>(x,k);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cdq</span>(<span class="number">1</span>,opn);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ans[<span class="number">0</span>];i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>分治</tag>
        <tag>图论</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | 线段树 | 二分 | 模拟  \ | 20190824考试解题报告</title>
    <url>/2019/08/24/2019-08-24-0824%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. agent</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">512 MB</td>
</tr>
<tr>
<td style="text-align:center">2. earth</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">512 MB</td>
</tr>
<tr>
<td style="text-align:center">3. aurora</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">512 MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-彩虹（rainbow-cpp）"><a href="#1-彩虹（rainbow-cpp）" class="headerlink" title="1. 彩虹（rainbow.cpp）"></a>1. 彩虹（rainbow.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>探险队员们跟随两位护法来到了七色虹前。七色虹，就是平面直角坐标系中赤橙黄绿青蓝紫七个半圆，第i座(1&lt;=i&lt;=7)半圆形彩虹的圆心是(xi,0)，半径是ri，半圆上所有点的纵坐标均为非负数。探险队员可以看做一条竖直的、长度等于身高的线段，线段的底端纵坐标为0，最高的一位探险队员的身高为h。</p>
<p>现在探险队员们要从(0,0)到达(x0,0)，穿越彩虹的过程中，探险队员的整个身体必须始终在至少一个半圆形彩虹的内部。由于彩虹的半径ri可能太小了，不足以满足这个条件，因此两位护法决定帮助他们把所有彩虹的半径都增大一个非负实数r。探险队员们想知道，r最小是多少呢？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个实数 h、x0,表示身高和目的地横坐标。 接下来七行每行两个实数 xi、ri,表示七座半圆形彩虹的圆心和半径。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最小的 r,四舍五入保留 2 位小数。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4.0 36.0</span><br><span class="line">0.0 4.0</span><br><span class="line">6.0 4.0</span><br><span class="line">12.0 4.0</span><br><span class="line">18.0 4.0</span><br><span class="line">24.0 4.0</span><br><span class="line">30.0 4.0</span><br><span class="line">36.0 4.0</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1.00</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于 100% 的数据,满足 0&lt;=xi,x0&lt;=10000,0&lt;h&lt;100。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>类似于 <strong>喷水池问题</strong> 的解法，即 <strong>二分 + 区间覆盖问题</strong></p>
<p>对于每个彩虹半圆，探险队能安全走过的空间就是半圆与 $y=h$ 这一条直线的两个交点之间的矩形部分，而这两个交点很好求出</p>
<p>对于一个圆心为 $(x_0，0)$，半径为 $r$ 的半圆，有 $h^2+dx^2=r^2$，那么 $dx=\sqrt{r^2-h^2}$ ，两点横坐标分别为 $x_0-dx$ 和 $x_0+dx$，对于和 $y=h$ 直线有交点的半圆，把这些交点保存为区间，然后判断这些区间能不能覆盖 $[0，x_0]$，然后实数域上二分猜答案即可</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)/2.0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt; pr;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf=<span class="number">2147483647.00</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,r;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;o)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x!=o.x) <span class="keyword">return</span> x&lt;o.x;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> r&lt;o.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;s[<span class="number">9</span>];<span class="type">double</span> h,x0;</span><br><span class="line"><span class="function">pr <span class="title">getseq</span><span class="params">(<span class="type">double</span> cx,<span class="type">double</span> cr,<span class="type">double</span> py)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> dx=<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(cr,<span class="number">2</span>)-<span class="built_in">pow</span>(py,<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_pair</span>(cx-dx,cx+dx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> d)</span></span>&#123;</span><br><span class="line">	pr dots[<span class="number">9</span>];<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i].r+d&gt;=h) dots[++cnt]=<span class="built_in">getseq</span>(s[i].x,s[i].r+d,h);</span><br><span class="line">	&#125; <span class="built_in">sort</span>(dots+<span class="number">1</span>,dots+cnt+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(dots[<span class="number">1</span>].first&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">double</span> cover=dots[<span class="number">1</span>].second;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cover&gt;=x0) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(dots[i].first&gt;cover) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		cover=<span class="built_in">max</span>(cover,dots[i].second);</span><br><span class="line">	&#125; <span class="keyword">return</span> cover&gt;=x0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;rainbow.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;rainbow.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;h,&amp;x0);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;s[i].x,&amp;s[i].r);</span><br><span class="line">	<span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">7</span>+<span class="number">1</span>);<span class="type">double</span> L=<span class="number">0.0</span>,R=<span class="number">100000.0</span>,ans;</span><br><span class="line">	<span class="built_in">check</span>(<span class="number">52.71</span>);</span><br><span class="line">	<span class="keyword">while</span>(R-L&gt;eps)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) R=mid,ans=mid;</span><br><span class="line">		<span class="keyword">else</span> L=mid;</span><br><span class="line">	&#125; <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-还教室（classroom-cpp）"><a href="#2-还教室（classroom-cpp）" class="headerlink" title="2. 还教室（classroom.cpp）"></a>2. 还教室（classroom.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>还记得 NOIP 2012 提高组 Day2 中的借教室吗？时光飞逝，光阴荏苒，两年过去了，曾经借教室的同学们纷纷归还自己当初租借的教室。请你来解决类似于借教室的另一个问题。</p>
<p>在接受借教室请求的 n 天中，第 i<em>i</em> 天剩余的教室为 ai 个。作为大学借教室服</p>
<p>务的负责人，你需要完成如下三种操作共 m<em>m</em> 次：</p>
<p>① 第 l 天到第 r 天，每天被归还 d 个教室。</p>
<p>② 询问第 l 天到第 r 天教室个数的平均数。</p>
<p>③ 询问第 l 天到第 r 天教室个数的方差。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行包括两个正整数 n 和 m ，其中 n 为借教室的天数，m 为操作次数。</p>
<p>接下来一行，共包含 n 个整数，第i 个整数表示第 i 天剩余教室数目为 ai 个。</p>
<p>接下来 m 行，每行的第一个整数为操作编号（只能为 1 或 2 或 3），接下来：</p>
<p>包含两个正整数 l 和 r，若操作编号为 1，则接下来再包含一个正整数 d。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>对于每个操作 2 和操作 3，输出一个既约分数（分子与分母互质）表示询问的答案（详见样例）。若答案为 0，请输出“0/1”（不含引号）</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2 3 4 5</span><br><span class="line">1 1 2 3</span><br><span class="line">2 2 4</span><br><span class="line">3 2 4</span><br><span class="line">3 1 5</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4/1</span><br><span class="line">2/3</span><br><span class="line">14/25</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>全部数据满足：$1\leq l,r \leq 10^5$，$n,m \leq 10^5$，$0\leq a_i \leq 10$，$1\leq d\leq 3$，操作 1 的数量不超过 10%</p>
<p>注意：$a_i$ 和 $d$ 的操作范围很小以及操作 1 的数量很少是为了保证答案的分子分母不会超过 Int64 的范围，与题目的做法本身并无关系</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看到区间更新和区间查询，很容易想到线段树，问题 1 就是区间更新板子，问题 2 直接区间求和后除以区间长度即可，关键在于维护问题 3 的答案信息</p>
<p><strong>显然我们不能直接维护方差，且不能通过实数的方式算出方差然后试图得出分数形式，因为这样会有精度损失</strong></p>
<p><strong>那么我们要维护的也就是方差的右边部分，也就是 $\sum_{i=1}^n(x_i-\overline{x})^2$ ，之后像平均数那样除以区间长度即可</strong></p>
<p>然而我们还是不能直接维护上述的一坨式子，把它展开得到：</p>
<p>$\sum<em>{i=1}^n(x_i-\overline{x})^2=\sum</em>{i=1}^n(x<em>i-2x_i\overline{x}+\overline{x}^2)=\sum</em>{i=1}^nx<em>i^2+n\times \overline{x}^2-2\times \sum</em>{i=1}^nx_i\overline{x}$ </p>
<p>$\sum<em>{i=1}^nx_i^2+n\times \overline{x}^2-2\overline{x}\times \sum</em>{i=1}^nx<em>i$，可以设 $S=\sum</em>{i=1}^nx<em>i^2$，$T=\sum</em>{i=1}^nx_i$，则 $\overline{x}=\frac{T}{n}$，化简式子：</p>
<p>$\sum<em>{i=1}^nx_i^2+n\times \overline{x}^2-2\overline{x}\times \sum</em>{i=1}^nx_i=S+n\times \frac{T^2}{n^2}-2\times \frac{T}{n}\times T=S+\frac{T^2}{n}-2\times\frac{T^2}{n}=S-\frac{T^2}{n}$</p>
<p>上述式子表明维护方差需要维护 <strong>区间平方和</strong> 和 <strong>区间和</strong>（区间长度 $n$ 可以直接得出）</p>
<p>区间和的线段树写过板子，那么区间平方和呢？其实转化之后也可以由区间和得出：</p>
<p>$\sum<em>{i=1}^n(x_i+v)^2=\sum</em>{i=1}^n(x^2+2x<em>iv+v^2)=\sum</em>{i=1}^nx<em>i^2+2v\sum</em>{i=1}^nx_i+nv^2$</p>
<p>上述式子表明新的区间平方和可以由 <strong>现在的区间平方和和现在的区间和</strong> 维护而来（此处注意应该是先更新区间平方和再更新区间和）,那么线段树就可以圆满解决这个题了</p>
<p>至于输出既约分数，就是分子分母同时除以它们的最大公约数</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> LC,RC;</span><br><span class="line">	ll V,PV,TAG;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> val(x) T[x].V</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> pval(x) T[x].PV</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> tag(x) T[x].TAG</span></span><br><span class="line">&#125;T[maxn&lt;&lt;<span class="number">2</span>];<span class="type">int</span> newp,Tr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="built_in">val</span>(k)=<span class="built_in">val</span>(<span class="built_in">lc</span>(k))+<span class="built_in">val</span>(<span class="built_in">rc</span>(k));</span><br><span class="line">	<span class="built_in">pval</span>(k)=<span class="built_in">pval</span>(<span class="built_in">lc</span>(k))+<span class="built_in">pval</span>(<span class="built_in">rc</span>(k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=++newp;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		<span class="built_in">val</span>(p)=Tr[L];</span><br><span class="line">		<span class="built_in">pval</span>(p)=<span class="built_in">val</span>(p)*<span class="built_in">val</span>(p);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">lc</span>(p)=<span class="built_in">build</span>(L,mid);<span class="built_in">rc</span>(p)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">spr</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="built_in">tag</span>(k)+=d;</span><br><span class="line">	<span class="built_in">pval</span>(k)=<span class="built_in">pval</span>(k)+(<span class="number">1ll</span>*<span class="number">2</span>*d*<span class="built_in">val</span>(k)+<span class="number">1ll</span>*(R-L+<span class="number">1</span>)*d*d);</span><br><span class="line">    <span class="comment">// 式子开头乘上 1ll，会自动将式子中的所有变量看做 long long 参与运算</span></span><br><span class="line">    <span class="comment">// 可以防止中途因为 int 爆掉</span></span><br><span class="line">	<span class="built_in">val</span>(k)+=(R-L+<span class="number">1</span>)*d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">tag</span>(k)==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">spr</span>(<span class="built_in">lc</span>(k),L,mid,<span class="built_in">tag</span>(k));</span><br><span class="line">	<span class="built_in">spr</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,<span class="built_in">tag</span>(k));</span><br><span class="line">	<span class="built_in">tag</span>(k)=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">spr</span>(k,L,R,d);</span><br><span class="line">	<span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=x) <span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,y,d);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;y) <span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y,d);</span><br><span class="line">	<span class="built_in">pushup</span>(k);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">val</span>(k); <span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=x) ans+=<span class="built_in">sum</span>(<span class="built_in">lc</span>(k),L,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;y) ans+=<span class="built_in">sum</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">psum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">pval</span>(k); <span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=x) ans+=<span class="built_in">psum</span>(<span class="built_in">lc</span>(k),L,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;y) ans+=<span class="built_in">psum</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;classroom.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;classroom.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(Tr[i]);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,n);<span class="type">int</span> op,x,y,z; </span><br><span class="line">	ll summ,divm,psumm,xsumm,ysumm;</span><br><span class="line">	ll newx,newy,tsumm;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(op);<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">fcin</span>(z),<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,z);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			summ=<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">			divm=<span class="built_in">gcd</span>(summ,(ll)(y-x+<span class="number">1</span>));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,summ/divm,(ll)(y-x+<span class="number">1</span>)/divm);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			summ=<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">			psumm=<span class="built_in">psum</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">			newx=(ll)(y-x+<span class="number">1</span>)*psumm-summ*summ; <span class="keyword">if</span>(newx&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// debug</span></span><br><span class="line">			newy=(ll)(y-x+<span class="number">1</span>)*(ll)(y-x+<span class="number">1</span>);</span><br><span class="line">			divm=<span class="built_in">gcd</span>(newx,newy);<span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>,newx/divm,newy/divm);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-篮球比赛（basketball-cpp）"><a href="#2-篮球比赛（basketball-cpp）" class="headerlink" title="2. 篮球比赛（basketball.cpp）"></a>2. 篮球比赛（basketball.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>由于Czhou举行了众多NOIP模拟赛，也导致放学后篮球比赛次数急剧增加。神牛们身体素质突飞猛进，并且球技不断精进。这引起了体育老师彩哥的注意，为了给校篮球队找到势均力敌的对手，彩哥找到了Czhou神，想要和机房篮球队进行多场友谊赛。Czhou为了顾全校篮球队面子，决定派出配合默契又不至于吊打校篮球队的阵容。</p>
<p>而机房神牛的能力值受到游戏时长，训练时长，个人基础值得影响，可能会不断变化。所以Czhou想根据神牛当天状态从中选出若干名选手，使他们的能力值和等于k。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>一行三个数n,k,l。表示机房有n个神牛，选出队员能力值和为k，每个神牛的能力最大值&lt;=L且&gt;=0。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>输出一个数，表示方案数，方案满足选出若干选手使能力和为k。因为答案比较大，最后模10^9+7。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2 2 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>样例说明：神牛的能力值可能为(0,2)(1,2)(1,1)(2,0)(2,1)(2,2)，这样都可以选出一些数字使他们的能力值和为2。</p>
<p>对于（0,2）表示第一只牛能力值为0，第二只牛能力为2</p>
<p>类似的：</p>
<p>对于（1,2）选出2即满足要求。</p>
<p>对于（1,1）选出全部选手即满足要求。</p>
<p>所以（0,2）（1，1）都是满足要求的方案。</p>
<p>数据范围：</p>
<p>n,k&lt;=20</p>
<p>0&lt;=L&lt;=10^9.</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：爆搜 + 背包（20分）</strong></p>
</blockquote>
<p>没什么好说的……暴力枚举每个神牛的能力值然后检验是否能刚好达到 K，因为数据规模的原因只能过 2 个点</p>
<blockquote>
<p><strong>做法二：状压 DP（100分）</strong></p>
</blockquote>
<p>从提示的数据范围来看，$n$，$k$ 都是非常小的整数，所以可以用状压 DP 表示 $[0，k]$ 中每一个能力值能不能取得到，所以 $f[i][j]$ ($i\in[1，n]$，$j\in[1，2^{min(l,k)}-1]$) 表示考虑完前 $i$ 个神牛，且满足状态 $j$ 表示的能力值的方案数</p>
<p><strong>也就是说其中若能力值 $x$ 取到，$j$ 化成二进制的第 $x$ 位为 1，题目的 $l$ 可能很大，但我们只需讨论 $k$ 以内的情况</strong></p>
<p>这个状压 DP 的方程也不难想到，新增一位神牛时，除了当前状态中能取到的能力值不变，还会增加一些新的能取到的能力值</p>
<p>故由 $f[i][j]$ 转移到 $f[i+1][j’]$ 时，若新神牛的能力值为 $x$，对应的 $j’=j \;\lvert\; (j&lt;&lt;x) \;\lvert\; 1&lt;&lt;(x-1)$，转移方程为：</p>
<p>$f[i+1][j’]=(f[i+1][j’]+f[i][j])\mod (1e9+7)$ ，其中 $x\in[0，min(l,k)]$ </p>
<p>而如果新神牛的能力值 $x\geq k$，那么原来的方案数显然不会改变，但是这仍然是一种取神牛的方式，所以：</p>
<p>$f[i+1][j]=(f[i][j]\times (l-k) \mod (1e9+7)) \mod (1e9+7)$ ($When\; l\geq k$)</p>
<p>统计时，判断当前状态 $i$ 下能力值 $k$ 能否被取到，用 $i\; \&amp; \; 1&lt;&lt;(k-1)$</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 25 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxs 1&lt;&lt;21</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll mod=(ll)<span class="number">1e9</span>+<span class="number">7</span>; </span><br><span class="line">ll f[maxn][maxs];<span class="type">int</span> n,m,k,l;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;basketball.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;basketball.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(k);<span class="built_in">fcin</span>(l);m=(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(l,k);i++) f[<span class="number">1</span>][<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> nxts;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=k) f[<span class="number">1</span>][<span class="number">0</span>]=(l-k+<span class="number">1</span>); <span class="comment">// 特判 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!f[i][<span class="number">0</span>]) f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">if</span>(f[i][j])&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;=<span class="built_in">min</span>(l,k);h++)&#123;</span><br><span class="line">					nxts=(j|(j&lt;&lt;h)|(<span class="number">1</span>&lt;&lt;(h<span class="number">-1</span>)))&amp;m;</span><br><span class="line">					(f[i+<span class="number">1</span>][nxts]+=f[i][j])%=mod;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(l&gt;=k) (f[i+<span class="number">1</span>][j]+=(f[i][j]*(ll)(l-k)%mod))%=mod; </span><br><span class="line">			&#125;</span><br><span class="line">	&#125; ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))) (ans+=f[n][i])%=mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>二分</tag>
        <tag>线段树</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>分治 | 二分 | 整体二分： 学习笔  记</title>
    <url>/2019/08/21/2019-08-21-%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h2><p>在信息学竞赛中，有一部分题可以使用二分的办法来解决。但是当这种题目有多次询问且每次询问我们对每个查询都直接二分，可能会收获一个 TLE。这时候我们就会用到整体二分。<strong>整体二分的主体思路就是把多个查询一起解决，所以这是一个离线算法</strong>（摘自 OI Wiki）</p>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>可以使用整体二分法解决的问题具有如下性质：</p>
<ol>
<li><p><strong>询问的答案具有可二分性</strong></p>
</li>
<li><p><strong>修改对判定答案的贡献互相独立</strong> ，修改之间互不影响效果</p>
</li>
<li><p>修改如果对判定答案有贡献，<strong>则贡献为一确定的与判定标准无关的值</strong></p>
</li>
<li><p><strong>贡献满足交换律，结合律，具有可加性</strong></p>
</li>
<li><p>题目允许使用离线算法（显然）</p>
</li>
</ol>
<h3 id="思路或模板"><a href="#思路或模板" class="headerlink" title="思路或模板"></a>思路或模板</h3><p>一般的二分是对连续某次操作下（操作数为 $mid$ 的操作）进行判定，根据判定结果修改答案值域，值域不断缩小，逼近正确答案的过程，<strong>可以看出一般的二分仅对一个询问起作用</strong></p>
<p>而整体二分可以处理一坨询问，自然需要一个存储询问结果的数组，由于一次猜的答案需要拿去同时与多个询问进行判定，整体二分的大致思路如下：</p>
<ol>
<li>确定处理询问的区间：$[x,\;y]$（即处理第 $x$ 个到第 $y$ 个询问），确定答案值域：$[L,\;R]$ （二分的灵魂）</li>
<li>首先，若进行到 $L=R$ 的这一步，说明答案已经确定，将当前区间内询问的答案全部赋值为 $L$ ，当然这只是暂时的，一个询问的答案可能被赋值多次，然后直接 <code>return</code></li>
<li>用猜的答案 $mid$ 同时与区间内的询问作比较，设置两个数组 $newL$ 和 $newR$，对于那些答案过大的询问，放入 $newL$ 中，答案过小的询问，放入 $newR$ 中</li>
<li>同时更新答案值域和询问区间，按照先后顺序将 $newL$ 到 $newR$ 中的询问覆盖掉原来区间内的询问</li>
<li>递归处理，若 $newL$ 中有 $xL$ 个询问，则递归处理的询问区间分别为：$[x,\; x+xL-1]$ 和 $[x+xL,\; y]$，答案值域为 $[L,\;mid]$ 和 $[mid+1,\;R]$</li>
</ol>
<p>可以发现，整体二分和 CDQ 分治相似，第 4 步类似 CDQ 分治中的合并操作，<strong>这里可以理解成划分，将有二分价值的询问划分到一起，保证下一步二分时，对应区间内询问的答案一定在对应的答案值域内，如果没有这一步，那么很多询问的答案都无法精确</strong></p>
<p>思路中第 3 步的比较或检验是决定时间复杂度的关键，通常这一步都会采用一些数据结构优化时间复杂度</p>
<p>下面根据这个思路看几道例题</p>
<h3 id="洛谷P3834-【模板】可持久化线段树-1（主席树）"><a href="#洛谷P3834-【模板】可持久化线段树-1（主席树）" class="headerlink" title="洛谷P3834 【模板】可持久化线段树 1（主席树）"></a>洛谷P3834 【模板】可持久化线段树 1（主席树）</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>给定N个整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>第一行包含两个正整数N、M，分别表示序列的长度和查询的个数。</p>
<p>第二行包含N个整数，表示这个序列各项的数字。</p>
<p>接下来M行每行包含三个整数l,r,k , 表示查询区间[l,r]内的第k小值。</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出包含k行，每行1个整数，依次表示每一次查询的结果</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">25957 6405 15770 26287 26465 </span><br><span class="line">2 2 1</span><br><span class="line">3 4 1</span><br><span class="line">4 5 1</span><br><span class="line">1 2 2</span><br><span class="line">4 4 1</span><br></pre></td></tr></table></figure>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">6405</span><br><span class="line">15770</span><br><span class="line">26287</span><br><span class="line">25957</span><br><span class="line">26287</span><br></pre></td></tr></table></figure>
<h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h4><p>20%的数据，$1\leq N,M \leq 10$</p>
<p>50%的数据，$1\leq N,M \leq 10^3$</p>
<p>80%的数据，$1\leq N,M \leq 10^5$</p>
<p>100%的数据，$1\leq N,M \leq 2\times 10^5$</p>
<p>数列中的数 $a_i$ 满足 $-10^9\leq a_i \leq 10^9$</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这个题以前曾是<del>令人闻风丧胆的</del>主席树的板子题，由于题目支持离线操作，现在我们也可以用整体二分解决，把所有询问存到数组里面，对所有询问，二分第 $k$ 小的数并检验，从而离线得出全部询问的答案并输出</p>
<p>具体的说，<strong>对于区间 $[x,\;y]$ 内的询问，二分一个 $mid$，然后对于每个询问，查询得到在区间内有 $C$ 个数 $mid$ 小， 个，通过比较 $C$ 和 $k$ 的大小划分这 $y-x+1$ 个询问到 $newL$ 和 $newR$ 中，然后覆盖掉原来的区间，递归处理询问，直到 $L=R$ 的时候，就直接把区间 $[x,\;y]$ 内的询问答案全部赋值为 $L$</strong></p>
<p>划分时注意，若要将操作 $p$ 划分至 $newR$ 中，那么要将其对应的 $k$ 减去 $C$（$C$ 为当前区间比 $mid$ 小的数的个数）</p>
<p>统计在区间内有多少个数比 $mid$ 小，这可以用树状数组实现（就像统计逆序对数那样），要注意树状数组要及时清空，以免对下一个区间的判定产生影响</p>
<h4 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=(<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos,val;</span><br><span class="line">	<span class="type">int</span> id,l,r,k; <span class="type">int</span> type;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_asVal</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;pos=p;val=v;type=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_asAsk</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;id=i;l=a;r=b;k=c;type=<span class="number">2</span>;&#125;</span><br><span class="line">&#125;q[maxn&lt;&lt;<span class="number">1</span>],q1[maxn&lt;&lt;<span class="number">1</span>],q2[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,m,ans[maxn],T[maxn],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		T[i]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		ret+=T[i];</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)</span><br><span class="line">			<span class="keyword">if</span>(q[i].type==<span class="number">2</span>) ans[q[i].id]=L;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="type">int</span> qcnt1=<span class="number">0</span>,qcnt2=<span class="number">0</span>,t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].type==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i].val&lt;=mid) <span class="built_in">updata</span>(q[i].pos,<span class="number">1</span>),q1[++qcnt1]=q[i];</span><br><span class="line">			<span class="keyword">else</span> q2[++qcnt2]=q[i];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			t=<span class="built_in">res</span>(q[i].r)-<span class="built_in">res</span>(q[i].l<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span>(q[i].k&lt;=t) q1[++qcnt1]=q[i];</span><br><span class="line">			<span class="keyword">else</span> q[i].k-=t,q2[++qcnt2]=q[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="built_in">sizeof</span>(T));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=qcnt1;i++) q[x+i<span class="number">-1</span>]=q1[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=qcnt2;i++) q[x+i<span class="number">-1</span>+qcnt1]=q2[i];</span><br><span class="line">	<span class="built_in">solve</span>(L,mid,x,x+qcnt1<span class="number">-1</span>);<span class="built_in">solve</span>(mid+<span class="number">1</span>,R,x+qcnt1,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="type">int</span> A,B,C,mL=inf,mR=-inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(A),q[++cnt].<span class="built_in">get_asVal</span>(i,A);</span><br><span class="line">		mL=<span class="built_in">min</span>(mL,A);mR=<span class="built_in">max</span>(mR,A);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(A);<span class="built_in">fcin</span>(B);<span class="built_in">fcin</span>(C);</span><br><span class="line">		q[++cnt].<span class="built_in">get_asAsk</span>(++ans[<span class="number">0</span>],A,B,C);</span><br><span class="line">	&#125; <span class="built_in">solve</span>(mL,mR,<span class="number">1</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ans[<span class="number">0</span>];i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷P2617-Dynamic-Rankings"><a href="#洛谷P2617-Dynamic-Rankings" class="headerlink" title="洛谷P2617 Dynamic Rankings"></a>洛谷P2617 Dynamic Rankings</h3><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)</p>
<p>并且，你可以改变一些a[i]的值，改变后，程序还能针对改变后的a继续回答上面的问题。</p>
<p>你需要编一个这样的程序，从输入文件中读入序列a，然后读入一系列的指令，包括询问指令和修改指令。</p>
<h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><p>第一行有两个正整数n(1≤n≤100000)，m(1≤m≤100000)。分别表示序列的长度和指令的个数。</p>
<p>第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。接下来的m行描述每条指令，每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t</p>
<ul>
<li>Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1）表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。</li>
<li>C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t。</li>
</ul>
<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><p>对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">3 2 1 4 7</span><br><span class="line">Q 1 4 3</span><br><span class="line">C 2 6</span><br><span class="line">Q 2 5 3</span><br></pre></td></tr></table></figure>
<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h4 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h4><p>10%的数据中，m,n≤100;</p>
<p>20%的数据中，m,n≤1000;</p>
<p>50%的数据中，m,n≤10000。</p>
<p>对于所有数据，m,n≤100000</p>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>本题是涉及修改操作的区间 K 小值，而像 CDQ 分治那样，<strong>我们同样可以将修改操作和询问操作合并到一个数组里面（上面的代码已经体现了这一点）</strong></p>
<p>合并之后动态处理，如果是修改操作，就更新树状数组，同时将这个操作放在 $newL$ 中，<strong>这是因为修改操作能影响其后面的查询操作，因此需要优先处理</strong>，如果是查询操作，按照上一个题的处理方法即可</p>
<p>需要注意的是，修改操作有正向的（添加值）也有负向的（擦除值），体现在题目中就是一个元素的修改可以看做先擦除这个元素，再添加修改后的元素，一共 2 个修改操作，因此，为了不影响下一次区间的检验，<strong>处理完毕后需要对树状数组处理，即把当前区间 $[x,\;y]$ 内的修改操作全部反向执行（其实就是系数乘上 -1）</strong></p>
<h4 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=(<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> pos,val,alpha;</span><br><span class="line">	<span class="type">int</span> id,l,r,k; <span class="type">int</span> type;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_asVal</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v,<span class="type">int</span> al)</span></span>&#123;pos=p;val=v;alpha=al;type=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_asAsk</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;id=i;l=a;r=b;k=c;type=<span class="number">2</span>;&#125;</span><br><span class="line">&#125;q[maxn&lt;&lt;<span class="number">2</span>],q1[maxn&lt;&lt;<span class="number">2</span>],q2[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,ans[maxn],T[maxn],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		T[i]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		ret+=T[i];</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span>; </span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)</span><br><span class="line">			<span class="keyword">if</span>(q[i].type==<span class="number">2</span>) ans[q[i].id]=L;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="type">int</span> qcnt1=<span class="number">0</span>,qcnt2=<span class="number">0</span>,t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[i].type==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i].val&lt;=mid) </span><br><span class="line">				<span class="built_in">updata</span>(q[i].pos,q[i].alpha),q1[++qcnt1]=q[i];</span><br><span class="line">			<span class="keyword">else</span> q2[++qcnt2]=q[i];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			t=<span class="built_in">res</span>(q[i].r)-<span class="built_in">res</span>(q[i].l<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span>(q[i].k&lt;=t) q1[++qcnt1]=q[i];</span><br><span class="line">			<span class="keyword">else</span> q[i].k-=t,q2[++qcnt2]=q[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=qcnt1;i++)</span><br><span class="line">		<span class="keyword">if</span>(q1[i].type==<span class="number">1</span>) <span class="built_in">updata</span>(q1[i].pos,-q1[i].alpha);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=qcnt1;i++) q[x+i<span class="number">-1</span>]=q1[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=qcnt2;i++) q[x+i<span class="number">-1</span>+qcnt1]=q2[i];</span><br><span class="line">	<span class="built_in">solve</span>(L,mid,x,x+qcnt1<span class="number">-1</span>);<span class="built_in">solve</span>(mid+<span class="number">1</span>,R,x+qcnt1,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="type">int</span> A,B,C,mL=inf,mR=-inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(A),q[++cnt].<span class="built_in">get_asVal</span>(i,A,<span class="number">1</span>);</span><br><span class="line">		s[i]=A;</span><br><span class="line">		mL=<span class="built_in">min</span>(mL,A);mR=<span class="built_in">max</span>(mR,A);</span><br><span class="line">	&#125; <span class="type">char</span> op;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(A);<span class="built_in">fcin</span>(B);<span class="built_in">fcin</span>(C);</span><br><span class="line">			q[++cnt].<span class="built_in">get_asAsk</span>(++ans[<span class="number">0</span>],A,B,C);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(A);<span class="built_in">fcin</span>(B);</span><br><span class="line">			mL=<span class="built_in">min</span>(mL,B);mR=<span class="built_in">max</span>(mR,B);</span><br><span class="line">			q[++cnt].<span class="built_in">get_asVal</span>(A,s[A],<span class="number">-1</span>);s[A]=B;</span><br><span class="line">			q[++cnt].<span class="built_in">get_asVal</span>(A,s[A],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="built_in">solve</span>(mL,mR,<span class="number">1</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ans[<span class="number">0</span>];i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洛谷SP10264-METEORS-流星"><a href="#洛谷SP10264-METEORS-流星" class="headerlink" title="洛谷SP10264 METEORS - 流星"></a>洛谷SP10264 METEORS - 流星</h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>Byteotian Interstellar Union有N个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为M份（第M份和第1份相邻），第i份上有第Ai个国家的太空站。<br>这个星球经常会下陨石雨。BIU已经预测了接下来K场陨石雨的情况。<br>BIU的第i个成员国希望能够收集Pi单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。</p>
<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><p>第一行是两个数N,M。 第二行有M个数，第i个数Oi表示第i段轨道上有第Oi个国家的太空站。<br>第三行有N个数，第i个数Pi表示第i个国家希望收集的陨石数量。 第四行有一个数K，表示BIU预测了接下来的K场陨石雨。<br>接下来K行，每行有三个数Li,Ri,Ai，表示第K场陨石雨的发生地点在从Li顺时针到Ri的区间中（如果Li&lt;=Ri，就是Li,Li+1,…,Ri，否则就是Ri,Ri+1,…,m-1,m,1,…,Li），向区间中的每个太空站提供Ai单位的陨石样本。</p>
<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><p>N行。第i行的数Wi表示第i个国家在第Wi波陨石雨之后能够收集到足够的陨石样本。如果到第K波结束后仍然收集不到，输出NIE。</p>
<h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 3 2 1 3</span><br><span class="line">10 5 7</span><br><span class="line">3</span><br><span class="line">4 2 4</span><br><span class="line">1 3 1</span><br><span class="line">3 5 2</span><br></pre></td></tr></table></figure>
<h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">NIE</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h4 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h4><p>25%的数据中，$n,m,k \leq 1000$;</p>
<p>100%的数据中，$n,m,k \leq 3\times 10^5，1\leq O_i \leq n，1\leq P_i ,A_i \leq 10^9$;</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>整体二分，当然就是二分第 $mid$ 场流星雨之后能不能满足每个国家采集样本的需求，根据能否满足将当前 $[x,\;y]$ 区间中的国家划分至 $newL$ 和 $newR$</p>
<p>统计第 $mid$ 场流星雨之后，$m$ 个空间站的情况，<strong>同样可采用树状数组，根据树状数组前缀和的性质进行区间更新</strong></p>
<p>具体的说，给 $[L,\; R]$($L \leq R$) 的空间站增加 $k$ 个陨石样本，就是先 $updata(L,k)$ ，这样 $L$ 及其以后的空间站就会多出 $k$ 来，但是 $R$ 以后的空间站没有增加陨石，需要减去，也就是 $updata(R+1,-k)$，这里的 $k$ 并不一定为正，比如当前进行到 $x(x&gt;mid)$ 场流星雨，我们需要将时间回退到第 $mid$ 场流星雨，此处的 $k$ 就应为负值</p>
<p>对于 $L&gt;R$ 的情况，视作 $[1,\;R]$ 和 $[R,\;L]$ 的同时更新即可，剩下的部分就和上述的整体二分代码非常类似了</p>
<p>为了判断题目中 <code>NIE</code> 的情况，<strong>我们可以人为增加第 $k+1$ 场流星雨，使其给所有空间站带来极大数量的样本（简而言之就是一定可以满足所有空间站的需求），</strong>原本不能在 $k$ 场流星雨结束之后收集完的国家就会在 $k+1$ 结束之后收集完，根据这个判断是否 <code>NIE</code> 即可</p>
<h4 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ve(X) vector<span class="string">&lt;X&gt;</span>::iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,t;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;l=a,r=b,t=c;&#125;</span><br><span class="line">&#125;q[maxn]; ll T[maxn];<span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> tar[maxn];vector&lt;<span class="type">int</span>&gt; a[maxn];</span><br><span class="line"><span class="type">int</span> id[maxn],ans[maxn],cur,s[maxn];</span><br><span class="line"><span class="type">bool</span> filled[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=m;i+=<span class="built_in">lowbit</span>(i))	</span><br><span class="line">		T[i]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">res</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		ret+=T[i];</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> alpha)</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> delta q[pos].t</span></span><br><span class="line">	<span class="keyword">if</span>(q[pos].l&lt;=q[pos].r)</span><br><span class="line">		<span class="built_in">updata</span>(q[pos].l,delta*alpha),<span class="built_in">updata</span>(q[pos].r+<span class="number">1</span>,delta*alpha*<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">updata</span>(<span class="number">1</span>,delta*alpha),<span class="built_in">updata</span>(q[pos].r+<span class="number">1</span>,delta*alpha*<span class="number">-1</span>),</span><br><span class="line">		<span class="built_in">updata</span>(q[pos].l,delta*alpha);</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> delta</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++) ans[id[i]]=L;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span>(cur&lt;=mid) <span class="built_in">change</span>(++cur,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(cur&gt;mid) <span class="built_in">change</span>(cur--,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>; ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)&#123;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">ve</span>(<span class="type">int</span>) iter=a[id[i]].<span class="built_in">begin</span>();iter!=a[id[i]].<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">			sum+=<span class="built_in">res</span>(*iter); <span class="keyword">if</span>(sum&gt;=tar[id[i]]) <span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=tar[id[i]]) filled[id[i]]=<span class="literal">true</span>,cnt++;</span><br><span class="line">		<span class="keyword">else</span> filled[id[i]]=<span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="type">int</span> p1=x,p2=x+cnt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++)</span><br><span class="line">		<span class="keyword">if</span>(filled[id[i]]) s[p1++]=id[i];</span><br><span class="line">		<span class="keyword">else</span> s[p2++]=id[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=y;i++) id[i]=s[i];</span><br><span class="line">	<span class="built_in">solve</span>(L,mid,x,p1<span class="number">-1</span>);<span class="built_in">solve</span>(mid+<span class="number">1</span>,R,p1,p2<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testin.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;testout.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">fcin</span>(x),a[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(tar[i]); <span class="built_in">fcin</span>(k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);<span class="built_in">fcin</span>(z);</span><br><span class="line">		q[i].<span class="built_in">get</span>(x,y,z);</span><br><span class="line">	&#125; q[++k].<span class="built_in">get</span>(<span class="number">1</span>,n,(<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) id[i]=i;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,k,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans[i]==k) <span class="built_in">printf</span>(<span class="string">&quot;NIE\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>VB.NET | 在线获取歌词方法的小小  总结</title>
    <url>/2019/09/13/2019-09-13-OLGetLRC/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次的项目 <code>LRCEditor</code> 告一段落之后，最近又想到对其进行优化，其实也就是添加一个常用的功能：<strong>在线搜索歌词</strong></p>
<p>在 <code>LRCEditor</code> 中的 “帮助” 选项里面有提到如何在网易云音乐的在线界面利用开发者模式获取歌词文件和翻译，但是此方法操作起来会有一定难度，不利于将来准备做的 MusicPlayer 的功能集成，<strong>因此想到通过程序自己访问网络获取歌词并显示</strong></p>
<p>在我们平常浏览的播放器网页里面，通常都可以看到歌词，歌曲名称，作者信息和封面信息等等，然而要让程序从网页中像人一样提取出这些信息无疑是非常难的，如何让这些信息以程序能够理解或者解析的格式直接呈现呢，这就要依<strong>网页API来实现了</strong></p>
<h2 id="实现（获取歌词）"><a href="#实现（获取歌词）" class="headerlink" title="实现（获取歌词）"></a>实现（获取歌词）</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>使用网易云提供的 API，根据给定的歌曲名称（设为 Faded）搜索相应信息：<code>http://music.163.com/api/search/get?s=Faded&amp;limit=20&amp;type=1&amp;offset=0</code> ，必需参数说明：</p>
<ul>
<li><code>http://music.163.com/api/search/get</code> API接口网址</li>
<li><code>s</code>：歌曲名称，中文要进行字符编码</li>
<li><code>limit</code>：返回结果的数量</li>
<li><code>type</code>：搜索类型，1为单曲，10为专辑，100为歌手，1000歌单，1002用户</li>
<li><code>offset</code>：偏移量，用于结果分页返回</li>
</ul>
<p>在浏览器地址栏输入这个网址后，可以看到返回了一坨信息，大多都是如下格式的 JSON 代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">36990266</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Faded&quot;</span><span class="punctuation">,</span><span class="attr">&quot;artists&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1045123</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Alan Walker&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1078390</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Iselin Solheim&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;album&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">3406843</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Faded&quot;</span><span class="punctuation">,</span><span class="attr">&quot;artist&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p2.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;publishTime&quot;</span><span class="punctuation">:</span><span class="number">1448380800007</span><span class="punctuation">,</span><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span><span class="attr">&quot;copyrightId&quot;</span><span class="punctuation">:</span><span class="number">7001</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">18277181788626198</span><span class="punctuation">,</span><span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="number">212626</span><span class="punctuation">,</span><span class="attr">&quot;copyrightId&quot;</span><span class="punctuation">:</span><span class="number">7001</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;rtype&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;ftype&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;mvid&quot;</span><span class="punctuation">:</span><span class="number">524116</span><span class="punctuation">,</span><span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span><span class="number">8</span><span class="punctuation">,</span><span class="attr">&quot;rUrl&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span><span class="number">8192</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，第一个 <code>&quot;id&quot;</code> 就是该歌曲在网易云音乐的编号，过后的信息如英文所示，<code>&quot;name&quot;</code> 表示歌曲名，<code>&quot;artists&quot;</code> 中列出了参与创作的艺术家名称（因为可能不止一个，所以是以数组的形式返回的），<code>&quot;duration&quot;</code> 表示歌曲持续的时间（单位为毫秒），这一步的作用只是通过API搜索出歌曲ID，下一步将再次通过API得到ID对应歌曲的歌词信息</p>
<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>使用此网址得到歌曲的歌词信息：<code>http://music.163.com/api/song/lyric?os=pc&amp;id=36990266&amp;lv=-1&amp;kv=-1&amp;tv=-1</code></p>
<p>地址中除了 <code>id=</code> 后面接上上一步得到的 ID 外，其他部分不用管，然后可以看到以下 JSON 信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;sgc&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="attr">&quot;sfy&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="attr">&quot;qfy&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="attr">&quot;transUser&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">36990266</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">,</span><span class="attr">&quot;demand&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;userid&quot;</span><span class="punctuation">:</span><span class="number">1569973972</span><span class="punctuation">,</span><span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span><span class="string">&quot;……ye&quot;</span><span class="punctuation">,</span><span class="attr">&quot;uptime&quot;</span><span class="punctuation">:</span><span class="number">1548668567698</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;lyricUser&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">36990266</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">,</span><span class="attr">&quot;demand&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;userid&quot;</span><span class="punctuation">:</span><span class="number">1569973972</span><span class="punctuation">,</span><span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span><span class="string">&quot;……ye&quot;</span><span class="punctuation">,</span><span class="attr">&quot;uptime&quot;</span><span class="punctuation">:</span><span class="number">1547805089718</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;lrc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">16</span><span class="punctuation">,</span><span class="attr">&quot;lyric&quot;</span><span class="punctuation">:</span><span class="string">&quot;……&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;klyric&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;lyric&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;tlyric&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span><span class="number">10</span><span class="punctuation">,</span><span class="attr">&quot;lyric&quot;</span><span class="punctuation">:</span><span class="string">&quot;……&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>详细的歌词部分用 “……” 代替了，返回信息中 <code>lrc</code> 是原版歌词，若歌曲非中文且网易云有翻译版，则 <code>tlyric</code> 为最新一的翻译版歌词，<code>nickname</code> 和 <code>userid</code> 是翻译贡献者的用户名和用户ID</p>
<p>到这一步，我们就已经取得了关于歌词的较为完整的信息，但是目前为止，上述步骤都是都是在浏览器中完成的，要让程序做到够像在浏览器地址栏中输入网址然后获取返回信息的话，需要额外的代码</p>
<p>并且，返回字符串也并不是原原本本的歌词，而是以 JSON 格式编码的返回信息，为了处理 JSON 格式的返回信息，需要用到 <code>Newtonsoft.JSON</code></p>
<h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>以下代码用于从给定网址读取信息，以 <code>String</code> 格式返回，原理不多做解释了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Imports System.Security.Cryptography.X509Certificates</span><br><span class="line">Imports System.Net</span><br><span class="line">Public Function GetInfo(ByVal url As String) As String</span><br><span class="line">        Dim ret As String = <span class="string">&quot;&quot;</span></span><br><span class="line">        Dim HttpUrl As New Uri(url)</span><br><span class="line">        Dim HttpReq As HttpWebRequest = WebRequest.Create(HttpUrl)</span><br><span class="line">        Dim HttpRep As HttpWebResponse = HttpReq.GetResponse()</span><br><span class="line">        Dim resStream As IO.Stream = HttpRep.GetResponseStream()</span><br><span class="line">        Dim sr As New IO.StreamReader(resStream, System.Text.Encoding.UTF8)</span><br><span class="line">        ret = sr.ReadToEnd()</span><br><span class="line">        sr.Close()</span><br><span class="line">        Return ret</span><br><span class="line">    End Function</span><br></pre></td></tr></table></figure>
<p>调用例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dim ResPUrl As String = <span class="string">&quot;http://music.163.com/api/search/get?&amp;limit=20&amp;type=1&amp;offset=0&amp;s=&quot;</span> + Given <span class="string">&#x27;Given 给定歌曲的名称</span></span><br><span class="line"><span class="string">Dim WebRet = GetInfo(ResPUrl)</span></span><br></pre></td></tr></table></figure>
<p>此时，<code>WebRet</code> 存储的就是 Step1 里面看到的一大坨东西了，接下来使用 <code>Newtonsoft.JSON</code> 框架里的函数解析这个字符串，获得我们想要的歌曲信息</p>
<h3 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h3><p>先从 NuGet 导入 <code>Newtonsoft</code> 的包，然后 <code>Imports Newtonsoft.JSON</code></p>
<p>这一步使用 <code>JsonConvert.DeserializeObject</code> 对字符串进行反序列化并存储对应标签的键值</p>
<p>先看一下函数声明：<code>JsonConvert.DeserializeObject(Of T As Type)(Value As String) As Object</code>，是一个很奇怪的函数，可以把它和 C++ 里面的 <code>Template&lt;Typename T&gt;</code> 类比，即前面一个括号里面写的 <code>(Of T As Type)</code> 限定此函数返回的类型，后面一个括号里面是我们要进行反序列化操作的 JSON 字符串</p>
<p><code>JsonConvert.DeserializeObject</code> 函数本身返回的是 <code>Object</code> 类型，这是 <code>VB.NET</code> 里面的最基本类型，可以派生出任意的类型，拥有他们的结构，但是 <code>Object</code> 本身不具有任何特定的成员变量或者函数，需要将特定的结构体传入到 <code>Object</code> 才能让它像其他类或者结构体一样使用</p>
<p><code>JsonConvert.DeserializeObject</code> 函数返回的是一个特定的类或者结构体，其组成和要操作的 JSON 字符串一致，即拥有相同的结构和变量名，例如以下 JSON 字符串：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Competitors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HQX&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0ms&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WYX&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1000ms&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>从此字符串返回的特定结构体或类应具有如下组成形式，才能让函数正确返回：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Public Structure JRES</span><br><span class="line">	Public Structure JRES_PERSON</span><br><span class="line">		Public name,time As String</span><br><span class="line">		Public score As Integer</span><br><span class="line">	End Structure</span><br><span class="line">	Public Competitors As List(Of JRES_PERSON)</span><br><span class="line">	<span class="string">&#x27;若 JSON 返回的值不带引号，需要用Integer或Long类型接收</span></span><br><span class="line"><span class="string">End Structure</span></span><br></pre></td></tr></table></figure>
<p>需要说明的是，特定结构体不一定要有全部 JSON 里面的变量名称，但是不能多出 JSON 里没有的变量名称，例如删去成员 <code>name</code> ，函数仍然正确返回，但是若加上成员 <code>age</code> 就会出现错误（不管是什么类型），对于 JSON 返回值中带方括号声明的数组类型，需要用同名且拥有一致的结构的集合类型进行接收，如 List 或 数组</p>
<p>现在，分析一下 Step1 中JSON返回值的结构：</p>
<p><img src="https://s2.ax1x.com/2019/09/14/nyx5En.png" alt="pic"></p>
<p>整个结构非常的繁琐而且层次很深，因此我们只提取想要的几个信息，可以用如下的特定结构体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Public Structure JRES</span><br><span class="line">        Public code As Integer</span><br><span class="line">        Public Structure JRES_SONGS</span><br><span class="line">            Public songCount As Integer</span><br><span class="line">            Public Structure JRES_SINGLESONG</span><br><span class="line">                Public <span class="built_in">id</span>, duration As Integer</span><br><span class="line">                Public name As String</span><br><span class="line">                Public Structure JRES_SINGLESONG_ARTISTS</span><br><span class="line">                    Public name As String</span><br><span class="line">                End Structure</span><br><span class="line">                Public artists As List(Of JRES_SINGLESONG_ARTISTS)</span><br><span class="line">            End Structure</span><br><span class="line">            Public songs As List(Of JRES_SINGLESONG)</span><br><span class="line">        End Structure</span><br><span class="line">        Public result As JRES_SONGS</span><br><span class="line">    End Structure</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Public Res As JRES</span><br><span class="line">Res = JsonConvert.DeserializeObject(Of JRES)(TarGetResp)</span><br><span class="line"><span class="string">&#x27;TarGetResp 是上一步取得的网页返回值</span></span><br></pre></td></tr></table></figure>
<p>现在，结构体 <code>Res</code> 里面存储的就是我们希望得到的歌词信息了，如果用户还限制了艺术家名称，我们可以将不符合的项从 List 当中去掉，然后选取一个控件呈现得到的信息吧！</p>
<h2 id="实现（获取专辑封面）"><a href="#实现（获取专辑封面）" class="headerlink" title="实现（获取专辑封面）"></a>实现（获取专辑封面）</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>同样是网易云的 API 网址：<code>http://music.163.com/api/song/detail/?id=&#123;歌曲id&#125;&amp;ids=[&#123;歌曲id&#125;]</code></p>
<p>获取到如下返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;songs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Umbrella (Matte Remix)&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">518904426</span><span class="punctuation">,</span><span class="attr">&quot;position&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;fee&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;copyrightId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;disc&quot;</span><span class="punctuation">:</span><span class="string">&quot;01&quot;</span><span class="punctuation">,</span><span class="attr">&quot;no&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;artists&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Matte&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">12335355</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Id&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;briefDesc&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;musicSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topicPerson&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Ember Island&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1100001</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Id&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;briefDesc&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;musicSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topicPerson&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;album&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Umbrella (Matte Remix)&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">36812124</span><span class="punctuation">,</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;EP/Single&quot;</span><span class="punctuation">,</span><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">109951163063843501</span><span class="punctuation">,</span><span class="attr">&quot;blurPicUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/1LrtvH8EpKb5iHKR9qEU0Q==/109951163063843501.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;companyId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="number">109951163063843501</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/1LrtvH8EpKb5iHKR9qEU0Q==/109951163063843501.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;publishTime&quot;</span><span class="punctuation">:</span><span class="number">1510502400007</span><span class="punctuation">,</span><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;company&quot;</span><span class="punctuation">:</span><span class="string">&quot;Self-Release&quot;</span><span class="punctuation">,</span><span class="attr">&quot;briefDesc&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;artist&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Id&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;briefDesc&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;musicSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topicPerson&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;songs&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;copyrightId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;commentThreadId&quot;</span><span class="punctuation">:</span><span class="string">&quot;R_AL_3_36812124&quot;</span><span class="punctuation">,</span><span class="attr">&quot;artists&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Matte&quot;</span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">12335355</span><span class="punctuation">,</span><span class="attr">&quot;picId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Id&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;briefDesc&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;picUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;img1v1Url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://p1.music.126.net/6y-UleORITEDbvrOLV0Q8A==/5639395138885805.jpg&quot;</span><span class="punctuation">,</span><span class="attr">&quot;albumSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;trans&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;musicSize&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;topicPerson&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;subType&quot;</span><span class="punctuation">:</span><span class="string">&quot;混音版&quot;</span><span class="punctuation">,</span><span class="attr">&quot;transName&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;picId_str&quot;</span><span class="punctuation">:</span><span class="string">&quot;109951163063843501&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;starred&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span><span class="attr">&quot;popularity&quot;</span><span class="punctuation">:</span><span class="number">100.0</span><span class="punctuation">,</span><span class="attr">&quot;score&quot;</span><span class="punctuation">:</span><span class="number">100</span><span class="punctuation">,</span><span class="attr">&quot;starredNum&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="number">285701</span><span class="punctuation">,</span><span class="attr">&quot;playedNum&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;dayPlays&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;hearTime&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;ringtone&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;crbt&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;audition&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;copyFrom&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;commentThreadId&quot;</span><span class="punctuation">:</span><span class="string">&quot;R_SO_4_518904426&quot;</span><span class="punctuation">,</span><span class="attr">&quot;rtUrl&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;ftype&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;rtUrls&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;copyright&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;transName&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;sign&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;mark&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;hMusic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1387911675</span><span class="punctuation">,</span><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">11430182</span><span class="punctuation">,</span><span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span><span class="string">&quot;mp3&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span><span class="number">44100</span><span class="punctuation">,</span><span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span><span class="number">320000</span><span class="punctuation">,</span><span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span><span class="number">285701</span><span class="punctuation">,</span><span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span><span class="number">-19400.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;mMusic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1387911676</span><span class="punctuation">,</span><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">6858127</span><span class="punctuation">,</span><span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span><span class="string">&quot;mp3&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span><span class="number">44100</span><span class="punctuation">,</span><span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span><span class="number">192000</span><span class="punctuation">,</span><span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span><span class="number">285701</span><span class="punctuation">,</span><span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span><span class="number">-16600.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;lMusic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1387911677</span><span class="punctuation">,</span><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">4572099</span><span class="punctuation">,</span><span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span><span class="string">&quot;mp3&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span><span class="number">44100</span><span class="punctuation">,</span><span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span><span class="number">128000</span><span class="punctuation">,</span><span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span><span class="number">285701</span><span class="punctuation">,</span><span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span><span class="number">-14700.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;bMusic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1387911677</span><span class="punctuation">,</span><span class="attr">&quot;size&quot;</span><span class="punctuation">:</span><span class="number">4572099</span><span class="punctuation">,</span><span class="attr">&quot;extension&quot;</span><span class="punctuation">:</span><span class="string">&quot;mp3&quot;</span><span class="punctuation">,</span><span class="attr">&quot;sr&quot;</span><span class="punctuation">:</span><span class="number">44100</span><span class="punctuation">,</span><span class="attr">&quot;dfsId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;bitrate&quot;</span><span class="punctuation">:</span><span class="number">128000</span><span class="punctuation">,</span><span class="attr">&quot;playTime&quot;</span><span class="punctuation">:</span><span class="number">285701</span><span class="punctuation">,</span><span class="attr">&quot;volumeDelta&quot;</span><span class="punctuation">:</span><span class="number">-14700.0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;mvid&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;rtype&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;rurl&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;mp3Url&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;equalizers&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这个 JSON 返回值的结构和上面提到的获取歌词时候的返回值结构相似，但是没有最外层的 <code>result</code> ，所以还是需要再写一个结构体接收，如果用上述获取歌词的结构体接收，其 <code>songs</code> 会为 <code>nothing</code></p>
<p>成功接收数据后，<code>songs(0).album.picurl</code> 就是专辑封面图片的网址</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>得到网址后，注意到这次的网址返回的不是纯字符串而是文件，所以不能再用像获取歌词的 <code>GetResponse</code> 的方法得到图片了，此时我们可以用 .NET 自带的 HTTP 下载器 <code>WebClint</code> 完成操作</p>
<p><code>WebClint</code> 的下载操作都是默认异步执行的，不会造成主窗体死锁的现象，但是 <code>WebClint</code> 不在控件箱里，不能可视化对其触发事件进行函数绑定，因此我们用 <code>AddHandler</code> 手动绑定几个函数，首先，请求下载的操作为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Dim <span class="built_in">wc</span> As WebClint</span><br><span class="line">wc.DownloadFileAsync(TargetUrl, TargetFileName)</span><br></pre></td></tr></table></figure>
<p>其中 <code>TargetFileName</code> 是下载文件保存到本地时的文件名，然后我们给两个触发事件绑定函数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AddHandler wc.DownloadProgressChanged, AddressOf ShowDownProcess</span><br><span class="line">AddHandler wc.DownloadFileCompleted, AddressOf DownloadComplete</span><br></pre></td></tr></table></figure>
<p>其中 <code>DownloadProcessChanged</code> 在下载进度改变时触发，<code>DownloadFileCompleted</code> 在文件下载完成后触发，在对应的函数 <code>ShowDownProcess</code> 里可以使用 <code>ProcessBar</code> 控件直观显示下载进度，下载完成后 <code>Process.Start</code> 启动文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Public Sub ShowDownProcess(ByVal sender As Object, ByVal e As System.Net.DownloadProgressChangedEventArgs)</span><br><span class="line">        pb1.Value = e.ProgressPercentage</span><br><span class="line">        Lpro.Text = <span class="string">&quot;已完成：&quot;</span> + CStr(e.ProgressPercentage) + <span class="string">&quot; / &quot;</span> + <span class="string">&quot;100&quot;</span></span><br><span class="line">    End Sub</span><br><span class="line">    Public Sub DownloadComplete(ByVal sender As Object, ByVal e As System.ComponentModel.AsyncCompletedEventArgs)</span><br><span class="line">        Process.Start(TargetFileName)</span><br><span class="line">        Me.Close()</span><br><span class="line">    End Sub</span><br></pre></td></tr></table></figure>
<p>这一步可以单独用一个窗体来解决，使得程序更直观</p>
<h2 id="实现（获取mp3文件）"><a href="#实现（获取mp3文件）" class="headerlink" title="实现（获取mp3文件）"></a>实现（获取mp3文件）</h2><h3 id="Step1-1"><a href="#Step1-1" class="headerlink" title="Step1"></a>Step1</h3><p>API网址为：<code>http://music.163.com/song/media/outer/url?id=&#123;歌曲id&#125;</code></p>
<p>打开这个网址会得到一个可以直接下载的 mp3 文件，然后直接使用上面提到的 <code>WebClint</code> 下载即可</p>
<h3 id="附：窗体代码（下载）"><a href="#附：窗体代码（下载）" class="headerlink" title="附：窗体代码（下载）"></a>附：窗体代码（下载）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Option Explicit On</span><br><span class="line">Imports System.Security.Cryptography.X509Certificates</span><br><span class="line">Imports Newtonsoft.Json</span><br><span class="line">Imports System.Net</span><br><span class="line">Imports System.Diagnostics</span><br><span class="line">Public Class Donw</span><br><span class="line">    Public <span class="built_in">wc</span> As WebClient</span><br><span class="line">    Public TargetUrl As Uri</span><br><span class="line">    Public TargetFileName As String</span><br><span class="line">    Public Sub callDialog(songname As String, songart As String, songid As Integer)</span><br><span class="line">        TargetUrl = New Uri(<span class="string">&quot;http://music.163.com/song/media/outer/url?id=&quot;</span> + CStr(songid) + <span class="string">&quot;.mp3&quot;</span>)</span><br><span class="line">        TargetFileName = songname + <span class="string">&quot; - &quot;</span> + songart + <span class="string">&quot;.mp3&quot;</span></span><br><span class="line">        Ltitle.Text = <span class="string">&quot;下载歌词：&quot;</span> + TargetFileName</span><br><span class="line">        pb1.Value = 0</span><br><span class="line">        <span class="built_in">wc</span> = New WebClient()</span><br><span class="line">        AddHandler wc.DownloadProgressChanged, AddressOf ShowDownProcess</span><br><span class="line">        AddHandler wc.DownloadFileCompleted, AddressOf DownloadComplete</span><br><span class="line">        Me.ShowDialog()</span><br><span class="line">    End Sub</span><br><span class="line">    Public Sub callDialog_PIC(songname As String, songart As String, picurl As String)</span><br><span class="line">        TargetUrl = New Uri(picurl)</span><br><span class="line">        TargetFileName = songname + <span class="string">&quot; - &quot;</span> + songart + <span class="string">&quot;.png&quot;</span></span><br><span class="line">        Ltitle.Text = <span class="string">&quot;下载专辑图片：&quot;</span> + TargetFileName</span><br><span class="line">        pb1.Value = 0</span><br><span class="line">        <span class="built_in">wc</span> = New WebClient()</span><br><span class="line">        AddHandler wc.DownloadProgressChanged, AddressOf ShowDownProcess</span><br><span class="line">        AddHandler wc.DownloadFileCompleted, AddressOf DownloadComplete</span><br><span class="line">        Me.ShowDialog()</span><br><span class="line">    End Sub</span><br><span class="line">    Public Sub ShowDownProcess(ByVal sender As Object, ByVal e As System.Net.DownloadProgressChangedEventArgs)</span><br><span class="line">        pb1.Value = e.ProgressPercentage</span><br><span class="line">        Lpro.Text = <span class="string">&quot;已完成：&quot;</span> + CStr(e.ProgressPercentage) + <span class="string">&quot; / &quot;</span> + <span class="string">&quot;100&quot;</span></span><br><span class="line">    End Sub</span><br><span class="line">    Public Sub DownloadComplete(ByVal sender As Object, ByVal e As System.ComponentModel.AsyncCompletedEventArgs)</span><br><span class="line">        Process.Start(TargetFileName)</span><br><span class="line">        Me.Close()</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Private Sub Donw_Load(sender As Object, e As EventArgs) Handles MyBase.Load</span><br><span class="line">        wc.DownloadFileAsync(TargetUrl, TargetFileName)</span><br><span class="line">    End Sub</span><br><span class="line"></span><br><span class="line">    Private Sub Donw_FormClosing(sender As Object, e As FormClosingEventArgs) Handles MyBase.FormClosing</span><br><span class="line">        If Not wc.IsBusy Then wc.CancelAsync()</span><br><span class="line">    End Sub</span><br><span class="line">End Class</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>VB.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>数论 | 同余 | 字符串 | 动态规划  \ | 树链剖分 | 201901024考试：解题报告</title>
    <url>/2019/10/24/2019-10-24-exam/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. math</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">2. path</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">3. city</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-数学题（xorarray-cpp）"><a href="#1-数学题（xorarray-cpp）" class="headerlink" title="1. 数学题（xorarray.cpp）"></a>1. 数学题（xorarray.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一道数学题，表达式为：(B+E+S+S+I+E)(G+O+E+S)(M+O+O)，该表达式共有7个变量，每个变量最多有500个可能的候选取值，问有多少种方式能使上面的表达式成为7的倍数？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数N</p>
<p>接下来N行，每行包含一个变量和其可能的一个值。输入数据保证同一个变量可能的取值各不相同，且都在-10^5 到 10^5之间</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数，表示方案数。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">B 2</span><br><span class="line">E 5</span><br><span class="line">S 7</span><br><span class="line">I 10</span><br><span class="line">O 16</span><br><span class="line">M 19</span><br><span class="line">B 3</span><br><span class="line">G 1</span><br><span class="line">I 9</span><br><span class="line">M 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The two possible assignments are</span><br><span class="line"></span><br><span class="line">(B,E,S,I,G,O,M) = (2, 5, 7, 9, 1, 16, 19) -&gt; 51,765</span><br><span class="line"></span><br><span class="line">                = (2, 5, 7, 9, 1, 16, 2) -&gt; 34,510</span><br></pre></td></tr></table></figure>
<p>数据范围</p>
<p>1&lt;=N&lt;=500</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>原表达式 $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$ 共 7 个变量，它的结果被 7 整除，利用同余可以等效理解为 $B,E,S,I,G,O,M$ 这 7 个变量 $\mod 7$ 的余数带进这个式子被 7 整除</p>
<p>由于$\mod 7$ 的结果只有 0-6 这 7 种情况，直接暴力枚举，时间复杂度 $O(7^7)$ 约为 83 万</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s[<span class="number">9</span>][maxn];</span><br><span class="line"><span class="type">int</span> v[<span class="number">9</span>];</span><br><span class="line">ll ans=<span class="number">0</span>;<span class="type">int</span> n,times;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll sum=<span class="number">1ll</span>*(v[<span class="number">1</span>]+<span class="number">2</span>*v[<span class="number">2</span>]+<span class="number">2</span>*v[<span class="number">4</span>]+v[<span class="number">3</span>]);</span><br><span class="line">	sum*=<span class="number">1ll</span>*(v[<span class="number">5</span>]+v[<span class="number">4</span>]+v[<span class="number">6</span>]+v[<span class="number">2</span>]);</span><br><span class="line">	sum*=<span class="number">1ll</span>*(<span class="number">2</span>*v[<span class="number">6</span>]+v[<span class="number">7</span>]);</span><br><span class="line">	<span class="keyword">return</span> (sum%<span class="number">7</span>==<span class="number">0</span>)?sum:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step&gt;<span class="number">7</span>)&#123;</span><br><span class="line">		ll ret=<span class="built_in">calc</span>();</span><br><span class="line">		<span class="keyword">if</span>(ret) ans++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s[step][<span class="number">0</span>];i++)&#123;</span><br><span class="line">			v[step]=s[step][i];</span><br><span class="line">			<span class="built_in">dfs</span>(step+<span class="number">1</span>);</span><br><span class="line">			v[step]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;math.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;math.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// (B+E+S+S+I+E)(G+O+E+S)(M+O+O)</span></span><br><span class="line">	<span class="comment">// (1+4+2+2+3+4)(5+6+4+2)(7+6+6)</span></span><br><span class="line">	<span class="built_in">fcin</span>(n);</span><br><span class="line">	<span class="type">char</span> ch;<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;ch;<span class="built_in">fcin</span>(x);</span><br><span class="line">		<span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:s[<span class="number">1</span>][++s[<span class="number">1</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:s[<span class="number">2</span>][++s[<span class="number">2</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:s[<span class="number">3</span>][++s[<span class="number">3</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:s[<span class="number">4</span>][++s[<span class="number">4</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:s[<span class="number">5</span>][++s[<span class="number">5</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:s[<span class="number">6</span>][++s[<span class="number">6</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:s[<span class="number">7</span>][++s[<span class="number">7</span>][<span class="number">0</span>]]=x; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="built_in">dfs</span>(<span class="number">1</span>);<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-回文路径（path-cpp）"><a href="#2-回文路径（path-cpp）" class="headerlink" title="2. 回文路径（path.cpp）"></a>2. 回文路径（path.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>在一个N*N的网格中，规定左上角为起点，每次只能向右或者向下走一格，以右下角为终点，计算有多少种方案，使得走过的线路是回文串？最终输出答案模1,000,000,007的结果。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行一个正整数 <em>N</em>。</p>
<p>第二行 <em>N</em> 个正整数 <em>Xi</em>，表示存在一条有向边 <em>i</em> 指向 <em>Xi</em>。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>请输出回文路径数量，取模1,000,000,007。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">ABCD</span><br><span class="line">BXZX</span><br><span class="line">CDXB</span><br><span class="line">WCBA</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>【样例解释】</p>
<p>1 “ ABCDCBA”</p>
<p>1 “ ABCWCBA”</p>
<p>6 “ ABXZXBA”</p>
<p>4 “ ABXDXBA”</p>
<p>【数据范围】</p>
<p>1≤N≤500</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>直接看原图可能不好分析，我们把原图按照对角线顺序转换成如下图：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">BB</span><br><span class="line">CXC</span><br><span class="line">WDZD</span><br><span class="line">CXX</span><br><span class="line">BB</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>题目给定的每次往右或者往下移动，在新图里面就是往下或者往右下方移动</p>
<p>这样转换的好处在于：从左上角出发，且在右下角结束的路径上的回文串，其中心字符一定在中间的 <code>WDZD</code> 上，而关于中心字符对称的两组字符串分别是从最上面的 <code>A</code> 和最下面的 <code>A</code>，分别往下和往上移动相同的步数得到的</p>
<p>因此可以设计递推方程： <strong>$f[i1][j1][i2][j2]$ 表示考虑到 $d[i1][i2]$ 位置的字符，其关于某个中心字符对称的字符位于 $d[i2][j2]$ 处的方案数</strong></p>
<p>转移：$f[i1][j1][i2][j2]\leftarrow \begin{cases} f[i1-1][j1][i2+1][j2]\\f[i1-1][j1-1][i2+1][j2]\\f[i1-1][j1][i2+1][j2-1]\\f[i1-1][j1-1][i2+1][j2-1] \end{cases}$</p>
<p>边界 $f[1][1][2n-1][1]=1$，转移条件为 $d[i1][j1]=d[i2][j2]$ </p>
<p>直接这样设计肯定会造成 MLE，我们可以利用回文串的关于中心字符对称的两个子串长度相等的性质，发现只要 $i1$ 确定，那么 $i2$ 也就确定了，且 $i1+i2=2n$，于是可以省去一维，又发现 $f[i1]$ 只和 $f[i1-1]$ 有关系，所以滚动优化，最后的空间为 $2\times 500\times 500$，可以过此题</p>
<p>P.S. 实际写代码时，我第一次采用的是分步加法再取模的方法统计的 $f$ 数组，结果有一个测试点直接爆 1.6s，然后改成一次性赋值，在加法表达式里面取模，时间骤缩至 0.4s……，估计是因为每次赋值都要对当前的数组下标寻址花费了时间，以后写代码时能一次性赋值还是尽量一次性赋值吧</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#pragma GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> ll mod=(ll)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line"><span class="type">char</span> src[maxn][maxn];</span><br><span class="line"><span class="type">char</span> str[<span class="number">2</span>*maxn<span class="number">-1</span>][maxn];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">2</span>*maxn<span class="number">-1</span>];</span><br><span class="line">ll f[<span class="number">2</span>][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">convert</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) str[i+j<span class="number">-1</span>][++cnt[i+j<span class="number">-1</span>]]=src[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// current: at rows i</span></span><br><span class="line">	<span class="comment">// another: at rows tot-i+1;</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ii (2*n-i)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> NI ((i+1)&amp;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> I (i&amp;1)</span></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f[I],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[I]));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i;k++)</span><br><span class="line">			<span class="keyword">if</span>(str[i][j]==str[ii][k])&#123;</span><br><span class="line">				f[I][j][k]=(f[NI][j][k]%mod+f[NI][j][k<span class="number">-1</span>]%mod+f[NI][j<span class="number">-1</span>][k]%mod+f[NI][j<span class="number">-1</span>][k<span class="number">-1</span>]%mod)%mod;</span><br><span class="line">				<span class="comment">//(f[I][j][k]+=f[NI][j][k])%=mod;</span></span><br><span class="line">				<span class="comment">//(f[I][j][k]+=f[NI][j-1][k])%=mod;</span></span><br><span class="line">				<span class="comment">//(f[I][j][k]+=f[NI][j][k-1])%=mod;</span></span><br><span class="line">				<span class="comment">//(f[I][j][k]+=f[NI][j-1][k-1])%=mod;</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) (ans+=f[n&amp;<span class="number">1</span>][i][i])%=mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> ii</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> NI</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> I</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;path.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;path.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;src[i][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">convert</span>();</span><br><span class="line">	<span class="built_in">dp</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-大都市（city-cpp）"><a href="#3-大都市（city-cpp）" class="headerlink" title="3. 大都市（city.cpp）"></a>3. 大都市（city.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>在经济全球化浪潮的影响下,习惯于漫步在清晨的乡间小路的邮递员Blue Mary也开始骑着摩托车传递邮件了。不过，她经常回忆起以前在乡间漫步的情景。昔日，乡下有依次编号为1..n的n个小村庄，某些村庄之间有一些双向的土路。从每个村庄都恰好有一条路径到达村庄1（即比特堡）。并且，对于每个村庄，它到比特堡的路径恰好只经过编号比它的编号小的村庄。另外，对于所有道路而言，它们都不在除村庄以外的其他地点相遇。在这个未开化的地方，从来没有过高架桥和地下铁道。随着时间的推移，越来越多的土路被改造成了公路。至今，Blue Mary还清晰地记得最后一条土路被改造为公路的情景。现在，这里已经没有土路了——所有的路都成为了公路，而昔日的村庄已经变成了一个大都市。 Blue Mary想起了在改造期间她送信的经历。她从比特堡出发，需要去某个村庄，并且在两次送信经历的间隔期间,有某些土路被改造成了公路.现在Blue Mary需要你的帮助：计算出每次送信她需要走过的土路数目。（对于公路，她可以骑摩托车；而对于土路，她就只好推车了。）</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行是一个数n(1 &lt; = n &lt; = 2 50000).</p>
<p>以下n-1行，每行两个整数a，b（1≤a&lt;b≤n)</p>
<p>以下一行包含一个整数m（1 &lt; = m &lt; = 2 50000），表示Blue Mary曾经在改造期间送过m次信。</p>
<p>以下n+m-1行，每行有两种格式的若干信息，表示按时间先后发生过的n+m-1次事件:</p>
<p>1、若这行为“A a b”（a&lt;b），表示a村和b村之间的乡村道路在该特定时刻转变为高速公路。2、若这行为“W a”，表示Blue Mary从比特堡到a村送信。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>有m行，每行包含一个整数，表示对应的某次送信时经过的土路数目。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">4 5</span><br><span class="line">4</span><br><span class="line">W 5</span><br><span class="line">A 1 4</span><br><span class="line">W 5</span><br><span class="line">A 4 5</span><br><span class="line">W 5</span><br><span class="line">W 2</span><br><span class="line">A 1 2</span><br><span class="line">A 1 3</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1---2;1---3;1---4;</span><br><span class="line">4---5;</span><br></pre></td></tr></table></figure>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>可以用树链剖分做，把父结点和子结点间边的权值给子结点，每次给出 <code>W</code> 操作就是询问根结点到当前结点的边权和，修路就是选定一对父子结点把他们之间的边改为0，也就是把子结点的权值改为0，因为题目数据太过强大，这样做好像会 TLE 一个点……</p>
<p>常数较小的是与 DFS 序结合的树状数组，我们发现每次询问的都是根结点到当前结点的权值和，每次将一个点的权值变为0，会导致以这个结点为根的子树上的结点的权值和全部减去1，因此用 DFS序处理后可以类似于线段树的区间修改 + 单点查询，维护查分数组即可</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><blockquote>
<p><strong>DFS序做法</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 250005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],w[maxn];</span><br><span class="line"><span class="type">int</span> l[maxn],r[maxn],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n,m,dt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		w[i]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		ans+=w[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fu)</span></span>&#123;</span><br><span class="line">	l[u]=++dt;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i]==fu) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(to[i],u);</span><br><span class="line">	&#125;r[u]=dt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;city.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;city.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">fcin</span>(n);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    	<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">    	<span class="built_in">Eadd</span>(x,y);<span class="built_in">Eadd</span>(y,x);</span><br><span class="line">	&#125;<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">updata</span>(l[i],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">updata</span>(r[i]+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	&#125; <span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">fcin</span>(m);m=m+n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27;W&#x27;</span>) <span class="built_in">fcin</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">sum</span>(l[x]));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(x),<span class="built_in">fcin</span>(y);</span><br><span class="line">			<span class="built_in">updata</span>(l[y],<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">updata</span>(r[y]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>树剖做法</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#pragma GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 250005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn*2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm];</span><br><span class="line"><span class="type">int</span> head[maxn],n,m,tot,id[maxn];</span><br><span class="line"><span class="type">int</span> dep[maxn],xson[maxn],fa[maxn],top[maxn];</span><br><span class="line"><span class="type">int</span> newp,siz[maxn];</span><br><span class="line"><span class="comment">// segment tree </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> LC,RC,VAL,TAG;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc(x) T[x].LC</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc(x) T[x].RC</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> val(x) T[x].VAL</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> tag(x) T[x].TAG</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line">&#125;T[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="built_in">val</span>(k)=<span class="built_in">val</span>(<span class="built_in">lc</span>(k))+<span class="built_in">val</span>(<span class="built_in">rc</span>(k));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">tag</span>(k)==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// [L,mid] [mid+1,R]</span></span><br><span class="line">	<span class="built_in">val</span>(<span class="built_in">lc</span>(k))=<span class="built_in">tag</span>(k)*(mid-L+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">val</span>(<span class="built_in">rc</span>(k))=<span class="built_in">tag</span>(k)*(R-mid);</span><br><span class="line">	<span class="built_in">tag</span>(<span class="built_in">lc</span>(k))=<span class="built_in">tag</span>(<span class="built_in">rc</span>(k))=<span class="built_in">tag</span>(k);</span><br><span class="line">	<span class="built_in">tag</span>(k)=<span class="number">-1</span>;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=++newp;<span class="built_in">tag</span>(p)=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;<span class="built_in">val</span>(p)=<span class="number">1</span>;<span class="keyword">return</span> p;&#125;</span><br><span class="line">	<span class="built_in">lc</span>(p)=<span class="built_in">build</span>(L,mid);</span><br><span class="line">	<span class="built_in">rc</span>(p)=<span class="built_in">build</span>(mid+<span class="number">1</span>,R);</span><br><span class="line">	<span class="built_in">pushup</span>(p);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y)&#123;</span><br><span class="line">		<span class="built_in">val</span>(k)=d*(R-L+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">tag</span>(k)=d;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=x) <span class="built_in">updata</span>(<span class="built_in">lc</span>(k),L,mid,x,y,d);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;y) <span class="built_in">updata</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y,d);</span><br><span class="line">	<span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> <span class="built_in">val</span>(k);</span><br><span class="line">	<span class="built_in">pushdown</span>(k,L,R);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mid&gt;=x) ans+=<span class="built_in">sum</span>(<span class="built_in">lc</span>(k),L,mid,x,y);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;y) ans+=<span class="built_in">sum</span>(<span class="built_in">rc</span>(k),mid+<span class="number">1</span>,R,x,y);</span><br><span class="line">	<span class="built_in">pushup</span>(k);<span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>;<span class="type">int</span> maxsize=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[to[i]]) <span class="keyword">continue</span>;</span><br><span class="line">		dep[to[i]]=dep[u]+<span class="number">1</span>;</span><br><span class="line">		fa[to[i]]=u;<span class="built_in">dfs</span>(to[i]);</span><br><span class="line">		siz[u]+=siz[to[i]];</span><br><span class="line">		<span class="keyword">if</span>(siz[to[i]]&gt;maxsize)&#123;</span><br><span class="line">			maxsize=siz[to[i]];</span><br><span class="line">			xson[u]=to[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> TOP)</span></span>&#123;</span><br><span class="line">	id[u]=++id[<span class="number">0</span>];</span><br><span class="line">	top[u]=TOP;</span><br><span class="line">	<span class="keyword">if</span>(siz[u]==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(xson[u],TOP);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=xson[u] &amp;&amp; to[i]!=fa[u])</span><br><span class="line">			<span class="built_in">dfs</span>(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathadd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],dt);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">updata</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x],dt); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		ans+=<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;<span class="keyword">if</span>(dep[x]&lt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ans+=<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[y],id[x]);<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;city.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;city.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,y);<span class="built_in">Eadd</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	dep[<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">dfs</span>(<span class="number">1</span>);<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">fcin</span>(m);m=(n+m)<span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> op;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="string">&#x27;W&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(x);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">pathsum</span>(<span class="number">1</span>,x)<span class="number">-1</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">			<span class="built_in">pathadd</span>(y,y,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | SPFA | 字符串 | 201901022考试  ：解题报告</title>
    <url>/2019/10/22/2019-10-22-exam/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. door</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">2. escape</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">3. graze</td>
<td style="text-align:center">3000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-门卫（door-cpp）"><a href="#1-门卫（door-cpp）" class="headerlink" title="1. 门卫（door.cpp）"></a>1. 门卫（door.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>红美玲是红魔馆的门卫。最近红魔馆安保系统使用了新型的数据编码技术base64，可以</p>
<p>将数据转化为大小写字母、数字和+、/、=组成的字符串，具体方法如下： </p>
<p>首先将输入字符三个三个分为一组：如果没有剩余（即字符串长度为3的倍数），则直接调用主过程（见下方描述）；如果剩1个，则加两个“\0”字符（ASCII码为0），使总长度变为3的倍数，调用主过程，并且将主过程转化后的字符串最后两个字符改为“==”；如果剩2个，则加一个“\0”字符，使总长度变为3的倍数，调用主过程，并且将主过程转化后的字符串最后一个字符改为“=”。 </p>
<p>主过程：输入一个长度为3k的字符串，输出一个长度为4k的字符串。（k为非负整数。）循环以下过程n次,每次转换三个字符成为四个字符，循环n次转换出的字符串连接起来，即为最终的字符串。 </p>
<p>每次将三个字符转化成ascii码，再转成二进制，得到24个二进制位。将24个二进制位分成4组，每组6个二进制位，再分别转化成十进制。此时得到四个十进制数，并且小于 64（因为每个十进制数是由6个二进制位表示的）。接下来参照下表，将这四个数转化成字符，输出即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">value</th>
<th style="text-align:center">char</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0-25</td>
<td style="text-align:center">A-Z</td>
</tr>
<tr>
<td style="text-align:center">26-51</td>
<td style="text-align:center">a-z</td>
</tr>
<tr>
<td style="text-align:center">52-61</td>
<td style="text-align:center">0-9</td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center">+</td>
</tr>
<tr>
<td style="text-align:center">63</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
</div>
<p>接下来是两个例子： </p>
<p>输入Man，长度为3的倍数，直接调用主过程 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文本</th>
<th style="text-align:center">M</th>
<th style="text-align:center">a</th>
<th style="text-align:center">n</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII</td>
<td style="text-align:center">77</td>
<td style="text-align:center">97</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">01001101</td>
<td style="text-align:center">01100001</td>
<td style="text-align:center">01101110</td>
</tr>
</tbody>
</table>
</div>
<p>输出为：TWFu</p>
<p>输入A：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文本</th>
<th style="text-align:center">A</th>
<th style="text-align:center">\0</th>
<th style="text-align:center">\0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ASCII</td>
<td style="text-align:center">65</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">二进制</td>
<td style="text-align:center">01000001</td>
<td style="text-align:center">00000000</td>
<td style="text-align:center">00000000</td>
</tr>
</tbody>
</table>
</div>
<p>输出为：QQAA =&gt; QQ==（最后两个字符被替换）</p>
<p>最终将转化后的字符串输出，每76个字符为一行，如果最后一行不满76个字符，也换一行。输出文件最后请输出一个空行。因为是逐字节比较，行末不能有多余空格，文末不能有多余空行（也就是说文件最后一行一定是空行，倒数第二行一定不是空行）。 </p>
<p>你需要为红魔馆设计这个新型的编码技术，红美玲正在急着处理传输进来的信息，却不</p>
<p>知道红魔馆内已经有了入侵者…… </p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入文件第一行是一个正整数n，表示原始字符串的长度。 </p>
<p>第二行是一个字符串，长度为n。字符串由大小写字母，数字，符号，空格构成。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p> 若干行，表示转化后的字符串。每76个字符为一行，如果最后一行不满76个字符，也换一行。因为是逐字节比较，行末不能有多余空格，文末不能有多余空行（也就是说文件最后一行一定是空行，倒数第二行一定不是空行）。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">BC</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">QkM=</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于30%的数据,n=3,字符串只由字母组成</p>
<p>对于50%的数据,n=12</p>
<p>对于70%的数据,n&lt;=57</p>
<p>对于100%的数据,3&lt;=n&lt;=1000</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道简单的字符串操作题，根据题意转化字符串，分行输出转化后的字符即可</p>
<p>这道题在考试时写的程序，在自己电脑上能 AC，但是交到老师的 Linux 下面去就不行了……</p>
<p>然而 NOIP 采用的就是标准的 Linux 环境，不知道该怎么办……</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> src[maxn];</span><br><span class="line"><span class="type">int</span> bin[maxn],res[maxn];</span><br><span class="line"><span class="type">char</span> ref[maxn];</span><br><span class="line"><span class="type">int</span> n,cnt,rest;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;Z&#x27;</span>;i++) ref[cnt++]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++) ref[cnt++]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="string">&#x27;0&#x27;</span>;i&lt;=<span class="string">&#x27;9&#x27;</span>;i++) ref[cnt++]=i;</span><br><span class="line">	ref[cnt++]=<span class="string">&#x27;+&#x27;</span>;ref[cnt++]=<span class="string">&#x27;/&#x27;</span>;ref[cnt]=<span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;door.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;door.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);<span class="type">char</span> ch;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ch=<span class="built_in">getchar</span>();</span><br><span class="line">		src[i]=ch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n%<span class="number">3</span>!=<span class="number">0</span>) src[++n]=<span class="string">&#x27;\0&#x27;</span>,rest++;</span><br><span class="line">	<span class="type">int</span> offset,curch,ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">3</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(bin,<span class="number">0</span>,<span class="built_in">sizeof</span>(bin));</span><br><span class="line">	 	curch=src[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">7</span>;j&gt;=<span class="number">0</span>;j--) bin[++bin[<span class="number">0</span>]]=(curch&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">		curch=src[i+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">7</span>;j&gt;=<span class="number">0</span>;j--) bin[++bin[<span class="number">0</span>]]=(curch&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">		curch=src[i+<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">7</span>;j&gt;=<span class="number">0</span>;j--) bin[++bin[<span class="number">0</span>]]=(curch&gt;&gt;j)&amp;<span class="number">1</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=bin[<span class="number">0</span>];j++)&#123;</span><br><span class="line">			ans=(ans&lt;&lt;<span class="number">1</span>)|bin[j];</span><br><span class="line">			<span class="keyword">if</span>(j%<span class="number">6</span>==<span class="number">0</span>)&#123;res[++res[<span class="number">0</span>]]=ans;ans=<span class="number">0</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=rest;i;i--) res[res[<span class="number">0</span>]-i+<span class="number">1</span>]=<span class="number">64</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=res[<span class="number">0</span>];i++)&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(ref[res[i]]);</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">76</span>==<span class="number">0</span>) </span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	&#125;<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">// 这里必须多打一个 putchar，不然不能换行……</span></span><br><span class="line">	<span class="keyword">if</span>(res[<span class="number">0</span>]%<span class="number">76</span>!=<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-逃跑（escape-cpp）"><a href="#2-逃跑（escape-cpp）" class="headerlink" title="2. 逃跑（escape.cpp）"></a>2. 逃跑（escape.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>因为门卫红美玲的失误，疏忽将入侵者放入了红魔馆。入侵者袭击了红魔馆的大小姐蕾米莉亚·斯卡雷特，大小姐在施放【必杀·斯卡雷特家绝技·抱头蹲防】无效后只好变成了好多蝙蝠，在红魔馆中分散开来。 </p>
<p>现在的当务之急是找到二小姐芙兰朵露·斯卡雷特，并且与大小姐化身成的所有蝙蝠集合在一点。你的任务就是帮她们找一条最佳路线。 </p>
<p>我们可以用一个无向图来表示红魔馆的地图。蝙蝠和二小姐走过任何一条边都要付出一定的代价。因为形态不同，蝙蝠和二小姐走同一条边付出的代价可能不同。但是如果某一只蝙蝠与二小姐碰面，那么二小姐由于蝙蝠的引导，以后的所有路程可以不支付代价。（也就是相当于二小姐和某只蝙蝠都走到某点，之后无视二小姐的存在。）现在已知所有蝙蝠，二小姐和目标集合点的位置，请你求出所有蝙蝠和二小姐行走代价的和的最小值。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行是5个正整数，n，m，k，S，T，分别代表无向图点数，边数，蝙蝠的数量，二小姐所在起点的编号，目标点的编号。 </p>
<p>第二行是k个正整数，分别代表大小姐每个蝙蝠所在的起点的编号。 </p>
<p>接下来有m行，每行有4个正整数，u，v，q，p，分别是该边的起点、终点，蝙蝠通过该路花费的代价，二小姐通过该路花费的代价。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>第一行是5个正整数，n，m，k，S，T，分别代表无向图点数，边数，蝙蝠的数量，二小姐所在起点的编号，目标点的编号。 </p>
<p>第二行是k个正整数，分别代表大小姐每个蝙蝠所在的起点的编号。 </p>
<p>接下来有m行，每行有4个正整数，u，v，q，p，分别是该边的起点、终点，蝙蝠通过该路花费的代价，二小姐通过该路花费的代价。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 5 2 3 4 </span><br><span class="line">1 5 </span><br><span class="line">1 2 3 5 </span><br><span class="line">3 2 3 5 </span><br><span class="line">2 4 4 9 </span><br><span class="line">3 4 9 6 </span><br><span class="line">5 4 1 1 </span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>【样例解释】</p>
<p>1号蝙蝠从1到2，花费3  二小姐从3到2，花费5，遇见蝙蝠，之后不计算费用 </p>
<p> 1号蝙蝠从2到4，花费4  2号蝙蝠从5到4，花费1  总计13</p>
<p>【数据规模】</p>
<p>其中30%：n&lt;=200。 </p>
<p>另有20%: 保证S=T。 </p>
<p>另有20%：保证k&lt;=5，n&lt;=1000,m&lt;=10000。 </p>
<p>100%：n&lt;=10000，m&lt;=100000，k&lt;=10000，1&lt;=S、T、u、v&lt;=n，1&lt;=p、q&lt;=1000，不保证蝙蝠起点互不相等，数据中可能有重边和自环，保证所有点均能走到T点（即不存在无解情况）。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>局部分做法：SPFA + DFS（60分）</strong></p>
</blockquote>
<p>考试时写的解法，先预处理出终点到所有点的单源最短路径，然后统计所有蝙蝠到终点的最短路径距离和，如果题目给出的 S=T，则直接输出作为答案（这里有 20pts）</p>
<p><strong>然后就是 DFS 标记每只蝙蝠通过最短路径到达终点时要经历的点，再做一次 SPFA，以二小姐的点为源点，计算每个被标记的点到新的源点的最短路径，再在其中取最小值</strong>，加上上一步算出的和即为答案，最终得分 60pts</p>
<blockquote>
<p><strong>正解：SPFA + 路径转化（100分）</strong></p>
</blockquote>
<p>很显然蝙蝠不一定要在最短路径上经过的点来接二小姐，因为二小姐到达这些点的花费通常比蝙蝠要高得多</p>
<p>枚举每个蝙蝠去接二小姐的点 $D$，设去接二小姐的蝙蝠为 $K_i$，那么这只蝙蝠需要的额外花费就为：</p>
<p>$dist[K_i][D]+dist[S][D]+dist[D][T]-dist[K_i][T]=delta$，也就是 $ans+=delta$</p>
<p>这样做的话，朴素做法需要预处理出每只蝙蝠，二小姐，终点到每个点的单源最短路径（如果会求多源最短路径的话到这一步就可以 AC 此题了），时间和空间都不能接受，考虑每个点的 $delta$ 值：</p>
<p>$delta(D)=min_{i=1}^n(dist[K_i,D]+dist[D][T]+dist[S][D]-dist[K_i][T])$</p>
<p>$ans=min<em>{i=1}^ndelta(i)+\sum</em>{i=1}^ndist[i][T]$ </p>
<p>其中 $delta(D)$ 的表达式中可以提出常值表达式（即不会被当前计算所改变的表达式）：<br>$delta(D)=min_{i=1}^n(dist[K_i][D]-dist[K_i][T])-dist[S][K]+dist[D][T]$ </p>
<p>变化的表达式值记作：$f(D)=delta(D)=min_{i=1}^n(dist[K_i][D]-dist[K_i][T])$</p>
<p><strong>考虑新设源点 $S’$ ，把 $S’$ 与所有蝙蝠在的点 $Ki$ 连接一条权值为 $-dist[K_i][t]$ 的边，然后计算以这个点为源点的单源最短路径，发现表达式和 $f(D)$ 一致，那么我们就可以一次最短路求出 $f$ 数组，然后又枚举得出答案了</strong></p>
<p>本题考查对最短路径表达式的理解，难点在于最后一步的新源点设置和转化，通过已知的目标表达式构造出能用最短路径求出的表达式从而解决问题</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 100005*8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> wsis[maxm],wbf[maxm],tot;</span><br><span class="line"><span class="type">int</span> n,m,S,T,k;<span class="type">int</span> pos[maxn];</span><br><span class="line"><span class="type">int</span> bf[maxn];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">3</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> W1,<span class="type">int</span> W2)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	wbf[tot]=W1;wsis[tot]=W2;head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;<span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> pr a,<span class="type">const</span> pr b)</span></span>&#123;<span class="keyword">return</span> a.second&gt;b.second;&#125;&#125;;</span><br><span class="line">priority_queue&lt;pr,vector&lt;pr&gt;,cmp&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> src=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(src!=<span class="number">-1</span>) <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">if</span>(src!=<span class="number">-1</span>) <span class="built_in">memset</span>(dist[id],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist[id]));</span><br><span class="line">	<span class="type">int</span> hx,hy,val;</span><br><span class="line">	<span class="keyword">if</span>(src!=<span class="number">-1</span>)&#123;</span><br><span class="line">		dist[id][src]=<span class="number">0</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(src,<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		hx=q.<span class="built_in">top</span>().first;</span><br><span class="line">		hy=q.<span class="built_in">top</span>().second;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(dist[id][hx]!=hy) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[hx];i;i=nxt[i])&#123;</span><br><span class="line">			val=(id==<span class="number">0</span> || id==<span class="number">2</span>)?wbf[i]:wsis[i];</span><br><span class="line">			<span class="keyword">if</span>(dist[id][to[i]]&gt;dist[id][hx]+val)&#123;</span><br><span class="line">				dist[id][to[i]]=dist[id][hx]+val;</span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(to[i],dist[id][to[i]]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;escape.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;escape.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="type">int</span> a,b,c,d;</span><br><span class="line">	<span class="built_in">fcin</span>(k);<span class="built_in">fcin</span>(S);<span class="built_in">fcin</span>(T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">fcin</span>(a),bf[a]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(a);<span class="built_in">fcin</span>(b);</span><br><span class="line">		<span class="built_in">fcin</span>(c);<span class="built_in">fcin</span>(d);</span><br><span class="line">		<span class="built_in">Eadd</span>(a,b,c,d);<span class="built_in">Eadd</span>(b,a,c,d);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">SPFA</span>(<span class="number">0</span>,T);<span class="built_in">SPFA</span>(<span class="number">1</span>,S); </span><br><span class="line">	ll ans=<span class="number">0</span>;<span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(bf[i])&#123;</span><br><span class="line">			dist[<span class="number">2</span>][i]=-dist[<span class="number">0</span>][i];</span><br><span class="line">			ans+=dist[<span class="number">0</span>][i]*bf[i];</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i,dist[<span class="number">2</span>][i]));</span><br><span class="line">		&#125;<span class="keyword">else</span> dist[<span class="number">2</span>][i]=<span class="number">1</span>&lt;&lt;<span class="number">28</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SPFA</span>(<span class="number">2</span>);</span><br><span class="line">	ll ret=<span class="number">1ll</span>&lt;&lt;<span class="number">55</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ret=<span class="built_in">min</span>(ret,ans+dist[<span class="number">2</span>][i]+dist[<span class="number">0</span>][i]+dist[<span class="number">1</span>][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-擦蛋（graze-cpp）"><a href="#3-擦蛋（graze-cpp）" class="headerlink" title="3. 擦蛋（graze.cpp）"></a>3. 擦蛋（graze.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>大小姐和二小姐汇合以后，大小姐从蝙蝠变回人形。这个时候入侵者发现了她们，二小姐看见了新的玩具，十分兴奋，使用了禁忌【四重存在】。此时密集的弹幕飞了过来，二小姐与她的分身该怎样躲过这一阵袭击呢？ </p>
<p>四重存在 == 分身有4个</p>
<p>我们假设对战场地是一条长度为n格的路，开始时二小姐与所有分身都在路的最左端第一格，而目标在路的最右端，也就是第n格。二小姐需要将分身都移动到路的最右一格，然后给予敌人致命一击。因为分身难以操纵，所以二小姐每单位时间只能操作1个分身向右移动一格。显然，二小姐需要4n-4的时间使得所有分身处于道路最右端。 </p>
<p>我们已知从开始4n-4时间内每时刻，道路的某一格内的弹幕数。对于每个分身分别计算，如果在第t时刻,该分身位于第i格，那么则会：1.受到该时刻第i格内弹幕数量的伤害，称为miss数（指走位失误的数量）。2.如果该分身上一时刻在第i-1格，得到该时刻i-1格内弹幕数量的分数，称为graze数（指擦弹数）。（如果该分身此回合没有移动，不计算擦弹数。） </p>
<p>总miss就是这4n-4时间段内所有分身所有miss之和，总graze数是这4n-4时间段内所有分数的graze数之和。现在想知道miss数最小的情况下，graze数最大为多少。输出这个miss数和graze数。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第一行是1个正整数n，代表道路长度。 </p>
<p>接下来有4n-4行，每行n个整数，第i行第j个数代表在i时刻（开始为0时刻）在第j格内受到的伤害。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>两个整数，用空格隔开，分别代表最小的miss数，和在miss数最小的情况下最大的graze 数。 </p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">30 10</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>【样例解释 】</p>
<p> 只有一种走法。 </p>
<p> 第一回合：第一格3分身，第二格1分身，miss5，graze1。 </p>
<p> 第二回合：第一格2分身，第二格2分身，miss8，graze2。第三回合：第一格1分身，第二格3分身，miss9，graze3。 </p>
<p>第四回合：第一格0分身，第二格4分身，miss8，graze4。 </p>
<p>【数据约定 】</p>
<p> 其中30%数据:n&lt;=3      其中50%数据:n&lt;=10 其中70%数据:n&lt;=30 </p>
<p>100%数据:n&lt;=100,每时刻每格中弹幕数均为正数且小于1000 </p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>30分做法：搜索</strong></p>
</blockquote>
<p>朴素的搜索算法，考试时还想着剪枝优化，结果发现剪了枝和没剪没什么区别……</p>
<blockquote>
<p><strong>100分做法：DP+各种优化</strong></p>
</blockquote>
<p><strong>1级 DP</strong></p>
<p>设 $f[t][i][j][k][l]=(miss,\;graze)$ 表示在 $t$ 时刻，四个分身位于 $i,\;j,\;k,\;l$ 四个位置时的最小 $miss$ 值以及最大 $graze$ 值，按照题意 $miss$ 值小的优先，这点可以在重载运算符时实现，然后转移方程也比较好想：</p>
<p>设 $cost[i]$ 为 $i$ 位置在当前时刻 $t$ 的弹幕数量，则：</p>
<p>$f[t][i][j][k][l]=min\begin{cases} f[t-1][i-1][j][k][l]+(cost[i+j+k+l],\;cost[i-1])\\f[t-1][i][j-1][k][l]+(cost[i+j+k+l],\;cost[j-1])\\f[t-1][i][j][k-1][l]+(cost[i+j+k+l],\;cost[k-1])\\f[t-1][i][j][k][l-1]+(cost[i+j+k+l],\;cost[l-1]) \end{cases}$</p>
<p>这一个转移方程的控件和时间复杂度都达到了 $O((4n-4)\times n^4)$，可以过 50% 的数据</p>
<p><strong>2级 DP</strong></p>
<p>由于每时刻只能操作一个分身向前移动一格，所以 $t$ 也就是所有分身的位置总和（设 0 为起点，n-1 为终点），那么只需要枚举前三个 $i,\;j,\;k$ 就能确定剩下的 $l$ ，复杂度为  $O((4n-4)\times n^3)$ ，可以过掉 70 pts</p>
<p><strong>3级DP</strong></p>
<p><strong>首先，$f[t]$ 的状态只和 $f[t-1]$ 有关，所以可以用滚动数组优化，降低空间复杂度</strong></p>
<p><strong>其次，考虑互换每个分身的位置，我们发现由于分身是一样的，所以将任一时刻的分身随意互换位置对计算的答案毫无影响，</strong>于是可以规定 $i&gt;j&gt;k&gt;l$ ，从而减少枚举的状态，过 100pts 的数据点</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 125</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> miss,graze;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(miss!=x.miss) <span class="keyword">return</span> miss&lt;x.miss;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> graze&gt;x.graze;</span><br><span class="line">	&#125;</span><br><span class="line">	node <span class="keyword">operator</span> +(<span class="type">const</span> node &amp;x)&#123;</span><br><span class="line">		<span class="keyword">return</span> (node)&#123;miss+x.miss,graze+x.graze&#125;; </span><br><span class="line">	&#125;</span><br><span class="line">	node&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> node &amp;x)&#123;</span><br><span class="line">		miss+=x.miss;graze+=x.graze;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;f[<span class="number">2</span>][maxn][maxn][maxn];</span><br><span class="line"><span class="type">int</span> n,cost[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(node &amp;x,node y[maxn][maxn][maxn],<span class="type">int</span> p1,<span class="type">int</span> p2,<span class="type">int</span> p3,<span class="type">int</span> p4,<span class="type">int</span> delta)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p1&lt;p2) <span class="built_in">swap</span>(p1,p2);</span><br><span class="line">	<span class="keyword">if</span>(p2&lt;p3) <span class="built_in">swap</span>(p2,p3);</span><br><span class="line">	<span class="keyword">if</span>(p3&lt;p4) <span class="built_in">swap</span>(p3,p4);</span><br><span class="line">	node cur=y[p1][p2][p3];</span><br><span class="line">	cur.graze+=delta;</span><br><span class="line">	<span class="keyword">if</span>(cur.miss&lt;x.miss || (cur.miss==x.miss &amp;&amp; cur.graze&gt;x.graze)) x=cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;graze.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;graze.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);</span><br><span class="line">	<span class="type">int</span> curStat=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(f[curStat],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f[curStat]));</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>*(n<span class="number">-1</span>);i++)&#123;</span><br><span class="line">		curStat=!curStat;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p++) <span class="built_in">fcin</span>(cost[p]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x=<span class="built_in">min</span>(n<span class="number">-1</span>,i);x&gt;=<span class="number">0</span>;x--)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="built_in">min</span>(x,i-x);<span class="number">3</span>*y+x&gt;=i&amp;&amp;y&gt;=<span class="number">0</span>;y--)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> z=<span class="built_in">min</span>(y,i-x-y);<span class="number">2</span>*z+y+x&gt;=i&amp;&amp;z&gt;=<span class="number">0</span>;z--)&#123;</span><br><span class="line">			<span class="type">int</span> w=i-x-y-z;</span><br><span class="line">			f[curStat][x][y][z]=(node)&#123;<span class="number">1</span>&lt;&lt;<span class="number">28</span>,<span class="number">1</span>&lt;&lt;<span class="number">28</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(x) <span class="built_in">calc</span>(f[curStat][x][y][z],f[<span class="number">1</span>-curStat],x<span class="number">-1</span>,y,z,w,cost[x<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(y) <span class="built_in">calc</span>(f[curStat][x][y][z],f[<span class="number">1</span>-curStat],x,y<span class="number">-1</span>,z,w,cost[y<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(z) <span class="built_in">calc</span>(f[curStat][x][y][z],f[<span class="number">1</span>-curStat],x,y,z<span class="number">-1</span>,w,cost[z<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(w) <span class="built_in">calc</span>(f[curStat][x][y][z],f[<span class="number">1</span>-curStat],x,y,z,w<span class="number">-1</span>,cost[w<span class="number">-1</span>]);</span><br><span class="line">			f[curStat][x][y][z].miss+=cost[x]+cost[y]+cost[z]+cost[w];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node ans=f[curStat][n<span class="number">-1</span>][n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,ans.miss,ans.graze);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | 贪心 | 图论 | 201901025考试  ：解题报告</title>
    <url>/2019/10/25/2019-10-25-exam/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. <strong>trapped</strong></td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">2. <strong>array</strong></td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">3. <strong>travel</strong></td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-陷阱（trapped-cpp）"><a href="#1-陷阱（trapped-cpp）" class="headerlink" title="1. 陷阱（trapped.cpp）"></a>1. 陷阱（trapped.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>FJ将N(1&lt;=N&lt;=100000)堆干草放在了一条平直的公路上。第j堆干草的大小为Sj，坐标为Pj。奶牛贝茜位于一个没有干草堆的点B。</p>
<p>奶牛Bessie可以在路上自由移动，甚至可以走到某个干草堆上，但是不能穿过去。如果她朝同一个方向跑了D个单位的距离，那么她就有足够大的速度去击碎任何大小严格小于D的干草堆。当然，在这之后她就可以获得了更大的活动空间，以尝试击碎更多干草堆。</p>
<p>约翰可以指定某堆干草，并增大它的大小，他想知道他最少需要     增大多少，才能把奶牛贝茜困住（即在第一堆干草和最后一堆干草之间），或者根本不可能。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数，分别表示N和B</p>
<p>接下来N行，每行两个整数S,J ，描述了干草堆的大小和坐标</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示FJ需要增加的最小值。如果不可能阻止Bessie，则输出-1</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">8 1</span><br><span class="line">1 4</span><br><span class="line">3 8</span><br><span class="line">12 15</span><br><span class="line">20 20</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>所有干草堆的位置和大小都属于[1,10^9]</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法一：暴力枚举（50分）</strong></p>
</blockquote>
<p>将所有干草堆按照Bessie的起点位置分成左右两个部分，然后每个部分内按照位置坐标升序排序</p>
<p>设 $f[i]$ 表示将Bessie阻挡在第 $i$ 堆干草块前最少需要在这堆干草上加的干草高度，于是可以得到：</p>
<p>$f[i]=min\lbrace abs(pos[j]-pos[i]-siz[i])\; \lvert\; pos[j]\geq abs(pos[j]-pos[i])\; \rbrace$</p>
<p>这样枚举寻找满足条件的 $j$ 的过程中，若遇到 $siz[i]\geq \lvert pos[j]-pos[i] \rvert$ 可以直接输出 0,复杂度接近 $O(n^2)$</p>
<blockquote>
<p><strong>做法二：近似贪心（100分）</strong></p>
</blockquote>
<p>我们可以指定Bessie往一个方向突破（左或者右），然后考虑花费最少的干草高度堆在某一个Bessie突破方像的干草堆上使得她不能出去</p>
<p>这样做的前提就是左边的干草堆必须能够承受Bessie的撞击，假设当前考虑突破到右边的第 $i$ 个干草堆，那么左边就必须存在干草堆 $j$ 使得 $\lvert pos[j]-pos[i] \rvert\leq siz[j]$ 然后我们才能放心的在这个右边的干草堆上面堆草</p>
<p>那么Bessie往左边突破的时候同理分析，最后类似贪心的做法能在近似 $O(n)$ 的时间复杂度内得到答案</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> siz,pos;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pos&lt;x.pos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;dl[maxn],dr[maxn];</span><br><span class="line"><span class="type">int</span> n,st,cl,cr;</span><br><span class="line"><span class="type">bool</span> l[maxn],r[maxn],del[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn];<span class="type">int</span> sign;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;trapped.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;trapped.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(st);</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(x);<span class="built_in">fcin</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(y&lt;st) dl[++cl]=(node)&#123;x,y&#125;;</span><br><span class="line">		<span class="keyword">else</span> dr[++cr]=(node)&#123;x,y&#125;;</span><br><span class="line">	&#125;<span class="built_in">sort</span>(dl+<span class="number">1</span>,dl+cl+<span class="number">1</span>);<span class="built_in">sort</span>(dr+<span class="number">1</span>,dr+cr+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">-1</span>,sign=cl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cr &amp;&amp; sign;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(sign &amp;&amp; <span class="built_in">abs</span>(dr[i].pos-dl[sign].pos)&gt;dl[sign].siz) sign--;</span><br><span class="line">		<span class="keyword">if</span>(!sign) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(dr[i].pos-dl[sign].pos)&lt;=dr[i].siz) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans=<span class="built_in">abs</span>(dr[i].pos-dl[sign].pos)-dr[i].siz;</span><br><span class="line">		<span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(dr[i].pos-dl[sign].pos)-dr[i].siz);</span><br><span class="line">	&#125;sign=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cl;i&amp;&amp;sign&lt;=cr;i--)&#123;</span><br><span class="line">		<span class="keyword">while</span>(sign&lt;=cr &amp;&amp; <span class="built_in">abs</span>(dl[i].pos-dr[sign].pos)&gt;dr[sign].siz) sign++;</span><br><span class="line">		<span class="keyword">if</span>(sign&gt;cr) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">abs</span>(dr[sign].pos-dl[i].pos)&lt;=dl[i].siz) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans=<span class="built_in">abs</span>(dr[sign].pos-dl[i].pos)-dl[i].siz;</span><br><span class="line">		<span class="keyword">else</span> ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(dr[sign].pos-dl[i].pos)-dl[i].siz);</span><br><span class="line">	&#125;<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-数列（array-cpp）"><a href="#2-数列（array-cpp）" class="headerlink" title="2. 数列（array.cpp）"></a>2. 数列（array.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>有两个位置分别对应的序列A、B，长度为n，两序列都为n的一个排列。当Ai == Bj时，上下会连一条边。</p>
<p>你可以选择序列A或者序列B进行旋转任意K步，</p>
<p>如 3 4 1 5 2 旋转两步为 5 2 3 4 1。</p>
<p>求旋转后最小的相交的线段的对数。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>第一行是N</p>
<p>接下来N行,每行一个整数，表示A[i]</p>
<p>再接下来N行,每行一个整数，表示B[i]</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>输出最小的相交的线段对数</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5 4 1 3 2</span><br><span class="line">1 3 2 5 4</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>1≤N≤100,000</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>题目所说的 “两个数列相交的线段最小” 其实就是尽可能多的将 a 数列中的数与 b 数列中的数一一对应，进一步的，<strong>如果将 b 数列中的元素在 a 数列中出现的位置做成新的一个序列（例如样例的序列为 <code>3 4 5 1 2</code>）所谓的最小的相交线段数就是这个序列的最少的逆序对数</strong></p>
<p>由于 a 数列可以旋转，那么对应出来的新的序列也是可以旋转的，但是我们不用每次旋转之后计算新的逆序对数，只需要记录最开始的逆序对数为 $ans$，那么假设当前新序列的末尾元素为 $p[i]$，它被旋转到了第一位，那么序列中减少的逆序对数就是原来比 $p[i]$ 大的元素个数，增加的逆序对数就是原来比 $p[i]$ 小的元素个数，由于题目给出的序列是 $[1,\;n]$ 的一个全排列，那么新的逆序对数 $ans’=ans-(n-p[i])+p[i]-1$，那么从尾到头把序列扫描一遍取最小值即可</p>
<p>P.S. 由于题目中说两个数列都可以旋转，所以上述操作要对 $(b\leftarrow a)$ 和 $(a\leftarrow b)$ 各自做一遍，取最小值</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;ll T[maxn];</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="type">int</span> vis[maxn],f[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		T[i]+=<span class="number">1ll</span>*d;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">		ans+=T[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">init</span><span class="params">(<span class="type">int</span> ref[maxn],<span class="type">int</span> op[maxn])</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="built_in">sizeof</span>(T));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) vis[ref[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=vis[op[i]];</span><br><span class="line">	ll ans=<span class="number">0</span>,tmp,res;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">		ans+=<span class="built_in">sum</span>(f[i]);</span><br><span class="line">		<span class="built_in">updata</span>(f[i],<span class="number">1</span>);</span><br><span class="line">	&#125;res=ans;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">		tmp=ans-(n-f[i])+f[i]<span class="number">-1</span>;</span><br><span class="line">		res=<span class="built_in">min</span>(res,tmp);</span><br><span class="line">		ans=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;array.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;array.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">fcin</span>(b[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">min</span>(<span class="built_in">init</span>(a,b),<span class="built_in">init</span>(b,a)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-旅游（travel-cpp）"><a href="#3-旅游（travel-cpp）" class="headerlink" title="3. 旅游（travel.cpp）"></a>3. 旅游（travel.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>某城市有N个旅游胜地（1≤N≤1000），编号为1…N，每个旅游胜地都有一个愉悦度Q。如果去i胜地旅游，可以获得Qi单位的愉悦度。每块胜地最多和10块胜地有相连的道路，在相连的两个胜地之间走动需要消耗E单位的愉悦度（1≤E≤1,000,000)。你可以从任意一个胜地开始旅游，并且想要在获得了最多愉悦度的时候停止。你是一个挑剔的旅行者，一旦去过某个胜地，她就不会再去愉悦度相同或更低的胜地！但是你可以路过某些胜地，而不停下来享受旅游（从而不获得该圣地的愉悦度）。实际上，如果路过一块高愉悦度的胜地，等一下返回再去享受旅游，有时会更有利！请计算你能够获得的愉悦度的最大值。</p>
<h3 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h3><p>第1行：包含两个整数N和E。</p>
<p>接下来N行：每行描述一块胜地，首先两个整数Q和D，分别表示该胜地的愉悦度（范围1…1,000,000）和相连的其他胜地的数量。然后紧接着D个整数表示相连的胜地编号。</p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>输出你能够获得的愉悦度的最大值。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">4 1 2</span><br><span class="line">1 3 1 3 4</span><br><span class="line">6 2 2 5</span><br><span class="line">5 2 2 5</span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>NO HINT</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p><strong>做法：BFS（或SPFA）+ DP</strong></p>
</blockquote>
<p>由于题目中限制了在旅游完一个景点之后只能去比它愉悦度更高的景点，那么我们可以根据愉悦度从大到小给每个景点排序，设 $f[i]$ 表示以 $i$ 号旅游景点为起点能得到的最大愉悦度</p>
<p>那么显然，若以 $i$ 号景点为起点，我们只能去 $[1,\;i-1]$ 号旅游景点旅游（不是路过），并且还要减去路上的花销，由于题目中的边权值是一样的，所以对于每个点直接 BFS 一次就可以到得到它到每个点的边权和，所以转移方程为：</p>
<p>$f[i]=max(f[i],\; f[j]+Q[id[i]]-dist[id[i]][id[j]])$，这里的 $id$ 表示排序后的数组对应到原来的旅游景点的编号</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">int</span> tot,n,costE,q[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn]; <span class="type">int</span> cost[maxn][maxn];</span><br><span class="line">ll f[maxn];<span class="type">int</span> id[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> src)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cost[src],<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(cost[src]));</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(src);vis[src]=<span class="literal">true</span>;cost[src][src]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> hx;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		hx=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[hx];i;i=nxt[i])</span><br><span class="line">			<span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">				vis[to[i]]=<span class="literal">true</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">				cost[src][to[i]]=cost[src][hx]+costE;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> q[x]&gt;q[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;travel.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;travel.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(costE);</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(q[i]);<span class="built_in">fcin</span>(x);</span><br><span class="line">		id[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;</span><br><span class="line">			<span class="built_in">fcin</span>(y);</span><br><span class="line">			<span class="built_in">Eadd</span>(i,y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="built_in">bfs</span>(i);</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,cmp);ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		f[i]=q[id[i]];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++) f[i]=<span class="built_in">max</span>(f[i],q[id[i]]+f[j]-cost[id[i]][id[j]]);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	&#125;<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>LrcEditor开发记（一）api接口</title>
    <url>/2020/02/02/2020-02-02-LRCEditor01/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目地址：<a href="https://github.com/Yan2u/LrcEditor">Github</a></p>
<p>前一段时间将我写的歌词编辑器 <code>LRCEditor</code> 完善了一下，添加了一个搜索歌词的功能，但是仅限于网易云<del>（因为网易云音乐的API是最好搞的）</del>，有一些网易云上面没有版权的歌曲自然就搜不到歌词，非常影响体验</p>
<p>于是就想到将另外两家音乐软件：QQ音乐和酷狗音乐的 API 也搞过来，添加到搜索功能里面去，这样基本上就不用担心搜不到歌词了:)</p>
<p>然后就花了整整一天时间研究他们的 API……</p>
<p>这里将 QQ 音乐和酷狗音乐的 API 接口使用整理一下，看到这篇文章并且有需要的小伙伴就可以直接拿去用了:)</p>
<p><em>P.S.1 整理的时间是 2020 年 2 月，有些接口过了一段时间可能就被更换了，所以看完还请自己先验证一波……</em></p>
<p><em>P.S.2 本文中接口网址返回的数据均为 JSON 字符串</em></p>
<p><em>P.S.3 有关网易云接口的整理在另一篇博文里，链接：<a href="http://wuyanxi.top/2019/09/13/OLGetLRC.html"><strong>VB.NET | 在线获取歌词方法的小小总结</strong></a></em></p>
<h2 id="1-QQ-音乐部分"><a href="#1-QQ-音乐部分" class="headerlink" title="1. QQ 音乐部分"></a>1. QQ 音乐部分</h2><h3 id="搜索歌曲"><a href="#搜索歌曲" class="headerlink" title="搜索歌曲"></a>搜索歌曲</h3><p><strong>网址格式：</strong><code>https://c.y.qq.com/soso/fcgi-bin/client_search_cp?aggr=1&amp;cr=1&amp;flag_qc=0&amp;p=&#123;0&#125;&amp;n=20&amp;w=&#123;1&#125;</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><code>p=&#123;0&#125;</code> 表示返回搜索结果中的第几页，和 <code>n=20</code> 一起用</li>
<li><code>n=20</code> 每页返回的结果数量</li>
<li><code>w=&#123;1&#125;</code> 要搜索的关键字</li>
</ol>
<p><strong>调用例子：</strong><code>https://c.y.qq.com/soso/fcgi-bin/client_search_cp?aggr=1&amp;cr=1&amp;flag_qc=0&amp;p=1&amp;n=20&amp;w=Faded</code></p>
<p>这一步可以获取歌曲的一些基本信息（名字，艺术家，专辑，时长等），同时需要在返回的信息里面获取歌曲的 <code>mid</code>，接下来获取歌词，封面图片，播放的文件都要用到</p>
<h3 id="获取歌词"><a href="#获取歌词" class="headerlink" title="获取歌词"></a>获取歌词</h3><p>这一个接口网址好像没有人介绍过？？？就是直接打开QQ音乐（网页版）的播放界面，然后F12，在Network 里面筛选XHR格式且含有 Lyric 关键词的文件，就会发现有一个文件是指向这个网址的</p>
<p><strong>网址格式：</strong><code>https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg?-=MusicJsonCallback_lrc&amp;songmid=&#123;0&#125;&amp;g_tk=758816886&amp;format=json&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq.json&amp;needNewCode=0</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><code>songmid=&#123;0&#125;</code> 表示上一步中获取到的歌曲 <code>mid</code> 值</li>
</ol>
<p><strong>调用例子：</strong><code>https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg?-=MusicJsonCallback_lrc&amp;songmid=004QK3K60anL4V&amp;g_tk=758816886&amp;format=json&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq.json&amp;needNewCode=0</code></p>
<p>然后，你会发现返回的是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;retcode&quot;</span><span class="punctuation">:</span><span class="number">-1310</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">-1310</span><span class="punctuation">,</span><span class="attr">&quot;subcode&quot;</span><span class="punctuation">:</span><span class="number">-1310</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>别慌，这是 QQ 音乐防止爬取数据而设置的障碍，我们只需要在 Request 里面设置两个东西：</p>
<ol>
<li><code>Referer = https://y.qq.com/portal/player.html</code></li>
<li><code>skey = ......</code></li>
</ol>
<p>第二个 <code>skey</code> 每次访问都是会变化的，但是服务器不会检测它的正确性，所以直接拿浏览器访问一次之后把 <code>skey</code> 放到代码中即可</p>
<p>然后就可以正常访问了，用 C# 实现的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">HttpWebRequest req = (HttpWebRequest)WebRequest.Create(<span class="string">&quot;https://c.y.qq.com/lyric/fcgi-bin/fcg_query_lyric_new.fcg?-=MusicJsonCallback_lrc&amp;songmid=&#123;0&#125;&amp;g_tk=758816886&amp;format=json&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq.json&amp;needNewCode=0&quot;</span>);</span><br><span class="line">req.Headers.Add(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;skey=@Y3TD47qBo&quot;</span>);</span><br><span class="line">req.Referer = <span class="string">&quot;https://y.qq.com/portal/player.html&quot;</span>;</span><br><span class="line"><span class="comment">// 注意这里不能 req.Headers.Set(&quot;Referer&quot;,&quot;https://y.qq.com/portal/player.html&quot;);</span></span><br><span class="line">Stream stream = req.GetResponse().GetResponseStream();</span><br><span class="line">StreamReader sr = <span class="keyword">new</span> StreamReader(Encoding.UTF8, stream);</span><br><span class="line"><span class="built_in">string</span> lyric = sr.ReadToEnd();</span><br></pre></td></tr></table></figure>
<p>然而，你会发现，返回的字符串是这个样子的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;W3RpOkxBU1QgU1RBUkRVU1QgKOOAikZhdGUvc3RheSBuaWdodCAoVW5saW1pdGVkIEJsYWRlIFdvcmtzKeOAi1RW5Yqo55S75o+S5puyKV0KW2FyOkFpbWVyICjjgqjjg6EpXQpbYWw6REFXTiAo6buO5piOKV0KW2J5Ol0KW29mZnNldDowXQpba2FuYToxMTExMeOBlzHjgY3jgofjgY8x44Go44GzMeOBquOBhDHjgb7jgZUx44Gy44KNMeOBpOOCiDHjgYLjgoEx44GI44GMMeOChjHjgoEx44GvMeOBteOCizHjgYvjgZ8x44GsMeOBguOCizHjgaTjgaUx44GZMeOBjTHjgaHjgYQx44GmMeOBmeOBjTHjgb4x44GGMeOBhOOCjTHjgY0x44GNMeOBiuOBjzHjgbLjgo0x44GC44GkMeOBhOOBqDHjg .....(后面很多很多就不放出来了)&quot;</span></span><br></pre></td></tr></table></figure>
<p>也不要慌，这个一长串明显是 Base64 加密处理过的，我们只需要一下就能把它还原成本来的样子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> new_lyric = Encoding.UTF8.GetString(Convert.FromBase64String(lyric));</span><br></pre></td></tr></table></figure>
<h3 id="获取专辑的封面"><a href="#获取专辑的封面" class="headerlink" title="获取专辑的封面"></a>获取专辑的封面</h3><p><strong>网址格式：</strong><code>http://imgcache.qq.com/music/photo/album_500/17/500_albumpic_&#123;0&#125;_0.jpg</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><code>500_albumpic_&#123;0&#125;_0.jpg</code> 在 <code>&#123;0&#125;</code> 处填上第一步获取的专辑 <code>mid</code> 值（不是歌曲 <code>mid</code>）</li>
</ol>
<p><strong>调用例子：</strong><code>http://imgcache.qq.com/music/photo/album_500/17/500_albumpic_8217_0.jpg</code></p>
<p>这个网址打开了是 500×500 的封面图，如果想要自定义大小，把地址中两个 500 都改成对应的大小即可</p>
<h3 id="获取可以播放的文件"><a href="#获取可以播放的文件" class="headerlink" title="获取可以播放的文件"></a>获取可以播放的文件</h3><p>这一步比较复杂，如果不是控制台程序建议弄成异步</p>
<p>获取文件，要先获取它的 Token（就是一种类似于通行证的东西）：</p>
<p><strong>网址#1 格式：</strong><code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json205361747&amp;platform=yqq&amp;cid=205361747&amp;songmid=&#123;0&#125;&amp;filename=&#123;1&#125;&amp;guid=126548448</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><p><code>songmid=&#123;0&#125;</code> 歌曲的 <code>mid</code> 值</p>
</li>
<li><p><code>filename=&#123;1&#125;</code> 由歌曲的 <code>mid</code> 值拼接而来，<code>filename = &#39;C400&#39; + mid + &#39;.m4a&#39;</code></p>
<p>例如 <code>mid</code> 为 <code>004QK3K60anL4V</code>，文件名就是 <code>C400004QK3K60anL4V.m4a</code></p>
</li>
</ol>
<p><strong>调用例子：</strong><code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json205361747&amp;platform=yqq&amp;cid=205361747&amp;songmid=004QK3K60anL4V&amp;filename=C400004QK3K60anL4V.m4a&amp;guid=126548448</code></p>
<p>另外的参数例如 <code>cid</code> 和 <code>guid</code> 都是可以写死的，所以就不用管了</p>
<p>在这一步的返回值里面可以看到 <code>&#123;&quot;vkey&quot; : &quot;...&quot;&#125;</code> 的字段，<code>vkey</code> 就是用来拼成获取播放文件的网址的东西</p>
<p><strong>网址#2 格式：</strong><code>http://ws.stream.qqmusic.qq.com/&#123;0&#125;?fromtag=0&amp;guid=126548448&amp;vkey=&#123;1&#125;</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><code>&#123;0&#125;</code> 上一步提到的 <code>filename</code>，用歌曲 <code>mid</code> 值加工而成</li>
<li><code>vkey=&#123;1&#125;</code> 填刚刚得到的 <code>vkey</code></li>
</ol>
<p><strong>调用例子：</strong><code>http://ws.stream.qqmusic.qq.com/C400004QK3K60anL4V.m4a?fromtag=0&amp;guid=126548448&amp;vkey=...</code>（vkey很长就不写出来了）</p>
<p>打开网址就是一个 m4a 文件，大功告成！</p>
<h2 id="2-酷狗音乐部分"><a href="#2-酷狗音乐部分" class="headerlink" title="2. 酷狗音乐部分"></a>2. 酷狗音乐部分</h2><p>相比起 QQ 音乐，酷狗音乐的 API 接口的破解要简单一些</p>
<h3 id="搜索歌曲-1"><a href="#搜索歌曲-1" class="headerlink" title="搜索歌曲"></a>搜索歌曲</h3><p><strong>网址格式：</strong><code>http://mobilecdn.kugou.com/api/v3/search/song?format=json&amp;keyword=&#123;1&#125;&amp;page=&#123;0&#125;&amp;pagesize=20&amp;showtype=1</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><code>page</code> 和 <code>pagesize</code> 页数和每页返回的结果数量</li>
<li><code>keyword</code> 要搜索的关键字</li>
</ol>
<p><strong>调用例子：</strong><code>http://mobilecdn.kugou.com/api/v3/search/song?format=json&amp;keyword=Faded&amp;page=1&amp;pagesize=20&amp;showtype=1</code></p>
<p>这一步可以获取歌曲的一些基本信息（名字，艺术家，专辑，时长等），同时需要记录歌曲的 <code>hash</code> 值，接下来会用到</p>
<h3 id="获取专辑封面，歌词，和播放文件"><a href="#获取专辑封面，歌词，和播放文件" class="headerlink" title="获取专辑封面，歌词，和播放文件"></a>获取专辑封面，歌词，和播放文件</h3><p><strong>网址格式：</strong><code>https://www.kugou.com/yy/index.php?r=play/getdata&amp;hash=&#123;0&#125;</code></p>
<p><strong>参数说明：</strong></p>
<ol>
<li><code>hash=&#123;0&#125;</code> 上一步得到的歌曲 <code>hash</code> 值</li>
</ol>
<p><strong>调用例子：</strong><code>https://www.kugou.com/yy/index.php?r=play/getdata&amp;hash=F139D898F1ED75CAD7B582BD1BAC0093</code></p>
<p>然后，你可能会发现，返回的是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span><span class="attr">&quot;err_code&quot;</span><span class="punctuation">:</span><span class="number">20010</span><span class="punctuation">,</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果不是这个结果，那么将浏览器的 <code>Cookie</code> 清除掉，刷新一下，就会是这个返回值</p>
<p>然而，如果用代码来直接访问的话，结果就一定会变成这样</p>
<p>但我们还是不慌，现在先输入酷狗官网的网址 <code>www.kugou.com</code>，随便点进去听一首歌，再把这个网址输进去，你就会发现，返回值变得正常了</p>
<p>再看这个网址，他有 <code>www.kugou.com</code> 的前缀，也就是说，访问这个网址时，和访问官网时用的是同一批数据，问题肯定就出在这批数据上了，经过反复尝试，我发现是 <code>Cookie</code> 中的 一个 <code>kg_mid</code> 字段决定了返回值正常与否</p>
<p>关于这个字段，网上有专门计算的方法和程序：<a href="https://blog.csdn.net/ychgyyn/article/details/90110296"><strong>酷狗音乐网站前端JS的逆向破解过程</strong></a>，但是实际上我们并不需要每次访问时都计算一遍，就像刚才的 <code>skey</code>，这个 <code>kg_mid</code> 也是属于有就行的那一类，服务器并不会检查它的正确性，所以还是浏览器访问一次，然后复制粘贴到代码当中即可：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">HttpWebRequest req = (HttpWebRequest)WebRequest.Create(<span class="keyword">new</span> Uri(LInterface.KuGouMusic_Detail(QMid)));</span><br><span class="line">CookieContainer cookie = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">cookie.Add(<span class="keyword">new</span> Cookie(<span class="string">&quot;kg_mid&quot;</span>, <span class="string">&quot;c8c679b1e10cd05ed4d0e55dc2da4b0a&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;.kugou.com&quot;</span>));</span><br><span class="line"><span class="comment">// 这里的 new 方法必须写四个参数，否则运行错误</span></span><br><span class="line">req.CookieContainer = cookie;</span><br><span class="line">HttpWebResponse resp = (HttpWebResponse)req.GetResponse();</span><br></pre></td></tr></table></figure>
<p>专辑封面，播放文件的网址和歌词都在返回值里面了，看英文就可以判断出来，于是酷狗的 API 接口破解成功！</p>
<p>但是，我们注意到酷狗 API 中返回的歌词是没有翻译的！！！<del>不是中文歌搜没有翻译的歌词还有什么用</del>，本着一条龙服务的原则，我决定再做一个 API 用来翻译……</p>
<h2 id="3-Google翻译-API"><a href="#3-Google翻译-API" class="headerlink" title="3. Google翻译 API"></a>3. Google翻译 API</h2><p>这部分的大多数内容转载自：<a href="https://www.cnblogs.com/marso/p/google_translate_api.html"><strong>C#实现谷歌翻译API</strong></a>，不同的地方在于这篇文章用的是 <code>www.translate.google.com</code> 这个网址，现在已经访问不到了，不过我们还有 <code>www.translate.google.cn</code> 这个国内版的翻译网址，获取 API 的方式也基本一致</p>
<h3 id="获取-TKK"><a href="#获取-TKK" class="headerlink" title="获取 TKK"></a>获取 TKK</h3><p>打开 <code>www.translate.google.cn</code> ，随便输入点英文，然后 F12 打开看 Network，发现只有这个网址指向了翻译的结果：<code>https://translate.google.cn/translate_a/single?client=webapp&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=ss&amp;dt=t&amp;source=bh&amp;ssel=0&amp;tsel=0&amp;kc=1&amp;tk=262549.177587&amp;q=...</code> </p>
<p><strong>分析：</strong>注意到整个网址中只有 <code>q=...</code> 是我们输入的内容，<code>sl</code> 和 <code>tl</code> 分别是源语言和目标语言（<code>sl</code> 填 auto 就相当于自动检测语言了），其它的字段都是自动填好的</p>
<p>然后注意到一个重要的字段 <code>tk=262549.177587</code>，注意到每次打开这个页面后，附带的 <code>tk</code> 都是不一样的，而且我们看不出什么规律</p>
<p><code>tk</code> 嘛，就相当于 <code>ticket</code> ，票的意思，应该就是 Google 防止随意调用翻译 API 设置的障碍了</p>
<p>这个 <code>tk</code> 其实和两个东西有关，一个是我们输入的内容，另一个是隐藏在页面 HTML 文档中的 <code>TKK</code> 值，可认为，两者都是浮点数类型，那么有可能 <code>tk</code> 就是由 <code>TKK</code> 计算得到的</p>
<h3 id="计算-tk"><a href="#计算-tk" class="headerlink" title="计算 tk"></a>计算 tk</h3><p>监视发现，网站中有一个 JS 调用了这个 <code>TKK</code> 并通过某种算法生成了 <code>tk</code> ，网上已经有人破解了这段算法的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> d = <span class="number">0</span>; d &lt; b.<span class="property">length</span> - <span class="number">2</span>; d += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = b.<span class="title function_">charAt</span>(d + <span class="number">2</span>),</span><br><span class="line">            c = <span class="string">&quot;a&quot;</span> &lt;= c ? c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - <span class="number">87</span> : <span class="title class_">Number</span>(c),</span><br><span class="line">            c = <span class="string">&quot;+&quot;</span> == b.<span class="title function_">charAt</span>(d + <span class="number">1</span>) ? a &gt;&gt;&gt; c : a &lt;&lt; c;</span><br><span class="line">        a = <span class="string">&quot;+&quot;</span> == b.<span class="title function_">charAt</span>(d) ? a + c &amp; <span class="number">4294967295</span> : a ^ c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> tk =  <span class="keyword">function</span> (<span class="params">a,TKK</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="variable constant_">TKK</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>), h = <span class="title class_">Number</span>(e[<span class="number">0</span>]) || <span class="number">0</span>, g = [], d = <span class="number">0</span>, f = <span class="number">0</span>; f &lt; a.<span class="property">length</span>; f++) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = a.<span class="title function_">charCodeAt</span>(f);</span><br><span class="line">        <span class="number">128</span> &gt; c ? g[d++] = c : (<span class="number">2048</span> &gt; c ? g[d++] = c &gt;&gt; <span class="number">6</span> | <span class="number">192</span> : (<span class="number">55296</span> == (c &amp; <span class="number">64512</span>) &amp;&amp; f + <span class="number">1</span> &lt; a.<span class="property">length</span> &amp;&amp; <span class="number">56320</span> == (a.<span class="title function_">charCodeAt</span>(f + <span class="number">1</span>) &amp; <span class="number">64512</span>) ? (c = <span class="number">65536</span> + ((c &amp; <span class="number">1023</span>) &lt;&lt; <span class="number">10</span>) + (a.<span class="title function_">charCodeAt</span>(++f) &amp; <span class="number">1023</span>), g[d++] = c &gt;&gt; <span class="number">18</span> | <span class="number">240</span>, g[d++] = c &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span> | <span class="number">128</span>) : g[d++] = c &gt;&gt; <span class="number">12</span> | <span class="number">224</span>, g[d++] = c &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span> | <span class="number">128</span>), g[d++] = c &amp; <span class="number">63</span> | <span class="number">128</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    a = h;</span><br><span class="line">    <span class="keyword">for</span> (d = <span class="number">0</span>; d &lt; g.<span class="property">length</span>; d++) a += g[d], a = <span class="title function_">b</span>(a, <span class="string">&quot;+-a^+6&quot;</span>);</span><br><span class="line">    a = <span class="title function_">b</span>(a, <span class="string">&quot;+-3^+b+-f&quot;</span>);</span><br><span class="line">    a ^= <span class="title class_">Number</span>(e[<span class="number">1</span>]) || <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> &gt; a &amp;&amp; (a = (a &amp; <span class="number">2147483647</span>) + <span class="number">2147483648</span>);</span><br><span class="line">    a %= <span class="number">1E6</span>;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() + <span class="string">&quot;.&quot;</span> + (a ^ h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中函数 <code>tk(a,TKK)</code> 的参数 <code>a</code> 是我们输入的内容，<code>TKK</code> 是刚才得到的值，直接调用 JS 代码就可以获得 <code>tk</code> 了</p>
<p>由于 <code>ScriptControl</code> ，C# 里面是可以直接调用 JS 代码的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MSScriptControl.ScriptControl scriptControl = <span class="keyword">new</span> MSScriptControl.ScriptControl();</span><br><span class="line">scriptControl.Language = <span class="string">&quot;JScript&quot;</span>;</span><br><span class="line">scriptControl.AddCode(JSCode);<span class="comment">// 刚刚的代码</span></span><br><span class="line"><span class="built_in">string</span> tk = scriptControl.Eval(<span class="string">&quot;...&quot;</span>); <span class="comment">// ...表示tk(a,TKK)，a 和 TKK 要替换成得到的值</span></span><br></pre></td></tr></table></figure>
<p>然后就可以正常的返回翻译结果了，注意重复调用时不用每次都先访问 <code>www.translate.google.cn</code> 获取 <code>TKK</code>，只用获取一次，然后动态根据输入的内容生成 <code>tk</code> 即可</p>
<p>歌词API代码：<a href="https://paste.ubuntu.com/p/sphY9vhVv9/">Ubuntu Pastebin</a><br>翻译API代码：<a href="https://paste.ubuntu.com/p/8yr7NwKSbx/">Ubuntu Pastebin</a>（感谢<a href="https://www.cnblogs.com/marso/p/google_translate_api.html"><strong>C#实现谷歌翻译API</strong></a>）</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C#.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期“毕设” -- Contest Killer</title>
    <url>/2022/08/19/2022-08-19-%E6%9A%91%E6%9C%9F%E6%AF%95%E8%AE%BE-Contest-Killer/</url>
    <content><![CDATA[<h3 id="暑期-“毕设”-——Contest-Killer"><a href="#暑期-“毕设”-——Contest-Killer" class="headerlink" title="暑期 “毕设” ——Contest Killer"></a>暑期 “毕设” ——Contest Killer</h3><h4 id="Contest-Killer"><a href="#Contest-Killer" class="headerlink" title="Contest Killer"></a>Contest Killer</h4><p>初学WPF，写了这个OI离线测评器</p>
<p>可以把它看成是CCR-Plus的换皮版（毕竟评测器部分的源代码都是照搬的…………）</p>
<p>因为UI字体普遍比较大，适合较大大屏幕的玩家使用</p>
<p>已开源，</p>
<p>Github：<a href="https://github.com/Yan2u/Contest_Killer">Yan2u/Contest_Killer: An offline judger for Olympiad in Informatics (github.com)</a></p>
<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>断断续续写了两个月……不断重复发现问题 + 上网查资料 + 现场学习 + 解决问题，纯面向问题编程了</p>
<p>虽然用了<code>viewmodel</code>和<code>command</code>，但是感觉自己还不是很懂MVVM，感觉用绑定事件来写也差不多</p>
<p>下一目标：用ASP.NET搭建自己的博客</p>
<p>加油：）</p>
<h4 id="一些截图"><a href="#一些截图" class="headerlink" title="一些截图"></a>一些截图</h4><p><img src="https://s1.ax1x.com/2022/08/19/vrxUzj.png" alt="vrxUzj.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrxNWQ.png" alt="vrxNWQ.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrxtJg.png" alt="vrxtJg.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrxwyn.png" alt="vrxwyn.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrxYFS.png" alt="vrxYFS.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrxDe0.png" alt="vrxDe0.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrx0Lq.png" alt="vrx0Lq.png (1688×1125) (ax1x.com)"></p>
<p><img src="https://s1.ax1x.com/2022/08/19/vrxrwV.png" alt="vrxrwV.png (1688×1125) (ax1x.com)"></p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>C#.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 | 线段树 | 0/1分数规划  \ | 图论  | 201901031考试：解题报告</title>
    <url>/2019/10/31/2019-10-31-exam/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="题目限制一览"><a href="#题目限制一览" class="headerlink" title="题目限制一览"></a>题目限制一览</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">题目</th>
<th style="text-align:center">时间限制</th>
<th style="text-align:center">空间限制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1. array</td>
<td style="text-align:center">1000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">2. bus</td>
<td style="text-align:center">2000 MS</td>
<td style="text-align:center">128 MB</td>
</tr>
<tr>
<td style="text-align:center">3. team</td>
<td style="text-align:center">3000 MS</td>
<td style="text-align:center">256 MB</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-逆序数对列（array-cpp）"><a href="#1-逆序数对列（array-cpp）" class="headerlink" title="1. 逆序数对列（array.cpp）"></a>1. 逆序数对列（array.cpp）</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于一个数列{ai}，如果有iaj，那么我们称ai与aj为一对逆序对数。若对于任意一个由1~n自然数组成的</p>
<p>数列，可以很容易求出有多少个逆序对数。那么逆序对数为k的这样自然数数列到底有多少个？</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行为两个整数n，k。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>写入一个整数，表示符合条件的数列个数，由于这个数可能很大，你只需输出该数对10000求余数后的结果。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">4 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>样例说明：</p>
<p>下列3个数列逆序对数都为1；分别是1 2 4 3 ；1 3 2 4 ；2 1 3 4；</p>
<p>100%的数据  n&lt;=1000，k&lt;=1000</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<ol>
<li><strong>正统解法</strong></li>
</ol>
</blockquote>
<p>设 $f[i][j]$ 表示 $1\rightarrow i$ 的排列中逆序对数为 $j$ 个的方案数</p>
<p>那么一些边界的情况就可以手算出来了，例如 $f[i][0]=1$，$f[i][1]=i-1$</p>
<p>接下来考虑怎么通过这个式子递推，可以考虑在已经形成的 $i-1$ 个排列中插入当前的数 $i$，这会导致增加一些逆序对数</p>
<p>设 $k$ 为增加的逆序对数，那么 $k\in[0,\;min(j,i-1)]$，即：$f[i][j]=\sum_{k=0}^{min(i-1,j)}f[i-1][j-k]$</p>
<p>再做个变形，$f[i][j]=\sum_{k=max(0,j-i+1)}^jf[i-1][k]$ ，到这一步递推的话，时间复杂度 $O(nk^2)$ ，有超时风险</p>
<p>但是我们发现 $k$ 是从 0 开始循环的，当 $i,j$ 固定时，$k$ 的区间 $[max(0,j-i+1),\;j]$ 也固定了，所以我们可以额外维护前缀和来快速的计算</p>
<blockquote>
<ol>
<li><strong>神奇乱搞解法</strong></li>
</ol>
</blockquote>
<p>考试的时候想出来的神奇乱搞解法，对于数据较小的时候，可以直接搜索，然后设 $f[i][j]$ 意义同上，观察表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$f[3][0\rightarrow3]$</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">2</th>
<th style="text-align:center">1</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$f[4][0\rightarrow6]$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$f[5][0\rightarrow10]$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">9</td>
<td style="text-align:center">15</td>
<td style="text-align:center">20</td>
<td style="text-align:center">22</td>
<td style="text-align:center">20</td>
<td style="text-align:center">15</td>
<td style="text-align:center">9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$f[6][0\rightarrow15]$</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">14</td>
<td style="text-align:center">29</td>
<td style="text-align:center">49</td>
<td style="text-align:center">71</td>
<td style="text-align:center">90</td>
<td style="text-align:center">101</td>
<td style="text-align:center">101</td>
<td style="text-align:center">90</td>
<td style="text-align:center">71</td>
<td style="text-align:center">49</td>
<td style="text-align:center">29</td>
<td style="text-align:center">14</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>后面数据太多就不放了，总之可以发现一个规律：</p>
<ol>
<li>当 $j&lt;i$ 时，$f[i][j]=f[i-1][j]+f[i][j-1]$</li>
<li>当 $i\leq j \leq \frac{i(i-1)}{4}$ 时，$f[i][j]=f[i-1][j]+f[i][j-1]-x$ </li>
<li>当 $\frac{i(i-1)}{4} \leq j \leq \frac{i(i-1)}{2}$ 时，$f[i][j]=f[i][\frac{i(i-1)}{2}-j]$ </li>
</ol>
<p>由于 $ 1 \rightarrow i$  的全排列最多有 $\frac{i(i-1)}{2}$ 对逆序对，所以 $j_{max}=\frac{i(i-1)}{2}$ ，接下来考虑 $x$ 的问题</p>
<p>可以发现，$f[i][j]$ 从 $j=i$ 开始减去的数，恰好是 $f[i-1]$ 的一行从 $j’=0$ 开始的项，随着 $j$ 往后移 $j’$ 也往后移动</p>
<p>于是这样一个神奇的递推式就写好了，时间复杂度 $ O(nk)$</p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line">ll f[maxn][maxn];</span><br><span class="line"><span class="type">int</span> n;<span class="type">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=<span class="number">1</span>,f[i][<span class="number">1</span>]=i<span class="number">-1</span>;</span><br><span class="line">	f[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">2</span>;f[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++) f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">		<span class="type">int</span> sub=<span class="number">0</span>,lim2=(i*(i<span class="number">-1</span>))&gt;&gt;<span class="number">2</span>,lim1=(i*(i<span class="number">-1</span>))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=lim2 &amp;&amp; j&lt;=k;j++,sub++)&#123;</span><br><span class="line">			f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][sub])%mod;</span><br><span class="line">			<span class="keyword">while</span>(f[i][j]&lt;<span class="number">0</span>) f[i][j]+=mod;f[i][j]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=lim2+<span class="number">1</span>;j&lt;=lim1 &amp;&amp; j&lt;=k;j++) f[i][j]=f[i][lim1-j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;array.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;array.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(k);</span><br><span class="line">	<span class="built_in">init</span>();<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n][k]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>{:. copyable}</p>
<hr>
<h2 id="2-公交线路（bus-cpp）"><a href="#2-公交线路（bus-cpp）" class="headerlink" title="2. 公交线路（bus.cpp）"></a>2. 公交线路（bus.cpp）</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>某城市的街道形成了一个棋盘网络 – 他们要么是北南走向要么就是西东走向.北南走向的路口从 1 到 n编号, 西东走向的路从1 到 m编号. 每个路口用两个数(i, j) 表示(1 &lt;= i &lt;= n, 1 &lt;= j &lt;= m).</p>
<p>该城市里有一条公交线, 在某一些路口设置了公交站点. 公交车从 (1, 1) 发车, 在(n, m)结束.公交车只能往北或往东走. 现在有一些乘客在某些站点等车. 公交车司机希望在路线中能接到尽量多的乘客.帮他想想怎么才能接到最多的乘客.</p>
<p>第一行一个数字 T 表示数据组数；</p>
<p>对于每组数据，</p>
<p>第一行两个数字 N,Q 分别表示 特殊位置数量和询问次数。</p>
<p>接下来 N 行，每行两个数字 Xi,Yi 表示特殊位置坐标；</p>
<p>接下来 Q 行，每行两个数字 S,T 表示询问起点坐标。</p>
<h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><p>一个数表示最多能接到的乘客数量.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">8 7 11</span><br><span class="line">4 3 4</span><br><span class="line">6 2 4</span><br><span class="line">2 3 2</span><br><span class="line">5 6 1</span><br><span class="line">2 5 2</span><br><span class="line">1 5 5</span><br><span class="line">2 1 1</span><br><span class="line">3 1 1</span><br><span class="line">7 7 1</span><br><span class="line">7 4 2</span><br><span class="line">8 6 2</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<h3 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h3><p>本题共 5 个测试点，每个测试点 20 分。</p>
<p>对于 20% 的数据，T=1,1≤N,Q≤5000,1≤S,T,Xi,Yi≤1000</p>
<p>对于 40% 的数据，所有数据中 N<em>Q 的总和不超过 5\</em>10^7</p>
<p>对于另外 20% 的数据，T=1,1≤S,T,Xi,Yi≤1000</p>
<p>对于 100% 的数据，N 的总和和 Q 的总和均不超过 10^6 ，1≤S,T,Xi,Yi≤10^9</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>考试时看到这个题，觉得很像以前做过的二维偏序问题，因为每个车站结点 $(x,\;y)$ 只能由 $(x’,\;y’)(x;\leq x,\;y’\leq y)$ 出发的公交车接客，所以可以用数据结构维护 $(x,\;y)$ 为右下角的矩形中的最大值</p>
<p><del>于是考场上 45min 敲代码+调试二维线段树结果 build 花了 1.8s+??? 怀疑人生</del></p>
<p>其实这题只需对$y$ 开一维线段树就可以轻松过了，因为 $x$ 轴的顺序可以直接一遍排序解决。。。</p>
<h3 id="Codes-1"><a href="#Codes-1" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fcin</span><span class="params">(t &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sign=<span class="number">1</span>; x=<span class="number">0</span>; <span class="type">char</span> op=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(op&lt;<span class="string">&#x27;0&#x27;</span>||op&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>;op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+(op<span class="number">-48</span>);op=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	x*=sign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,w;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;obj)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x!=obj.x) <span class="keyword">return</span> x&lt;obj.x;</span><br><span class="line">		<span class="keyword">return</span> y&lt;obj.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;d[maxn],dat[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn],c[maxn];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line">	st *lc,*rc;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="built_in">st</span>():<span class="built_in">lc</span>(<span class="number">0x0</span>),<span class="built_in">rc</span>(<span class="number">0x0</span>),<span class="built_in">val</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">()</span></span>&#123;</span><br><span class="line">		val=<span class="built_in">max</span>(lc-&gt;val,rc-&gt;val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">			val=<span class="built_in">max</span>(val,d);<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) lc-&gt;<span class="built_in">updata</span>(L,mid,x,d);</span><br><span class="line">		<span class="keyword">else</span> rc-&gt;<span class="built_in">updata</span>(mid+<span class="number">1</span>,R,x,d);</span><br><span class="line">		<span class="built_in">pushup</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">stmax</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=L &amp;&amp; R&lt;=y) <span class="keyword">return</span> val;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) ans=<span class="built_in">max</span>(ans,lc-&gt;<span class="built_in">stmax</span>(L,mid,x,y));</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) ans=<span class="built_in">max</span>(ans,rc-&gt;<span class="built_in">stmax</span>(mid+<span class="number">1</span>,R,x,y));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(st* &amp;p,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	p=<span class="keyword">new</span> <span class="built_in">st</span>();</span><br><span class="line">	<span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">		p-&gt;val=<span class="number">0</span>;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(p-&gt;lc,L,mid);</span><br><span class="line">	<span class="built_in">build</span>(p-&gt;rc,mid+<span class="number">1</span>,R);</span><br><span class="line">	p-&gt;<span class="built_in">pushup</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxDx,maxDy;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discret</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ed;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) c[i]=d[i].x;</span><br><span class="line">	<span class="built_in">sort</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>);</span><br><span class="line">	ed=<span class="built_in">unique</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>)-(c+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) </span><br><span class="line">		dat[i].x=<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+ed+<span class="number">1</span>,d[i].x)-c,</span><br><span class="line">		maxDx=<span class="built_in">max</span>(maxDx,dat[i].x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) c[i]=d[i].y;</span><br><span class="line">	<span class="built_in">sort</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>);</span><br><span class="line">	ed=<span class="built_in">unique</span>(c+<span class="number">1</span>,c+k+<span class="number">1</span>)-(c+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) </span><br><span class="line">		dat[i].y=<span class="built_in">lower_bound</span>(c+<span class="number">1</span>,c+ed+<span class="number">1</span>,d[i].y)-c,</span><br><span class="line">		maxDy=<span class="built_in">max</span>(maxDy,dat[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve_40</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(d+<span class="number">1</span>,d+k+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) f[i]=d[i].w;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(d[j].x&lt;=d[i].x &amp;&amp; d[j].y&lt;=d[i].y)</span><br><span class="line">				f[i]=<span class="built_in">max</span>(f[i],f[j]+d[i].w);</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">st *root;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;bus.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;bus.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">fcin</span>(n);<span class="built_in">fcin</span>(m);<span class="built_in">fcin</span>(k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="built_in">fcin</span>(d[i].x);</span><br><span class="line">		<span class="built_in">fcin</span>(d[i].y);</span><br><span class="line">		<span class="built_in">fcin</span>(d[i].w);</span><br><span class="line">		dat[i].w=d[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//if(k&lt;=10000) return solve_40();</span></span><br><span class="line">	<span class="built_in">discret</span>();</span><br><span class="line">	n=maxDx;m=maxDy;</span><br><span class="line">	<span class="built_in">build</span>(root,<span class="number">1</span>,m);</span><br><span class="line">	<span class="built_in">sort</span>(dat+<span class="number">1</span>,dat+k+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		cur=root-&gt;<span class="built_in">stmax</span>(<span class="number">1</span>,m,<span class="number">1</span>,dat[i].y);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,cur+dat[i].w);</span><br><span class="line">		root-&gt;<span class="built_in">updata</span>(<span class="number">1</span>,m,dat[i].y,cur+dat[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-最佳团体（team-cpp）"><a href="#3-最佳团体（team-cpp）" class="headerlink" title="3. 最佳团体（team.cpp）"></a>3. 最佳团体（team.cpp）</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h3><p>茜茜的舞蹈团队一共有N名候选人，这些候选人从1到N编号。方便起见，茜茜的编号是0号。每个候选人都由一位编号比他小的候选人Ri推荐。如果Ri=0则说明这个候选人是茜茜自己看上的。为了保证团队的和谐，茜茜需要保证，如果招募了候选人i，那么候选人Ri也一定需要在团队中。当然了，茜茜自己总是在团队里的。每一个候选人都有一个能力值Pi，也有一个招募费用Si。茜茜希望招募K个候选人（茜茜自己不算），组成一个性价比最高的团队。也就是，这K个被茜茜选择的候选人的总能力值与总招募总费用的比值最大。</p>
<h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><p>输入一行包含两个正整数K和N。</p>
<p>接下来N行，其中第i行包含3个整数Si,Pi,Ri表示候选人i的招募费用，战斗值和推荐人编号。 </p>
<h3 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个实数，表示最佳比值。答案保留三位小数。</p>
<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1000 1 0</span><br><span class="line">1 1000 1</span><br></pre></td></tr></table></figure>
<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0.001</span><br></pre></td></tr></table></figure>
<h3 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h3><p>对于100%的数据满足 $1\leq K\leq N \leq 2500,\;0\leq S_i,P_i\leq 10^4,\;0\leq R_i\leq i$</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这是一道 $0/1$ 分数规划的题目，但是由于<del>我根本没学过</del>导致只能写爆搜爆0</p>
<p>借着这个题来回顾一下 $0/1$ 分数规划的解题思路吧</p>
<p>首先，题目要求的是一个总战斗力和总费用的比值最大值，设比值为 $k$，战斗力为 $v[i]$，费用为 $w[i]$</p>
<p><strong>那么 $k<em>{max}=\frac{\sum v[i]}{\sum w[i]}$，把这个分式化成整式，得到：$k</em>{max}\sum w[i]=\sum v[i]$ ，移项得到 $\sum v[i]-k_{max}\sum w[i]\geq 0$</strong></p>
<p>那么我们就可以二分 $k_{max}$，然后更新 $v$ 数组，然后树上 DP 看能否满足结果 $\geq 0$</p>
<p>设 $f[i][j]$ 表示以 $i$ 为根的子树里面，选择 $j$ 个得到的最大 $v$ 值（$v$ 值已经减去 $k_{max}w[i]$），对于每个推荐人 $R[i]$ ，将这个推荐人 $R[i]$ 与他推荐的所有人连一条边，$R[i]$ 为父结点，$i$ 为儿子结点，就能符合题目选择的要求了</p>
<p>对于茜茜自己，根据题意设为 $0$ 号结点，由于最终茜茜自己也在团体里面，所以答案为 $f[0][k+1]$</p>
<p>这个 DP 的转移方程也很好写：$f[i][j]=max(f[i][j],\;f[i][k]+f[s][j-k])\;(s\in son[i])$ </p>
<p>然后是实数域上的二分精度问题，事实上这个题的树上背包做法是 $O(nk^2)$ 时间复杂度（正解是 DFS 序不想再写了），所以注意控制精度问题，实测 $1e-4$ 足矣，平时使用的 $1e-8$ 甚至 $1e-10$ 都有可能 TLE</p>
<h3 id="Codes-2"><a href="#Codes-2" class="headerlink" title="Codes"></a>Codes</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 2505</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxm maxn&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)/2.0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> to[maxm],nxt[maxm],head[maxn];</span><br><span class="line"><span class="type">double</span> cost[maxn];</span><br><span class="line"><span class="type">double</span> v[maxn],src[maxn];</span><br><span class="line"><span class="type">int</span> n,k,tot;</span><br><span class="line"><span class="type">double</span> f[maxn][maxn];</span><br><span class="line"><span class="type">int</span> siz[maxn];</span><br><span class="line"><span class="type">double</span> d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Eadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	to[++tot]=v;nxt[tot]=head[u];</span><br><span class="line">	head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u][<span class="number">0</span>]=<span class="number">0.0</span>; f[u][<span class="number">1</span>]=v[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i]==pre) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">check</span>(to[i],u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=siz[u]+siz[to[i]];j++) d[j]=<span class="number">-2147483647.0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=siz[u];j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;=siz[to[i]];p++) d[j+p]=<span class="built_in">max</span>(d[j+p],f[u][j]+f[to[i]][p]);</span><br><span class="line">		siz[u]+=siz[to[i]];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=siz[u];j++) f[u][j]=d[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;team.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;team.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;n);<span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;cost[i],&amp;src[i]);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="built_in">Eadd</span>(x,i);<span class="built_in">Eadd</span>(i,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">double</span> L=<span class="number">0.0</span>,R=<span class="number">10000.0</span>;</span><br><span class="line">	<span class="keyword">while</span>(R-L&gt;=INF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			v[i]=src[i]-mid*cost[i];</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">check</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(f[<span class="number">0</span>][k+<span class="number">1</span>]&gt;<span class="number">0</span>) L=mid;</span><br><span class="line">		<span class="keyword">else</span> R=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>,L);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>Neumorphism UI： 新拟态设计</title>
    <url>/2020/03/17/2020-03-17-Neumorphic/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="新拟态设计：Neumorphism-UI"><a href="#新拟态设计：Neumorphism-UI" class="headerlink" title="新拟态设计：Neumorphism UI"></a>新拟态设计：Neumorphism UI</h2><h3 id="Neumorphism-UI"><a href="#Neumorphism-UI" class="headerlink" title="Neumorphism UI"></a>Neumorphism UI</h3><blockquote>
<p>新拟态设计（Neumorphism UI）是 2020 年 UI 设计的主要趋势之一，你可以在 dribbble 上看到很多作品，新拟态是基于New+Skeuomorphism 英文单词的拼写。它是一种使用对象阴影的模糊、角度和强度来突显出对象的样式。由于其柔和的阴影和整体的外观，使该设计看起来更加的逼真、未来、现代、真实、有吸引力。</p>
</blockquote>
<p>拟态，在<a href="https://baike.baidu.com/item/拟态/472739">生物学</a>中指的是<strong>一种生物模拟另一种生物或模拟环境中的其他物体从而获得好处的现象</strong>，用在 UI 设计上，即是让 UI 元素模拟生活中的物体的形状与特征（就像桌面的垃圾桶图标那样），从而让 UI 元素具有生活中物体的层次感和辨识度</p>
<p>新拟态结合目前比较流行的扁平化设计和卡片式设计和拟态的设计风格，起源于一套在 dribbble 上走红的设计方案：</p>
<p><img src="http://image.woshipm.com/wp-files/2020/02/7xWL5aZvTPRPxHStcRP9.jpeg" alt="pic0"></p>
<p>设计师 alexplyuto 发表了这套设计方案，获得数千点赞，之后类似风格的新拟态设计大量出现，可以说他的作品开创了 UI 设计的一个新趋势</p>
<p>个人感觉这套设计方案很有现代感，简洁的同时有富含层次感，可以感觉到每一个元素仿佛都是雕刻在了背景上</p>
<h3 id="Neumorphic-UI-amp-Modern-UI"><a href="#Neumorphic-UI-amp-Modern-UI" class="headerlink" title="Neumorphic UI &amp; Modern UI"></a>Neumorphic UI &amp; Modern UI</h3><p><img src="http://image.woshipm.com/wp-files/2020/02/GbiMEQ69KwHRIxL9vFZC.jpeg" alt="pic1"></p>
<p>上图体现了新拟态的卡片设计和传统的 Material 卡片设计的差别，其中 Material 的卡片阴影设计，让人感觉它是漂浮在空中，主要是在元素下方出现阴影，这样使得元素与背景之间产生一种空间纵深感，<strong>而新拟态的卡片式设计通过2个正负阴影叠加，让卡片看起来更像是雕刻在了背景上，成为背景的一块突起</strong>，但是两者在与背景颜色的对比上都不是很明显</p>
<h3 id="只能用来设计卡片吗？"><a href="#只能用来设计卡片吗？" class="headerlink" title="只能用来设计卡片吗？"></a>只能用来设计卡片吗？</h3><p>Neumorphic UI 并不仅限于卡片设计，只要把原来正负的阴影对调，很容易就可以实现一个按钮被点击的效果：</p>
<p><img src="http://image.woshipm.com/wp-files/2020/02/zOgX616cuHwLoWl7L5j4.jpeg" alt="pic3"></p>
<p>但是这样会充分暴露出 Neumorphic UI 中元素和背景颜色对比度不足的问题，使得点击效果看起来不明显，UI 首先应确保易用性，因此可考虑以改用如下设计：</p>
<p><img src="http://image.woshipm.com/wp-files/2020/02/BBOUvTfvqWGcZs3tevhf.jpeg" alt="pic4"></p>
<h3 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h3><p>Neumorphic UI 主要通过控件左上边缘的正阴影和右下边缘的负阴影实现，当然你也可以改变正负阴影的位置：</p>
<p><img src="http://image.woshipm.com/wp-files/2020/02/iVjcJsSflJkHLykgr07W.jpeg" alt="pic4"></p>
<p>如果要设计一个按钮，在 hover 样式里，对调这两个阴影即可（或者加上 inset）</p>
<p>下面是一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#ffffff</span>;</span><br><span class="line"><span class="attribute">box-shadow</span>:  <span class="number">35px</span> <span class="number">35px</span> <span class="number">71px</span> <span class="number">#d9d9d9</span>, </span><br><span class="line">             -<span class="number">35px</span> -<span class="number">35px</span> <span class="number">71px</span> <span class="number">#ffffff</span>;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>这一设计趋势的出现，无疑激发了许多设计师的灵感，与以前使用的卡片组件的可用性问题相比，它的问题其实并不是那么严重。</p>
<p>所以疯狂大胆的去尝试吧！顺应这一趋势，并对其进行调整，使它成为你自己的风格。UI设计师的工作就是在拖动方块，因此每次方块出现“差异”和“新奇”时，都会带来一些喜悦之感。如果没有这种不断的探索的精神，那么所有的产品看起来都是一毛一样。</p>
<p>让我们找点乐子！</p>
<p>但同时也要记住，每个新趋势都有一些潜在的陷阱，必须谨慎对待，才能让它得以使用。</p>
</blockquote>
<p>Neumorphic UI 毕竟是新出现的设计风格，肯定还有不成熟的地方，但是它的简洁和层次感的结合使得整个界面非常具有现代感</p>
<p>另一方面，Neumorphic UI 的缺点其实也比较明显，例如：</p>
<ul>
<li>色调单一，对视力低下、失明、色盲的用户来说，可辨识性较差</li>
<li>区分度较差，可以发现 Neumorphic UI 作为区分标志的只有阴影，因为它卡片的材质纹理和背景是一样的，如果失去了阴影效果，整个界面就会变成一片</li>
<li>突出的元素密集，Neumorphic UI 主要呈现元素的方式便是类似于突出的两个阴影，但若界面上元素密集，这样的突出效果会使得元素之间失去主次性，导致用户不能把注意集中到某个需要与之交互的元素上</li>
<li>造成一定的混乱，在 Neumorphic UI 设计下，被 Disable 的元素和被 Enable 的元素将不易于区分</li>
</ul>
<p>对此，我的理解是，如果界面上的元素简洁大气，可以考虑采用这种设计方法，如果界面上元素密集丰富，则在采用之前需要优化或改进</p>
<h3 id="样图"><a href="#样图" class="headerlink" title="样图"></a>样图</h3><p>以下是采用 Neumorphic UI 设计的概念图：</p>
<blockquote>
<p>个人简介页面 &amp; 航班查询页面</p>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2020/02/uisdc-hw-20200222-4.jpg" alt="example0"></p>
<blockquote>
<p>拟遥控器，这应该是最能体现 Neumorphic UI 设计风格的了，它的阴影效果好像就是在模仿遥控器按键的效果</p>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2020/02/uisdc-hw-20200222-7.jpg" alt="example1"></p>
<blockquote>
<p>智能家居仪表盘</p>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2020/02/uisdc-hw-20200222-3.jpeg" alt="example2"></p>
<blockquote>
<p>智能家居仪表盘 2</p>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2020/02/uisdc-hw-20200222-1.jpeg" alt="example3"></p>
<blockquote>
<p>智能家居仪表盘 3</p>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2020/02/uisdc-hw-20200222-5.jpg" alt="example4"></p>
<blockquote>
<p>拟播放器</p>
</blockquote>
<p><img src="https://image.uisdc.com/wp-content/uploads/2020/02/uisdc-hw-20200222-6.jpg" alt="example 4"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>白嫖了 Neumorphic UI 的一点点代码，我写了一个能在 QQ 音乐上搜歌的网页：<a href="http://wuyanxi.top/QQMusicSearch.html">QQMusicSearcher</a></p>
<p>个人感觉，Neumorphic UI 在简洁的场合下使用会有意想不到的效果，也希望这套设计方案能逐渐改进，走向成熟并流行起来</p>
<p>2020 - 03 - 17</p>
<p>感谢阅读~~</p>
<hr>
<p>本文中部分内容摘取自：</p>
<ol>
<li><a href="http://www.woshipm.com/pd/3386232.html">新拟态——国外设计师分析的全新UI趋势</a></li>
<li><a href="https://www.uisdc.com/neumorphism-ui">为什么2020年初爆火的新拟物化设计，完全无法落地使用？</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>Deepin 初体验</title>
    <url>/2020/03/19/2020-03-19-Deepin/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="Deepin-初体验"><a href="#Deepin-初体验" class="headerlink" title="Deepin 初体验"></a>Deepin 初体验</h2><p>家里的古董笔记本好像带不动最新的 Windows10 了，最近使用体验比较差，但平时又不怎么用它……</p>
<p>那么，何不拿这台笔记本搞点事儿呢？？</p>
<p>想起以前在网上看到基于 Linux 的 Deepin OS 的时候，被它高端大气上档次的界面吸引了（然后尝试用VMWare装但是失败……），于是这次我打算动真格，直接在笔记本上安装 Deepin OS！</p>
<h3 id="安装-Deepin"><a href="#安装-Deepin" class="headerlink" title="安装 Deepin"></a>安装 Deepin</h3><p>首先 Deepin 官网本身的下载链接速度奇慢，这里推荐使用清华的镜像源下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/deepin-cd/15.11/">Deepin-CD</a></p>
<p>打开之后选择 <a href="https://mirrors.tuna.tsinghua.edu.cn/deepin-cd/15.11/deepin-15.11-amd64.iso">Deepin-15.11-amd64.iso</a> 下载镜像文件</p>
<p>之后就是用 UltraISO 烧录启动盘，然后开机 F2 进入 Boot 界面，选择 USB-HDD 启动</p>
<p>启动之后成功进入安装界面，按照提示操作一波之后，安装成功</p>
<blockquote>
<p><strong>图是网上找的：)</strong></p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20180102133551043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGliZXJhbGxpdXNoYWhl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="pic0"></p>
<h3 id="配置-Deepin"><a href="#配置-Deepin" class="headerlink" title="配置 Deepin"></a>配置 Deepin</h3><p>进入桌面，发现 Deepin 已经自带了 Chrome，WPS Office，搜狗输入法，和虽然是上古版本的 QQ，感觉比安装 Manjaro 的时候一个个手动 <code>sudo pacman -S ...</code> 方便了许多（最蛋疼的是输入法配置）</p>
<p>Deepin 还有自带的应用商店，你可以直接去商店里安装而不是 <code>sudo apt-get install ...</code> ，去商店里看了看，收录的应用还是挺多，至少常用的几个（网易云音乐，VS Code等）可以直接安装了</p>
<p>顺便说一句，这个窗口的标题栏是真的宽，用网上的方法修改了配置文件之后好像也没什么用……</p>
<p>不过总之，个人觉得 Deepin OS 的界面还是要比原生 Windows 10 好看了一些，下面是经过了一些简陋配置后的效果：</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cl4Ag.png" alt="pic1"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>其实，选择 Linux，一方面是为了新鲜感，另一方面是因为这台古董笔记本也平时确实也派不上什么用场，所以整个新系统玩玩，目前来看，体验也确实挺不错的，对于只有办公和上网需求的用户来说，我觉得这款 OS 是可以替代一下 Windows 的：）</p>
<blockquote>
<p>用 VSCode 写 C#</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/03/20/8c12G9.png" alt="pic2"></p>
<p>Linux 下 C#.NET 的代码可以用一个叫 MonoCompiler 的编译器编译，但是生成了是 Windows 的 exe 文件，这种 exe 只能用 MonoCompiler 自己打开</p>
<p>除此之外，也可以在 VSCode 安装 C# 扩展来编译 ，但是需要手动安装 SDK</p>
<p>顺手写了一个 Hanoi：</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8cJb0P.png" alt="pich"></p>
<blockquote>
<p>Typora</p>
</blockquote>
<p>这篇文章就是在 Deepin OS 下用 Typora 写的，由于 Deepin OS 自带思源黑体，原本的 Github 主题好看了很多，思源黑体是 Deepin 的默认字体，看起来觉得比 Windows 的微软雅黑要清晰？？</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8c3PiQ.png" alt="pic3"></p>
<blockquote>
<p>QQ</p>
</blockquote>
<p>在应用商店可以搜索到，不过这个 QQ 已经是上古版本了……</p>
<p>如果想要下载最新版的，可以去 QQ 官网看一下</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8c3lW9.png" alt="pic4"></p>
<blockquote>
<p>钉钉 &amp; 智学网</p>
</blockquote>
<p>没想到钉钉连 Linux 版的都做了，果然是换了系统也不能忘记学习啊！</p>
<p><img src="https://s1.ax1x.com/2020/03/20/8c3zlR.png" alt="pic5"></p>
<p>暂时就先写到这儿吧，等以后再整整这个奇妙的 OS……</p>
]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
